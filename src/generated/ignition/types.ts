/* eslint-disable */
/* AUTO-GENERATED FILE. DO NOT EDIT MANUALLY. */
export type Maybe<T> = T;
export type InputMaybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T
> = { [_ in K]?: never };
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
    };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  /** Represents non-fractional signed whole numeric values. */
  BigInt: { input: any; output: any };
  CountryCode: { input: any; output: any };
  /** ISO8601 formatted date (yyyy-mm-dd) */
  Date: { input: any; output: any };
  DateTime: { input: any; output: any };
  Decimal: { input: any; output: any };
  EmailAddress: { input: any; output: any };
  /** Returns safe HTML sanitised with permitted tags */
  Html: { input: any; output: any };
  IpAddress: { input: any; output: any };
  PhoneNumber: { input: any; output: any };
  /** Recurrence rule in serialised iCal format. */
  RecurrenceRuleInput: { input: any; output: any };
  /** Deprecated - use the Html type instead */
  RichText: { input: any; output: any };
  ShortURL: { input: any; output: any };
  URL: { input: any; output: any };
};

export type AcceptanceEmail = {
  __typename: 'AcceptanceEmail';
  /** @deprecated Use the safeHtml type instead. */
  html: Scalars['String']['output'];
  safeHtml: Scalars['Html']['output'];
  subject: Scalars['String']['output'];
  template: EmailTemplate;
};

export type Account = {
  __typename: 'Account';
  accountType?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  importedFrom?: Maybe<AccountImportedFrom>;
  name: Scalars['String']['output'];
  state: AccountState;
  updatedAt: Scalars['DateTime']['output'];
  /** @deprecated use id instead */
  uuid: Scalars['ID']['output'];
};

/** The connection type for Account. */
export type AccountConnection = {
  __typename: 'AccountConnection';
  /** A list of edges. */
  edges: Array<AccountEdge>;
  /** A list of nodes. */
  nodes: Array<Account>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AccountEdge = {
  __typename: 'AccountEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Account;
};

export enum AccountImportedFrom {
  /** Xero */
  XERO = 'XERO',
}

export type AccountQuery = {
  importedFromEq?: InputMaybe<Scalars['String']['input']>;
};

export enum AccountState {
  /** Active */
  ACTIVE = 'ACTIVE',
  /** Archived */
  ARCHIVED = 'ARCHIVED',
}

export type AcknowledgeFilter = {
  idCont?: InputMaybe<Scalars['String']['input']>;
  idStartsWith?: InputMaybe<Scalars['String']['input']>;
};

export type Acknowledgement = {
  __typename: 'Acknowledgement';
  id: Scalars['ID']['output'];
  level: AcknowledgementLevel;
  updatedAt: Scalars['DateTime']['output'];
};

/** Autogenerated input type of AcknowledgementAdd */
export type AcknowledgementAddInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** identifier of acknowledgement content */
  id: Scalars['ID']['input'];
  level: AcknowledgementLevel;
};

/** Autogenerated return type of AcknowledgementAdd. */
export type AcknowledgementAddPayload = {
  __typename: 'AcknowledgementAddPayload';
  acknowledgement?: Maybe<Acknowledgement>;
  acknowledgements: Array<Acknowledgement>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export enum AcknowledgementLevel {
  PRACTICE = 'PRACTICE',
  USER = 'USER',
}

/** Autogenerated input type of AcknowledgementRemove */
export type AcknowledgementRemoveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** identifier of acknowledgement content */
  id: Scalars['ID']['input'];
  level: AcknowledgementLevel;
};

/** Autogenerated return type of AcknowledgementRemove. */
export type AcknowledgementRemovePayload = {
  __typename: 'AcknowledgementRemovePayload';
  acknowledgements: Array<Acknowledgement>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export type ActivityLog = {
  __typename: 'ActivityLog';
  additionalInfo?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  level: ActivityLogLevel;
  message: Scalars['String']['output'];
  relationId: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
  /** The user associated with the activity (if any). */
  user?: Maybe<User>;
};

/** The connection type for ActivityLog. */
export type ActivityLogConnection = {
  __typename: 'ActivityLogConnection';
  /** A list of edges. */
  edges: Array<ActivityLogEdge>;
  /** A list of nodes. */
  nodes: Array<ActivityLog>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ActivityLogEdge = {
  __typename: 'ActivityLogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ActivityLog;
};

export enum ActivityLogLevel {
  ERROR = 'ERROR',
  INFO = 'INFO',
  SUCCESS = 'SUCCESS',
  WARNING = 'WARNING',
}

export type ActivityLogOrder = {
  /** Sort by when the activity log was created. */
  createdAt?: InputMaybe<OrderBy>;
};

/** An address */
export type Address = {
  __typename: 'Address';
  /** @deprecated use lines instead */
  address?: Maybe<Scalars['String']['output']>;
  /** City or Suburb */
  city?: Maybe<Scalars['String']['output']>;
  client: Client;
  /** Full country name */
  country?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  isPostal: Scalars['Boolean']['output'];
  /** Free text part of an address with each line a separate entry. Usually one or two */
  lines: Array<Scalars['String']['output']>;
  /** @deprecated Use postcode */
  postCode?: Maybe<Scalars['String']['output']>;
  postcode?: Maybe<Scalars['String']['output']>;
  referenceNumber: Scalars['ID']['output'];
  /** Region or State */
  region?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for Address. */
export type AddressConnection = {
  __typename: 'AddressConnection';
  /** A list of edges. */
  edges: Array<AddressEdge>;
  /** A list of nodes. */
  nodes: Array<Address>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AddressEdge = {
  __typename: 'AddressEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Address;
};

export type AddressFilter = {
  isPostal?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AddressInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  lines?: InputMaybe<Array<Scalars['String']['input']>>;
  postCode?: InputMaybe<Scalars['String']['input']>;
  postcode?: InputMaybe<Scalars['String']['input']>;
  region?: InputMaybe<Scalars['String']['input']>;
};

export type AdminUser = {
  __typename: 'AdminUser';
  createdAt: Scalars['DateTime']['output'];
  email: Scalars['EmailAddress']['output'];
  id: Scalars['ID']['output'];
  roles: Array<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

export type AgreedService = {
  __typename: 'AgreedService';
  /**
   * The Xero Integration account this service will be accounted to when invoiced
   * @deprecated use ledgerItem
   */
  account?: Maybe<Account>;
  activities: ActivityLogConnection;
  /** @deprecated Agreed Service can have multiple portions. Use `portion.billing_description` instead. */
  billingDescription?: Maybe<Scalars['String']['output']>;
  billingMode: ProposalBillingModeEnum;
  /** @deprecated Use portions { billingSchedule } instead */
  billingSchedule: BillingSchedule;
  /** @deprecated Agreed Service can have multiple portions. Use `portion.billing_summary` instead. */
  billingSummary?: Maybe<Scalars['String']['output']>;
  client: Client;
  description: Textile;
  discount:
    | BillingAmountDiscountRule
    | BillingNoneDiscountRule
    | BillingPercentDiscountRule;
  /**
   * The date this service is scheduled to becomes inactive, provided all
   * associated billing items have been billed. If not set, service will stay
   * active until ended manually.
   */
  expiresOn?: Maybe<Scalars['Date']['output']>;
  /** checks to see if the description is blank (true = blank) */
  hasBlankDescription: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** @deprecated use portions { invoiceStrategy } instead */
  invoiceStrategy?: Maybe<ProposalInvoiceStrategy>;
  /** @deprecated Use state instead. An agreed service is active if it's state = 'enabled'. */
  isActive: Scalars['Boolean']['output'];
  isBillingCompleted: Scalars['Boolean']['output'];
  isEditable: Scalars['Boolean']['output'];
  lastBillingDate?: Maybe<Scalars['Date']['output']>;
  /** Ledger Item. Currently only supports Xero account */
  ledgerItem?: Maybe<LedgerItem>;
  name: Scalars['String']['output'];
  origin?: Maybe<Origin>;
  paymentMethod?: Maybe<PaymentMethod>;
  portions: Array<AgreedServicePortion>;
  price:
    | ProposalFixedPrice
    | ProposalIncludedPrice
    | ProposalMinimumPrice
    | ProposalPriceRange
    | ProposalUnitPrice;
  /** Quantity Object containing amounts and rules */
  quantity?: Maybe<
    BillingEstimateQuantityRule | BillingSmartBillingQuantityRule
  >;
  /** If set, this is the agreed service that was / will be replaced once this agreed service is enabled. */
  replacee?: Maybe<AgreedService>;
  /** If set, this is the agreed service that will replace / has replaced this one. */
  replacement?: Maybe<AgreedService>;
  /** List of billing schedule items for all billable services linked to this agreed service */
  scheduleItems: Array<ScheduleItem>;
  /** @deprecated Agreed Service can have multiple portions. Use `portion.schedule_start` instead. */
  scheduleStart: Scalars['String']['output'];
  scheduleType: BillingScheduleTypeEnum;
  service: Service;
  /** The date this service becomes active. */
  startsOn: Scalars['Date']['output'];
  state: ClientServicesAgreedServiceStateEnum;
  /** The tax applied to this service */
  tax: Tax;
  uneditableReason?: Maybe<Scalars['String']['output']>;
};

export type AgreedServiceActivitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ActivityLogOrder>;
};

/** The connection type for AgreedService. */
export type AgreedServiceConnection = {
  __typename: 'AgreedServiceConnection';
  /** A list of edges. */
  edges: Array<AgreedServiceEdge>;
  /** A list of nodes. */
  nodes: Array<AgreedService>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type AgreedServiceCreatePreview = {
  __typename: 'AgreedServiceCreatePreview';
  billingItems: Array<BillingItemPreview>;
  billingSummary: Scalars['String']['output'];
  paymentMethod?: Maybe<PaymentMethod>;
};

/** An edge in a connection. */
export type AgreedServiceEdge = {
  __typename: 'AgreedServiceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: AgreedService;
};

export type AgreedServiceFilter = {
  stateIn?: InputMaybe<Array<ClientServicesAgreedServiceStateEnum>>;
};

export type AgreedServiceInput = {
  accountId?: InputMaybe<Scalars['ID']['input']>;
  description: Scalars['String']['input'];
  discount?: InputMaybe<DiscountRuleInput>;
  portions: Array<PortionInput>;
  quantity?: InputMaybe<QuantityRuleInput>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  serviceName?: InputMaybe<Scalars['String']['input']>;
  taxId: Scalars['ID']['input'];
};

export type AgreedServicePortion = {
  __typename: 'AgreedServicePortion';
  billingDescription: Scalars['String']['output'];
  billingStart: ProposalStartBillingOnDate;
  billingSummary: Scalars['String']['output'];
  discount:
    | BillingAmountDiscountRule
    | BillingNoneDiscountRule
    | BillingPercentDiscountRule;
  id: Scalars['ID']['output'];
  invoiceStrategy: ProposalInvoiceStrategy;
  name?: Maybe<Scalars['String']['output']>;
  price:
    | ProposalFixedPrice
    | ProposalIncludedPrice
    | ProposalMinimumPrice
    | ProposalPriceRange
    | ProposalUnitPrice;
  recurrence: ProposalBillingStrategyType;
  rrule?: Maybe<RecurrenceRule>;
  scheduleStart: Scalars['String']['output'];
};

export type AgreedServiceUpdatePreview = {
  __typename: 'AgreedServiceUpdatePreview';
  billingItems: Array<BillingItem>;
  billingSummary: Scalars['String']['output'];
  changedValues: Array<ChangedValue>;
  scheduleChangeDate?: Maybe<Scalars['Date']['output']>;
};

/** Discount specified as a currency amount */
export type AmountDiscountRuleInput = {
  /** Discount amount */
  amount: MoneyInput;
};

/**
 * An App is an integration that implements generic, defined functionality that
 * extends core functionality, usually by integrating with an external system.  For
 * example, a Xero App may deploy client billing invoices to Xero.  These defined
 * functionalities are called Capabilities.  An App returned through this API is
 * Practice specific- the same App type may have different capabilities for
 * different Practices
 */
export type App = {
  __typename: 'App';
  appClients: AppClientConnection;
  /** AppServices in a search results format */
  appServices?: Maybe<SearchQuery>;
  appTaxes: AppTaxConnection;
  appUsers: AppUserConnection;
  /** Capabilities are standard functionality that this App implements. A list of capabilities. */
  capabilities: Array<CapabilityWithState>;
  clientSyncSettings?: Maybe<ClientSyncSettings>;
  /** The name of this App to be shown in the user interface */
  displayName: Scalars['String']['output'];
  /** A publicly available URL with the icon of the App */
  icon: Scalars['URL']['output'];
  /** A unique identifier for this App */
  id: Scalars['ID']['output'];
  invoiceDeploySettings?: Maybe<InvoiceDeploySettings>;
  /** The most recent client sync result (if any). */
  latestClientSync?: Maybe<ClientSync>;
  ledgerItems: LedgerItemConnection;
  /** A publicly available URL with the logo of the App */
  logo: Scalars['URL']['output'];
  /** The globally unique name of this App */
  name: Scalars['String']['output'];
  userConfigurable?: Maybe<UserConfigurable>;
  workflowCategories: WorkflowCategoryTypeConnection;
  workflowTemplates: WorkflowTemplateTypeConnection;
};

/**
 * An App is an integration that implements generic, defined functionality that
 * extends core functionality, usually by integrating with an external system.  For
 * example, a Xero App may deploy client billing invoices to Xero.  These defined
 * functionalities are called Capabilities.  An App returned through this API is
 * Practice specific- the same App type may have different capabilities for
 * different Practices
 */
export type AppAppClientsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AppClientFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * An App is an integration that implements generic, defined functionality that
 * extends core functionality, usually by integrating with an external system.  For
 * example, a Xero App may deploy client billing invoices to Xero.  These defined
 * functionalities are called Capabilities.  An App returned through this API is
 * Practice specific- the same App type may have different capabilities for
 * different Practices
 */
export type AppAppServicesArgs = {
  asyncJobGroupId?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<IgnitionAppServiceFilterType>;
  pagination?: InputMaybe<PaginationInput>;
  sort?: InputMaybe<SearchQuerySortInput>;
};

/**
 * An App is an integration that implements generic, defined functionality that
 * extends core functionality, usually by integrating with an external system.  For
 * example, a Xero App may deploy client billing invoices to Xero.  These defined
 * functionalities are called Capabilities.  An App returned through this API is
 * Practice specific- the same App type may have different capabilities for
 * different Practices
 */
export type AppAppTaxesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AppTaxFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * An App is an integration that implements generic, defined functionality that
 * extends core functionality, usually by integrating with an external system.  For
 * example, a Xero App may deploy client billing invoices to Xero.  These defined
 * functionalities are called Capabilities.  An App returned through this API is
 * Practice specific- the same App type may have different capabilities for
 * different Practices
 */
export type AppAppUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AppUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * An App is an integration that implements generic, defined functionality that
 * extends core functionality, usually by integrating with an external system.  For
 * example, a Xero App may deploy client billing invoices to Xero.  These defined
 * functionalities are called Capabilities.  An App returned through this API is
 * Practice specific- the same App type may have different capabilities for
 * different Practices
 */
export type AppCapabilitiesArgs = {
  filter?: InputMaybe<AppCapabilityFilter>;
};

/**
 * An App is an integration that implements generic, defined functionality that
 * extends core functionality, usually by integrating with an external system.  For
 * example, a Xero App may deploy client billing invoices to Xero.  These defined
 * functionalities are called Capabilities.  An App returned through this API is
 * Practice specific- the same App type may have different capabilities for
 * different Practices
 */
export type AppLedgerItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * An App is an integration that implements generic, defined functionality that
 * extends core functionality, usually by integrating with an external system.  For
 * example, a Xero App may deploy client billing invoices to Xero.  These defined
 * functionalities are called Capabilities.  An App returned through this API is
 * Practice specific- the same App type may have different capabilities for
 * different Practices
 */
export type AppWorkflowCategoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * An App is an integration that implements generic, defined functionality that
 * extends core functionality, usually by integrating with an external system.  For
 * example, a Xero App may deploy client billing invoices to Xero.  These defined
 * functionalities are called Capabilities.  An App returned through this API is
 * Practice specific- the same App type may have different capabilities for
 * different Practices
 */
export type AppWorkflowTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Type for filtering App Capabilitites */
export type AppCapabilityFilter = {
  /** State of Capabilitites */
  state?: InputMaybe<CapabilityStateEnum>;
};

/**
 * An AppClient is a counterpart to a Client that exists in an App's domain.
 * AppClients can be linked ("mapped") to Clients, and can be used to create
 * Clients. For example, a Customer in QuickBooks or Contact in Xero could be the
 * underlying record behind an AppClient.
 */
export type AppClient = ClientInterface & {
  __typename: 'AppClient';
  app: App;
  company: AppClientCompany;
  contacts: AppClientContactConnection;
  defaultContact: AppClientContact;
  /** @deprecated Use contacts or defaultContact.email */
  email?: Maybe<Scalars['String']['output']>;
  /** An identifier used by the App this AppClient belongs to */
  externalId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  /** Slug of the manager user */
  managerId?: Maybe<Scalars['String']['output']>;
  /** Full name */
  name: Scalars['String']['output'];
  /** Slug of the partner user */
  partnerId?: Maybe<Scalars['String']['output']>;
  physicalAddress?: Maybe<AppClientAddress>;
  postalAddress?: Maybe<AppClientAddress>;
  /** Tags associated with this AppClient */
  tags: Array<Scalars['String']['output']>;
  /** Link to view this AppClient in external system */
  url?: Maybe<Scalars['String']['output']>;
};

/**
 * An AppClient is a counterpart to a Client that exists in an App's domain.
 * AppClients can be linked ("mapped") to Clients, and can be used to create
 * Clients. For example, a Customer in QuickBooks or Contact in Xero could be the
 * underlying record behind an AppClient.
 */
export type AppClientContactsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type AppClientAddress = {
  __typename: 'AppClientAddress';
  /** City or Suburb */
  city?: Maybe<Scalars['String']['output']>;
  /** Region or State */
  country?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Address Lines */
  lines: Array<Scalars['String']['output']>;
  postcode?: Maybe<Scalars['String']['output']>;
  /** Region or State */
  region?: Maybe<Scalars['String']['output']>;
};

export type AppClientCompany = {
  __typename: 'AppClientCompany';
  /** The fax number of the Company, as opposed to the phone number of an individual */
  fax?: Maybe<Scalars['String']['output']>;
  /** Freeform text to store GST Information- may be Yes/No or a GST Registration number */
  gstRegistrationInfo?: Maybe<Scalars['String']['output']>;
  /** The phone number of the Company, as opposed to the phone number of an individual */
  phone?: Maybe<Scalars['String']['output']>;
  /** The Official number of the company- e.g. ABN/ACN in Australia, CRN in U.S.A., etc */
  registrationNumber?: Maybe<Scalars['String']['output']>;
  /** e.g. TFN in Australia, EIN in U.S.A., etc */
  taxNumber?: Maybe<Scalars['String']['output']>;
  /** Free form Text description of the type of company */
  type?: Maybe<Scalars['String']['output']>;
  /** The main website of the Company */
  website?: Maybe<Scalars['String']['output']>;
};

/** The connection type for AppClient. */
export type AppClientConnection = {
  __typename: 'AppClientConnection';
  /** A list of edges. */
  edges: Array<AppClientEdge>;
  /** A list of nodes. */
  nodes: Array<AppClient>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type AppClientContact = {
  __typename: 'AppClientContact';
  addressee?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['EmailAddress']['output']>;
  id: Scalars['ID']['output'];
  mobile?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  phone?: Maybe<Scalars['String']['output']>;
  salutation?: Maybe<Scalars['String']['output']>;
};

/** The connection type for AppClientContact. */
export type AppClientContactConnection = {
  __typename: 'AppClientContactConnection';
  /** A list of edges. */
  edges: Array<AppClientContactEdge>;
  /** A list of nodes. */
  nodes: Array<AppClientContact>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AppClientContactEdge = {
  __typename: 'AppClientContactEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: AppClientContact;
};

/** An edge in a connection. */
export type AppClientEdge = {
  __typename: 'AppClientEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: AppClient;
};

/** Type for filtering AppClients */
export type AppClientFilter = {
  /** Return AppClients that belong to this app */
  appName?: InputMaybe<Scalars['String']['input']>;
  /** If true, exclude AppClients mapped to a Client */
  excludeMapped?: InputMaybe<Scalars['Boolean']['input']>;
  /** Return AppClients with these IDs */
  idsIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Return AppClients with names containing this value */
  nameCont?: InputMaybe<Scalars['String']['input']>;
};

/** Input data for filtering app clients */
export type AppClientFilterInputType = {
  booleanFilters?: InputMaybe<Array<SearchQueryBooleanFilterInput>>;
  dateFilters?: InputMaybe<Array<SearchQueryDateFilterInput>>;
  numberFilters?: InputMaybe<Array<SearchQueryNumberFilterInput>>;
  pagination?: InputMaybe<PaginationInput>;
  relativeDateFilters?: InputMaybe<Array<SearchQueryRelativeDateFilterInput>>;
  sort?: InputMaybe<SearchQuerySortInput>;
  textFilters?: InputMaybe<Array<SearchQueryTextFilterInput>>;
};

/** Input data identifying an AppClient */
export type AppClientInput = {
  /** The unique name of the App that the AppClient belongs to */
  appName: Scalars['String']['input'];
  /** The ID of the AppClient to map to.  If missing, any existing mapping will be removed */
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type AppClientProconnect = {
  __typename: 'AppClientProconnect';
  taxReturnType?: Maybe<Scalars['String']['output']>;
};

export type AppClientResult = {
  __typename: 'AppClientResult';
  appClient?: Maybe<AppClient>;
  appData: AppDataUnion;
  appName: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  email?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  ignitionappClient?: Maybe<Client>;
  ignitionappClientId?: Maybe<Scalars['String']['output']>;
  isLinked: Scalars['Boolean']['output'];
  lastSyncedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  primaryContactEmail?: Maybe<Scalars['String']['output']>;
  primaryContactName?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

/** Autogenerated input type of AppConnect */
export type AppConnectInput = {
  /** ID of the App Account to connect to */
  accountId: Scalars['ID']['input'];
  /** The name of the App to disconnect */
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AppConnect. */
export type AppConnectPayload = {
  __typename: 'AppConnectPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** The connection type for App. */
export type AppConnection = {
  __typename: 'AppConnection';
  /** A list of edges. */
  edges: Array<AppEdge>;
  /** A list of nodes. */
  nodes: Array<App>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type AppDataUnion = AppClientProconnect;

/** Autogenerated input type of AppDisconnect */
export type AppDisconnectInput = {
  /** The name of the App to disconnect */
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AppDisconnect. */
export type AppDisconnectPayload = {
  __typename: 'AppDisconnectPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type AppEdge = {
  __typename: 'AppEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: App;
};

/** Autogenerated input type of AppEnable */
export type AppEnableInput = {
  /** The name of the App to enable */
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AppEnable. */
export type AppEnablePayload = {
  __typename: 'AppEnablePayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Type for filtering Apps */
export type AppFilter = {
  /** Return Apps that implement all these Capabilities */
  capabilities?: InputMaybe<Array<CapabilityFilter>>;
  /** Return Apps that exactly match this name */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of AppSetClientSyncSettings */
export type AppSetClientSyncSettingsInput = {
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  settings: ClientSyncSettingsInput;
};

/** Autogenerated return type of AppSetClientSyncSettings. */
export type AppSetClientSyncSettingsPayload = {
  __typename: 'AppSetClientSyncSettingsPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of AppSync */
export type AppSyncInput = {
  /** The name of the App to sync */
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AppSync. */
export type AppSyncPayload = {
  __typename: 'AppSyncPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export type AppTax = {
  __typename: 'AppTax';
  app: App;
  /** Tax Code (e.g. GST) */
  code: Scalars['String']['output'];
  /** The app's own identifier for this tax. */
  externalId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  /** Tax Name (e.g. Sales Tax) */
  name: Scalars['String']['output'];
  /** Tax Rate */
  rate: Percentage;
  /**
   * Tax Rate as a decimal (e.g. 0.1 for 10%)
   * @deprecated Use rate instead.
   */
  rateLegacy: Scalars['Decimal']['output'];
};

/** The connection type for AppTax. */
export type AppTaxConnection = {
  __typename: 'AppTaxConnection';
  /** A list of edges. */
  edges: Array<AppTaxEdge>;
  /** A list of nodes. */
  nodes: Array<AppTax>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AppTaxEdge = {
  __typename: 'AppTaxEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: AppTax;
};

/** Type for filtering AppTaxes */
export type AppTaxFilter = {
  /** Return AppTaxes that belong to this app */
  appName?: InputMaybe<Scalars['String']['input']>;
  /** If true, exclude AppTaxes mapped to a Tax */
  excludeMapped?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Input data identifying an AppTax */
export type AppTaxInput = {
  /** The unique name of the App that the AppTax belongs to */
  appName: Scalars['String']['input'];
  /** The ID of the AppTax to map to. If missing, any existing mapping will be removed */
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type AppTaxMappingInput = {
  /** The ID of the AppTax to map to. If null, the existing mapping will be removed. */
  appTaxId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the Ignition Tax. */
  taxId: Scalars['ID']['input'];
};

export enum AppUnavailableReason {
  PLAN_GATED = 'PLAN_GATED',
}

/**
 * An AppUser is a counterpart to a User that exists in an App's domain. AppUsers
 * can be linked ("mapped") to Users, and can be used to create Users.  For
 * example, a Staff member in Xero could be the underlying record behind an AppUser.
 */
export type AppUser = {
  __typename: 'AppUser';
  app: App;
  email?: Maybe<Scalars['String']['output']>;
  /** An identifier used by the App this AppUser belongs to */
  externalId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  /** Full name */
  name: Scalars['String']['output'];
  /** Link to view this AppUser in external system */
  url?: Maybe<Scalars['String']['output']>;
};

/** The connection type for AppUser. */
export type AppUserConnection = {
  __typename: 'AppUserConnection';
  /** A list of edges. */
  edges: Array<AppUserEdge>;
  /** A list of nodes. */
  nodes: Array<AppUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AppUserEdge = {
  __typename: 'AppUserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: AppUser;
};

/** Type for filtering AppUsers */
export type AppUserFilter = {
  /** Return AppUsers that belong to this app */
  appName?: InputMaybe<Scalars['String']['input']>;
  /** If true, exclude AppUsers mapped to a User */
  excludeMapped?: InputMaybe<Scalars['Boolean']['input']>;
  /** Return AppUsers with names containing this value */
  nameCont?: InputMaybe<Scalars['String']['input']>;
};

/** Input data identifying an AppUser */
export type AppUserInput = {
  /** The unique name of the App that the AppUser belongs to */
  appName: Scalars['String']['input'];
  /** The ID of the AppUser to map to.  If missing, any existing mapping will be removed */
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type AsyncJob = {
  __typename: 'AsyncJob';
  createdAt: Scalars['DateTime']['output'];
  errors: Array<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  resultSlug?: Maybe<Scalars['String']['output']>;
  state: AsyncJobStateEnum;
  subjectSlug?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

export type AsyncJobGroup = {
  __typename: 'AsyncJobGroup';
  failureCount: Scalars['Int']['output'];
  groupType?: Maybe<AsyncJobGroupTypeEnum>;
  id: Scalars['ID']['output'];
  jobs: Array<AsyncJob>;
  name: Scalars['String']['output'];
  state: AsyncJobGroupStateEnum;
  user?: Maybe<User>;
};

export enum AsyncJobGroupStateEnum {
  COMPLETED = 'COMPLETED',
  PENDING = 'PENDING',
}

export enum AsyncJobGroupTypeEnum {
  CLIENT_ARCHIVE = 'CLIENT_ARCHIVE',
  CREATED_FROM_LEDGER = 'CREATED_FROM_LEDGER',
  CREATE_PROPOSALS = 'CREATE_PROPOSALS',
  CREATE_SERVICE_FROM_ITEM = 'CREATE_SERVICE_FROM_ITEM',
  CREATE_VIA_IMPORT = 'CREATE_VIA_IMPORT',
  PAYMENT_METHOD_REQUEST = 'PAYMENT_METHOD_REQUEST',
  RENEWAL = 'RENEWAL',
  SEND_PROPOSALS = 'SEND_PROPOSALS',
}

export enum AsyncJobStateEnum {
  FAILED = 'FAILED',
  PENDING = 'PENDING',
  SUCCESSFUL = 'SUCCESSFUL',
}

export type BackgroundJob = {
  __typename: 'BackgroundJob';
  /** sidekiq background job id */
  id: Scalars['String']['output'];
  /** timestamp of when the job was queued */
  queuedAt: Scalars['DateTime']['output'];
};

export type BankAccount = {
  __typename: 'BankAccount';
  /** The editable part of the payment descriptor */
  descriptor?: Maybe<Scalars['String']['output']>;
  /** The prefix added to the statement descriptor during disbursal */
  descriptorPrefix?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  number: Scalars['String']['output'];
  routingNumber: Scalars['String']['output'];
};

export type BankAccountFailureEmailTemplate = EmailTemplateInterface &
  PracticeTemplate & {
    __typename: 'BankAccountFailureEmailTemplate';
    content: Scalars['String']['output'];
    contentHtml: Scalars['String']['output'];
    createdAt: Scalars['DateTime']['output'];
    description?: Maybe<Scalars['String']['output']>;
    id: Scalars['ID']['output'];
    name: Scalars['String']['output'];
    slug: Scalars['ID']['output'];
    subject: Scalars['String']['output'];
    updatedAt: Scalars['DateTime']['output'];
  };

/** Autogenerated input type of BankAccountFailureEmailTemplateUpdate */
export type BankAccountFailureEmailTemplateUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of bank account failure email template */
  id: Scalars['ID']['input'];
  template: EmailTemplateInput;
};

/** Autogenerated return type of BankAccountFailureEmailTemplateUpdate. */
export type BankAccountFailureEmailTemplateUpdatePayload = {
  __typename: 'BankAccountFailureEmailTemplateUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<BankAccountFailureEmailTemplate>;
  templates?: Maybe<Templates>;
};

export type BankAccountPaymentMethod = PaymentsPaymentMethod & {
  __typename: 'BankAccountPaymentMethod';
  createdAt: Scalars['DateTime']['output'];
  displayMethodType: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isInUse: Scalars['Boolean']['output'];
  isInvalid: Scalars['Boolean']['output'];
  name?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['String']['output']>;
  numberSuffix: Scalars['String']['output'];
  referenceNumber: Scalars['ID']['output'];
  routingNumber: Scalars['String']['output'];
  type: PaymentMethodType;
  verificationUrl?: Maybe<Scalars['URL']['output']>;
  verified: Scalars['Boolean']['output'];
};

export type BankAccountVerificationEmailTemplate = EmailTemplateInterface &
  PracticeTemplate & {
    __typename: 'BankAccountVerificationEmailTemplate';
    content: Scalars['String']['output'];
    contentHtml: Scalars['String']['output'];
    createdAt: Scalars['DateTime']['output'];
    description?: Maybe<Scalars['String']['output']>;
    id: Scalars['ID']['output'];
    name: Scalars['String']['output'];
    slug: Scalars['ID']['output'];
    subject: Scalars['String']['output'];
    updatedAt: Scalars['DateTime']['output'];
  };

/** Autogenerated input type of BankAccountVerificationEmailTemplateUpdate */
export type BankAccountVerificationEmailTemplateUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of bank account verification email template */
  id: Scalars['ID']['input'];
  template: EmailTemplateInput;
};

/** Autogenerated return type of BankAccountVerificationEmailTemplateUpdate. */
export type BankAccountVerificationEmailTemplateUpdatePayload = {
  __typename: 'BankAccountVerificationEmailTemplateUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<BankAccountVerificationEmailTemplate>;
  templates?: Maybe<Templates>;
};

export type BillableService = {
  __typename: 'BillableService';
  billingGroup: BillingGroup;
  billingItems: BillingItemConnection;
  description: Textile;
  id: Scalars['ID']['output'];
  invoiceStrategy?: Maybe<ProposalInvoiceStrategy>;
  name: Scalars['String']['output'];
  price:
    | ProposalFixedPrice
    | ProposalIncludedPrice
    | ProposalMinimumPrice
    | ProposalPriceRange
    | ProposalUnitPrice;
  /** Quantity Object containing amounts and rules */
  quantity?: Maybe<
    BillingEstimateQuantityRule | BillingSmartBillingQuantityRule
  >;
};

export type BillableServiceBillingItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for BillableService. */
export type BillableServiceConnection = {
  __typename: 'BillableServiceConnection';
  /** A list of edges. */
  edges: Array<BillableServiceEdge>;
  /** A list of nodes. */
  nodes: Array<BillableService>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BillableServiceEdge = {
  __typename: 'BillableServiceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: BillableService;
};

export type BillingAmountDiscountRule = BillingDiscountRuleInterface & {
  __typename: 'BillingAmountDiscountRule';
  amount: Money;
  description: Scalars['String']['output'];
};

export type BillingDiscountRuleInterface = {
  description: Scalars['String']['output'];
};

export type BillingEstimateQuantityRule = BillingQuantityRuleInterface & {
  __typename: 'BillingEstimateQuantityRule';
  /** Quantity amount. Either a calculated amount or a estimate amount depending on the type */
  amount: Scalars['Decimal']['output'];
  /** Type of quantity rule */
  type: BillingQuantityRuleType;
};

export type BillingFixedPriceRule = BillingPriceRuleInterface & {
  __typename: 'BillingFixedPriceRule';
  /** Amount */
  amount: Money;
  /** Description of the price rule */
  description: Scalars['String']['output'];
  /** Type of price rule */
  type: BillingPriceRuleType;
};

export type BillingGroup = {
  __typename: 'BillingGroup';
  /** The billing items belonging to this billing group. */
  billingItems: ClientBillingBillingItemConnection;
  /**
   * The billing group reference number.
   *
   * This is used in combination with a Workflow integration, where workflows
   * can be configured to receive credits when services belonging to a billing group
   * with that reference are invoiced.
   */
  billingReference: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** The invoices issued for this billing group. */
  invoices: ClientBillingInvoiceConnection;
  /**
   * Denotes whether there are unbilled services assigned this billing group.
   * @deprecated use invoices { count }
   */
  isInUse: Scalars['Boolean']['output'];
  /** Name of billing group. */
  name: Scalars['String']['output'];
  /** Source of billing group */
  source?: Maybe<ClientBillingBillingGroupSource>;
  /** The type of this billing group. */
  type: ClientBillingBillingGroupType;
  /** The workflow strategies assigned this billing group. */
  workflowStrategies: ClientWorkflowStrategyConnection;
};

export type BillingGroupBillingItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<BillingItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type BillingGroupInvoicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type BillingGroupWorkflowStrategiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ClientWorkflowStrategyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ClientWorkflowStrategyOrder>;
};

/** The connection type for BillingGroup. */
export type BillingGroupConnection = {
  __typename: 'BillingGroupConnection';
  /** A list of edges. */
  edges: Array<BillingGroupEdge>;
  /** A list of nodes. */
  nodes: Array<BillingGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BillingGroupEdge = {
  __typename: 'BillingGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: BillingGroup;
};

export type BillingIncludedPriceRule = BillingPriceRuleInterface & {
  __typename: 'BillingIncludedPriceRule';
  /** Description of the price rule */
  description: Scalars['String']['output'];
  /** Type of price rule */
  type: BillingPriceRuleType;
};

export type BillingItem = {
  __typename: 'BillingItem';
  /** The value of this billing item excluding tax */
  amount?: Maybe<Money>;
  /** The total value of this billing item, including tax */
  amountWithTax?: Maybe<Money>;
  billOn: Scalars['Date']['output'];
  billableService: BillableService;
  billingGroup: BillingGroup;
  billingName?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use billOn instead */
  date?: Maybe<Scalars['Date']['output']>;
  description: Textile;
  /** The total discount applied */
  discount?: Maybe<Money>;
  groupId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  invoiceStrategy?: Maybe<ProposalInvoiceStrategy>;
  name: Scalars['String']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  origin?: Maybe<Origin>;
  paymentMethod?: Maybe<PaymentMethod>;
  /** @deprecated Use unitPrice instead */
  price?: Maybe<Money>;
  priceRule:
    | ProposalFixedPrice
    | ProposalIncludedPrice
    | ProposalMinimumPrice
    | ProposalPriceRange
    | ProposalUnitPrice;
  /** @deprecated Use quantity_rule instead. */
  quantity?: Maybe<Scalars['Decimal']['output']>;
  /** Quantity rule object containing amounts and rules */
  quantityRule: BillingEstimateQuantityRule | BillingSmartBillingQuantityRule;
  state: ClientBillingBillingItemState;
  /** The value of the tax component of this billing item */
  taxAmount?: Maybe<Money>;
  unitPrice?: Maybe<Money>;
  unitPriceWithTax?: Maybe<Money>;
};

/** The connection type for BillingItem. */
export type BillingItemConnection = {
  __typename: 'BillingItemConnection';
  /** A list of edges. */
  edges: Array<BillingItemEdge>;
  /** A list of nodes. */
  nodes: Array<BillingItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BillingItemEdge = {
  __typename: 'BillingItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: BillingItem;
};

export type BillingItemFilter = {
  dateIn?: InputMaybe<DateRangeInput>;
  stateIn?: InputMaybe<ClientBillingBillingItemState>;
  strategyEq?: InputMaybe<ProposalInvoiceStrategy>;
};

export type BillingItemGroup = {
  __typename: 'BillingItemGroup';
  /** Total value of this billing group, excluding tax */
  amount?: Maybe<Money>;
  /** Total value of this billing group, including tax */
  amountWithTax?: Maybe<Money>;
  billingStrategy: ProposalInvoiceStrategy;
  date?: Maybe<Scalars['Date']['output']>;
  id: Scalars['ID']['output'];
  items: BillingItemConnection;
  paymentMethod?: Maybe<PaymentMethod>;
  /** Value of the tax on this billing group */
  taxAmount?: Maybe<Money>;
  /** @deprecated Use amount instead */
  totalPrice?: Maybe<Money>;
};

export type BillingItemGroupItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for BillingItemGroup. */
export type BillingItemGroupConnection = {
  __typename: 'BillingItemGroupConnection';
  /** A list of edges. */
  edges: Array<BillingItemGroupEdge>;
  /** A list of nodes. */
  nodes: Array<BillingItemGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BillingItemGroupEdge = {
  __typename: 'BillingItemGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: BillingItemGroup;
};

export type BillingItemInput = {
  /** discount in dollar */
  discount?: InputMaybe<Scalars['Decimal']['input']>;
  groupId: Scalars['String']['input'];
  id: Scalars['ID']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  /** price in dollar */
  price?: InputMaybe<Scalars['Decimal']['input']>;
  /** Quantity rule */
  quantityRule: QuantityRuleInput;
};

export type BillingItemPreview = {
  __typename: 'BillingItemPreview';
  billOn: Scalars['Date']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  priceRule:
    | ProposalFixedPrice
    | ProposalIncludedPrice
    | ProposalMinimumPrice
    | ProposalPriceRange
    | ProposalUnitPrice;
};

export type BillingItemResult = {
  __typename: 'BillingItemResult';
  billingStrategy: Scalars['String']['output'];
  client: ClientResult;
  currency: Scalars['String']['output'];
  /** The date the item should be billed */
  date: Scalars['Date']['output'];
  /** The billing item minimum value */
  estimatedTotalPrice: Money;
  id: Scalars['ID']['output'];
  /** Whether the client has a payment method attached to their account */
  paymentMethodAttached: Scalars['Boolean']['output'];
  /** @deprecated Use priceRule { type } instead. */
  priceRuleType: Scalars['String']['output'];
  serviceName: Scalars['String']['output'];
  status: ClientBillingBillingItemState;
  text: Scalars['String']['output'];
  /** The billing item minimum value */
  totalPrice: Money;
};

export type BillingMinimumPriceRule = BillingPriceRuleInterface & {
  __typename: 'BillingMinimumPriceRule';
  /** Description of the price rule */
  description: Scalars['String']['output'];
  /** Minimum amount */
  minimum: Money;
  /** Type of price rule */
  type: BillingPriceRuleType;
};

export type BillingNoneDiscountRule = BillingDiscountRuleInterface & {
  __typename: 'BillingNoneDiscountRule';
  description: Scalars['String']['output'];
};

export type BillingPercentDiscountRule = BillingDiscountRuleInterface & {
  __typename: 'BillingPercentDiscountRule';
  description: Scalars['String']['output'];
  percentage: Percentage;
};

/** Autogenerated input type of BillingPriceRuleAddUnitName */
export type BillingPriceRuleAddUnitNameInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** custom unit name */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of BillingPriceRuleAddUnitName. */
export type BillingPriceRuleAddUnitNamePayload = {
  __typename: 'BillingPriceRuleAddUnitNamePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  priceRuleUnitName: PriceRuleUnitName;
};

/** Autogenerated input type of BillingPriceRuleDeleteUnitName */
export type BillingPriceRuleDeleteUnitNameInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of Custom Unit Name */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of BillingPriceRuleDeleteUnitName. */
export type BillingPriceRuleDeleteUnitNamePayload = {
  __typename: 'BillingPriceRuleDeleteUnitNamePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  customUnitPriceNames: PriceRuleUnitNameConnection;
};

/** Autogenerated return type of BillingPriceRuleDeleteUnitName. */
export type BillingPriceRuleDeleteUnitNamePayloadCustomUnitPriceNamesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type BillingPriceRuleInterface = {
  /** Description of the price rule */
  description: Scalars['String']['output'];
  /** Type of price rule */
  type: BillingPriceRuleType;
};

export enum BillingPriceRuleType {
  FIXED = 'FIXED',
  HOURLY = 'HOURLY',
  INCLUDED = 'INCLUDED',
  MINIMUM = 'MINIMUM',
  RANGE = 'RANGE',
  UNIT = 'UNIT',
}

export type BillingQuantityRuleInterface = {
  /** Quantity amount. Either a calculated amount or a estimate amount depending on the type */
  amount: Scalars['Decimal']['output'];
  /** Type of quantity rule */
  type: BillingQuantityRuleType;
};

export enum BillingQuantityRuleType {
  ESTIMATE = 'ESTIMATE',
  SMART_BILLING = 'SMART_BILLING',
}

export type BillingRangePriceRule = BillingPriceRuleInterface & {
  __typename: 'BillingRangePriceRule';
  /** Description of the price rule */
  description: Scalars['String']['output'];
  /** Maximum amount */
  maximum: Money;
  /** Minimum amount */
  minimum: Money;
  /** Type of price rule */
  type: BillingPriceRuleType;
};

export type BillingSchedule = {
  __typename: 'BillingSchedule';
  billingDescription?: Maybe<Scalars['String']['output']>;
  billingSummary?: Maybe<Scalars['String']['output']>;
  dates: Array<Scalars['Date']['output']>;
  /** the html for displaying on the web page */
  description?: Maybe<Scalars['String']['output']>;
  /** The date from which the schedule stops recurring. Will be NULL for CONTINUOUS schedules. */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** representation of the recurrence rule in ical rule encoded format */
  ical: Scalars['String']['output'];
  /** The date from which the schedule starts recurring. */
  startDate: Scalars['Date']['output'];
  type: BillingScheduleTypeEnum;
};

/** Input to creation of a BillingSchedule */
export type BillingScheduleInputType = {
  name?: InputMaybe<Scalars['String']['input']>;
  recurrence: ProposalBillingStrategyType;
  /** Ignored unless recurrence is "RECURRING" */
  rule?: InputMaybe<Scalars['RecurrenceRuleInput']['input']>;
  start: BillingStartInputType;
};

export enum BillingScheduleTypeEnum {
  CONTINUOUS = 'CONTINUOUS',
  NON_RECURRING = 'NON_RECURRING',
  RECURRING = 'RECURRING',
}

export type BillingSmartBillingQuantityRule = BillingQuantityRuleInterface & {
  __typename: 'BillingSmartBillingQuantityRule';
  /** Quantity amount. Either a calculated amount or a estimate amount depending on the type */
  amount: Scalars['Decimal']['output'];
  /** time rule was created or of last sync */
  lastUpdatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** source/name of the rule used to calculate the amount */
  source: Scalars['String']['output'];
  /** Type of quantity rule */
  type: BillingQuantityRuleType;
};

export type BillingStartInputType = {
  /** Ignored unless start_type is "ON_DATE" */
  date?: InputMaybe<Scalars['Date']['input']>;
  delay?: InputMaybe<DurationInput>;
  startType: ProposalStartBillingType;
};

export type BillingUnitPriceRule = BillingPriceRuleInterface & {
  __typename: 'BillingUnitPriceRule';
  /** Amount */
  amount: Money;
  /** Description of the price rule */
  description: Scalars['String']['output'];
  /** Type of price rule */
  type: BillingPriceRuleType;
  /** Name of the type of unit */
  unitName: Scalars['String']['output'];
};

export type BrandingTheme = {
  __typename: 'BrandingTheme';
  colour: Scalars['String']['output'];
  colourHex: Scalars['String']['output'];
  defaultBrochure?: Maybe<Filestack>;
  /** @deprecated Use default_brochure { url } instead. */
  defaultBrochureUrl?: Maybe<Scalars['URL']['output']>;
  id: Scalars['ID']['output'];
  /** Tells you if the returned logo is the Ignition provided default. */
  isDefaultLogo: Scalars['Boolean']['output'];
  /** Whether the customer logo is displayed in emails to clients if the customer has Branded Emails enabled. */
  isLogoShownOnClientEmails: Scalars['Boolean']['output'];
  logo: ResizeableImage;
  /** @deprecated Use logo { url } instead. */
  logoUrl: Scalars['URL']['output'];
};

/** Autogenerated input type of BrandingThemeColourUpdate */
export type BrandingThemeColourUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  colour: Scalars['String']['input'];
};

/** Autogenerated return type of BrandingThemeColourUpdate. */
export type BrandingThemeColourUpdatePayload = {
  __typename: 'BrandingThemeColourUpdatePayload';
  brandingTheme: BrandingTheme;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of BrandingThemeDefaultBrochureUnset */
export type BrandingThemeDefaultBrochureUnsetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of BrandingThemeDefaultBrochureUnset. */
export type BrandingThemeDefaultBrochureUnsetPayload = {
  __typename: 'BrandingThemeDefaultBrochureUnsetPayload';
  brandingTheme: BrandingTheme;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of BrandingThemeDefaultBrochureUpdate */
export type BrandingThemeDefaultBrochureUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  file: FilestackInput;
};

/** Autogenerated return type of BrandingThemeDefaultBrochureUpdate. */
export type BrandingThemeDefaultBrochureUpdatePayload = {
  __typename: 'BrandingThemeDefaultBrochureUpdatePayload';
  brandingTheme: BrandingTheme;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of BrandingThemeLogoUnset */
export type BrandingThemeLogoUnsetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of BrandingThemeLogoUnset. */
export type BrandingThemeLogoUnsetPayload = {
  __typename: 'BrandingThemeLogoUnsetPayload';
  brandingTheme: BrandingTheme;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of BrandingThemeLogoUpdate */
export type BrandingThemeLogoUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  file: FilestackInput;
};

/** Autogenerated return type of BrandingThemeLogoUpdate. */
export type BrandingThemeLogoUpdatePayload = {
  __typename: 'BrandingThemeLogoUpdatePayload';
  brandingTheme: BrandingTheme;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of BrandingThemeUpdate */
export type BrandingThemeUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  colour?: InputMaybe<Scalars['String']['input']>;
  defaultBrochureFile?: InputMaybe<FilestackInput>;
  isLogoShownOnClientEmails?: InputMaybe<Scalars['Boolean']['input']>;
  logo?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of BrandingThemeUpdate. */
export type BrandingThemeUpdatePayload = {
  __typename: 'BrandingThemeUpdatePayload';
  brandingTheme: BrandingTheme;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export type Brochure = {
  __typename: 'Brochure';
  file: Filestack;
  id: Scalars['ID']['output'];
};

/** Autogenerated input type of BrochureCreate */
export type BrochureCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  file: FilestackInput;
};

/** Autogenerated return type of BrochureCreate. */
export type BrochureCreatePayload = {
  __typename: 'BrochureCreatePayload';
  brochure?: Maybe<Brochure>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export type CapabilityFilter = {
  name?: InputMaybe<CapabilityNameEnum>;
  state?: InputMaybe<CapabilityStateEnum>;
};

export enum CapabilityNameEnum {
  CLIENT_SEARCH = 'CLIENT_SEARCH',
  CLIENT_SYNC = 'CLIENT_SYNC',
  INVOICE_DEPLOY = 'INVOICE_DEPLOY',
  LEDGER_ITEMS = 'LEDGER_ITEMS',
  PRACTICE_BILLING = 'PRACTICE_BILLING',
  PROPOSAL_IMPORT = 'PROPOSAL_IMPORT',
  PROVIDED_TEMPLATES = 'PROVIDED_TEMPLATES',
  SERVICE_IMPORT = 'SERVICE_IMPORT',
  SMART_BILLING = 'SMART_BILLING',
  TAX_RATES = 'TAX_RATES',
  USER_CONFIGURABLE = 'USER_CONFIGURABLE',
  USER_SYNC = 'USER_SYNC',
  WORKFLOW = 'WORKFLOW',
  WORKFLOW_CATEGORIES = 'WORKFLOW_CATEGORIES',
  WORKFLOW_TEMPLATES = 'WORKFLOW_TEMPLATES',
}

export enum CapabilityStateEnum {
  DISABLED = 'DISABLED',
  ENABLED = 'ENABLED',
}

/**
 * A Capability is a generic piece of functionality that an App can .implement.
 * For example, the "client_sync" functionality allows Apps to sync Client details
 * to and from external systems.  If an App has the "client_sync" functionality,
 * then all associated types (e.g. AppClient) and mutations (e.g.
 * ClientSetAppMapping) will work with that App.
 */
export type CapabilityWithState = {
  __typename: 'CapabilityWithState';
  description: Scalars['String']['output'];
  name: CapabilityNameEnum;
  state: CapabilityStateEnum;
};

export type ChangedValue = {
  __typename: 'ChangedValue';
  name: Scalars['String']['output'];
  newValue?: Maybe<Scalars['String']['output']>;
  oldValue?: Maybe<Scalars['String']['output']>;
  summary?: Maybe<Scalars['String']['output']>;
};

export type Clawback = {
  __typename: 'Clawback';
  amount: Money;
  collection?: Maybe<Collection>;
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  externalId?: Maybe<Scalars['String']['output']>;
  failedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  message?: Maybe<Scalars['String']['output']>;
  /** Payment associated with the clawback */
  payment: Payment;
  paymentMethod: PaymentMethod;
  startedAt: Scalars['DateTime']['output'];
  state: PaymentsClawbackState;
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for Clawback. */
export type ClawbackConnection = {
  __typename: 'ClawbackConnection';
  /** A list of edges. */
  edges: Array<ClawbackEdge>;
  /** A list of nodes. */
  nodes: Array<Clawback>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalAmount: Money;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ClawbackEdge = {
  __typename: 'ClawbackEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Clawback;
};

/** A client of a practice for which proposals are created. */
export type Client = {
  __typename: 'Client';
  /**
   * The workflow strategy that is currently configured to receive credits for invoices raised with this
   * client's billing group.
   */
  activeBillingWorkflowStrategy?: Maybe<ClientWorkflowStrategy>;
  activities: ActivityLogConnection;
  /** If present, this is an error related to recent activity on the client, such as a failed proposal creation */
  activityError?: Maybe<Scalars['String']['output']>;
  /** The date/time when activityError last occurred */
  activityErrorOccurredAt?: Maybe<Scalars['DateTime']['output']>;
  /** @deprecated Use companyAddress and postalAddress instead */
  addresses: AddressConnection;
  /** agreed services */
  agreedServices: AgreedServiceConnection;
  appClients: AppClientConnection;
  automaticBillingGroup?: Maybe<BillingItemGroup>;
  automaticBillingGroups: BillingItemGroupConnection;
  billableServices: BillableServiceConnection;
  billingGroup?: Maybe<BillingGroup>;
  billingGroups: BillingGroupConnection;
  billingItem?: Maybe<BillingItem>;
  /** unbilled billing items */
  billingItems: BillingItemConnection;
  businessStructure?: Maybe<Scalars['String']['output']>;
  canArchive: Scalars['Boolean']['output'];
  companyAddress?: Maybe<Address>;
  companyNumber?: Maybe<Scalars['String']['output']>;
  contacts: ContactConnection;
  createdAt: Scalars['DateTime']['output'];
  defaultContact: Contact;
  /** Reference number for the client (eg. CLI-0001) */
  displayReferenceNumber: Scalars['String']['output'];
  emailSettings: Array<EmailSettings>;
  fax?: Maybe<Scalars['PhoneNumber']['output']>;
  fiscalPeriodEndDay?: Maybe<Scalars['Int']['output']>;
  fiscalPeriodEndMonth?: Maybe<Scalars['Int']['output']>;
  group?: Maybe<ClientGroup>;
  gstRegistered?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  invoiceSettings?: Maybe<InvoiceNotificationSettings>;
  invoices: ClientBillingInvoiceConnection;
  /** Is revenue from this client excluded from the dashboard and other reports? */
  isExcludedFromReports: Scalars['Boolean']['output'];
  /** send the invoice email when an invoice is raised */
  isSendInvoiceNotificationsEnabled: Scalars['Boolean']['output'];
  /** Whether the practice applies surcharges to pass on payment fees to this client */
  isSurchargeEnabled: Scalars['Boolean']['output'];
  /** @deprecated Use manager instead. */
  jobManager?: Maybe<User>;
  manager?: Maybe<User>;
  name: Scalars['String']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  notificationSettings?: Maybe<ClientNotificationSettings>;
  partner?: Maybe<User>;
  /** List of payment method requests sent to the client. */
  paymentMethodRequests: PaymentMethodRequestConnection;
  paymentMethods?: Maybe<Array<PaymentMethod>>;
  paymentNotificationSettings?: Maybe<PaymentNotificationSettings>;
  payments: PaymentConnection;
  phone?: Maybe<Scalars['PhoneNumber']['output']>;
  postalAddress?: Maybe<Address>;
  /**
   * Legacy auto-inc id of client
   * @deprecated Use id instead.
   */
  referenceNumber: Scalars['ID']['output'];
  state: ClientState;
  tagList: Array<Scalars['String']['output']>;
  taxNumber?: Maybe<Scalars['String']['output']>;
  token?: Maybe<PublicToken>;
  type: ClientType;
  /** url used for updating payment details on a client */
  updatePaymentDetailsUrl?: Maybe<Scalars['URL']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  website?: Maybe<Scalars['URL']['output']>;
  willDeployInvoices: Scalars['Boolean']['output'];
  workflowItem?: Maybe<ClientWorkflowItem>;
  workflowStrategies: ClientWorkflowStrategyConnection;
  /**
   * Xero Tracking Categories for the client
   * @deprecated After tracking categories and available options have been moved to the practice root, only selectedOptions will remain
   */
  xeroTrackingCategories?: Maybe<Array<XeroTrackingCategory>>;
};

/** A client of a practice for which proposals are created. */
export type ClientActivitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ActivityLogOrder>;
};

/** A client of a practice for which proposals are created. */
export type ClientAddressesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AddressFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A client of a practice for which proposals are created. */
export type ClientAgreedServicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AgreedServiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A client of a practice for which proposals are created. */
export type ClientAppClientsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AppClientFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A client of a practice for which proposals are created. */
export type ClientAutomaticBillingGroupArgs = {
  id: Scalars['ID']['input'];
};

/** A client of a practice for which proposals are created. */
export type ClientAutomaticBillingGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  dateIn?: InputMaybe<DateRangeInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A client of a practice for which proposals are created. */
export type ClientBillableServicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A client of a practice for which proposals are created. */
export type ClientBillingGroupArgs = {
  id: Scalars['ID']['input'];
};

/** A client of a practice for which proposals are created. */
export type ClientBillingGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ClientBillingBillingGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A client of a practice for which proposals are created. */
export type ClientBillingItemArgs = {
  id: Scalars['ID']['input'];
};

/** A client of a practice for which proposals are created. */
export type ClientBillingItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter: BillingItemFilter;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A client of a practice for which proposals are created. */
export type ClientContactsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A client of a practice for which proposals are created. */
export type ClientInvoicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A client of a practice for which proposals are created. */
export type ClientPaymentMethodRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PaymentMethodRequestFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A client of a practice for which proposals are created. */
export type ClientPaymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PaymentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A client of a practice for which proposals are created. */
export type ClientWorkflowItemArgs = {
  id: Scalars['ID']['input'];
};

/** A client of a practice for which proposals are created. */
export type ClientWorkflowStrategiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ClientWorkflowStrategyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ClientWorkflowStrategyOrder>;
};

/** Autogenerated input type of ClientAddSignatory */
export type ClientAddSignatoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  contactId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientAddSignatory. */
export type ClientAddSignatoryPayload = {
  __typename: 'ClientAddSignatoryPayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  contact?: Maybe<Contact>;
};

/** Autogenerated input type of ClientArchive */
export type ClientArchiveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientArchive. */
export type ClientArchivePayload = {
  __typename: 'ClientArchivePayload';
  /** Archived client */
  client: Client;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export type ClientBillingBillingGroupFilter = {
  billingReferenceEq?: InputMaybe<Scalars['String']['input']>;
  typeEq?: InputMaybe<ClientBillingBillingGroupType>;
};

export type ClientBillingBillingGroupSource =
  | Client
  | Engagement
  | Project
  | Proposal;

export enum ClientBillingBillingGroupType {
  /** Billing Group for Client */
  CLIENT = 'CLIENT',
  /** Billing Group for Classic Proposal */
  ENGAGEMENT = 'ENGAGEMENT',
  /** Billing Group for Proposal Project */
  PROJECT = 'PROJECT',
  /** Billing Group for Proposal */
  PROPOSAL = 'PROPOSAL',
}

/** The connection type for BillingItem. */
export type ClientBillingBillingItemConnection = {
  __typename: 'ClientBillingBillingItemConnection';
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges: Array<ClientBillingBillingItemEdge>;
  /** A list of nodes. */
  nodes: Array<BillingItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalPrice?: Maybe<Money>;
};

/** An edge in a connection. */
export type ClientBillingBillingItemEdge = {
  __typename: 'ClientBillingBillingItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: BillingItem;
};

export enum ClientBillingBillingItemState {
  ARCHIVED = 'ARCHIVED',
  BILLED = 'BILLED',
  UNBILLED = 'UNBILLED',
}

export type ClientBillingInvoice = {
  __typename: 'ClientBillingInvoice';
  activities: ActivityLogConnection;
  /** The total value of the invoice, excluding tax */
  amount: Money;
  /** The total value of the invoice, including tax */
  amountWithTax: Money;
  client: Client;
  date: Scalars['Date']['output'];
  deployments: ClientBillingInvoiceDeploymentConnection;
  dueDate: Scalars['Date']['output'];
  id: Scalars['ID']['output'];
  /** Indicate whether we have sent the invoice email to client or not */
  isInvoiceEmailSent: Scalars['Boolean']['output'];
  isOnlinePaymentAvailable: Scalars['Boolean']['output'];
  items: ClientBillingInvoiceItemConnection;
  latestDeployment?: Maybe<ClientBillingInvoiceDeployment>;
  memo?: Maybe<Scalars['String']['output']>;
  payInvoicePortalUrl: Scalars['String']['output'];
  payment?: Maybe<Payment>;
  /** @deprecated Use payment.paymentMethod instead */
  paymentMethod?: Maybe<PaymentMethod>;
  /** Whether it is valid to call the reconcile mutation on this Invoice */
  reconcilable: Scalars['Boolean']['output'];
  reference: Scalars['String']['output'];
  state: ClientBillingInvoiceState;
  /** The total amount of tax charged on this invoice */
  taxAmount: Money;
};

export type ClientBillingInvoiceActivitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ActivityLogOrder>;
};

export type ClientBillingInvoiceDeploymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ClientBillingInvoiceDeploymentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ClientBillingInvoiceItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ClientBillingInvoice. */
export type ClientBillingInvoiceConnection = {
  __typename: 'ClientBillingInvoiceConnection';
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges: Array<ClientBillingInvoiceEdge>;
  /** A list of nodes. */
  nodes: Array<ClientBillingInvoice>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalAmount?: Maybe<Money>;
};

/** Autogenerated input type of ClientBillingInvoiceDeploy */
export type ClientBillingInvoiceDeployInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of invoice */
  invoiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientBillingInvoiceDeploy. */
export type ClientBillingInvoiceDeployPayload = {
  __typename: 'ClientBillingInvoiceDeployPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  invoice: ClientBillingInvoice;
};

export type ClientBillingInvoiceDeployment = {
  __typename: 'ClientBillingInvoiceDeployment';
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  externalId?: Maybe<Scalars['String']['output']>;
  externalNumber?: Maybe<Scalars['String']['output']>;
  externalUrl?: Maybe<Scalars['String']['output']>;
  failedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  ledgerName: Scalars['String']['output'];
  message?: Maybe<Scalars['String']['output']>;
  reference: Scalars['ID']['output'];
  startedAt?: Maybe<Scalars['DateTime']['output']>;
  state: ClientBillingInvoiceDeploymentState;
};

/** The connection type for ClientBillingInvoiceDeployment. */
export type ClientBillingInvoiceDeploymentConnection = {
  __typename: 'ClientBillingInvoiceDeploymentConnection';
  /** A list of edges. */
  edges: Array<ClientBillingInvoiceDeploymentEdge>;
  /** A list of nodes. */
  nodes: Array<ClientBillingInvoiceDeployment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ClientBillingInvoiceDeploymentEdge = {
  __typename: 'ClientBillingInvoiceDeploymentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ClientBillingInvoiceDeployment;
};

export type ClientBillingInvoiceDeploymentFilter = {
  stateIn?: InputMaybe<Array<ClientBillingInvoiceDeploymentState>>;
};

export enum ClientBillingInvoiceDeploymentState {
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  STARTED = 'STARTED',
}

/** An edge in a connection. */
export type ClientBillingInvoiceEdge = {
  __typename: 'ClientBillingInvoiceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ClientBillingInvoice;
};

/** Autogenerated input type of ClientBillingInvoiceIssue */
export type ClientBillingInvoiceIssueInput = {
  /** billing items */
  billingItems: Array<BillingItemInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** payment method slug */
  paymentMethodId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientBillingInvoiceIssue. */
export type ClientBillingInvoiceIssuePayload = {
  __typename: 'ClientBillingInvoiceIssuePayload';
  billingItems: Array<BillingItem>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  invoices: Array<ClientBillingInvoice>;
};

export type ClientBillingInvoiceItem = {
  __typename: 'ClientBillingInvoiceItem';
  /** The total value of this item excluding tax, i.e. quantity * unit_price */
  amount: Money;
  /** The total value of this item including total, i.e. (quantity * unit_price) + tax_amount */
  amountWithTax: Money;
  /** The billing item this invoice item was created from (if any). */
  billingItem?: Maybe<BillingItem>;
  billingName?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  discount?: Maybe<Money>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  origin?: Maybe<Origin>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity: Scalars['Decimal']['output'];
  /** The type of tax applied to this item */
  tax: Tax;
  /** The total value of tax applied to this item */
  taxAmount: Money;
  /** The value of a single unit of this item, i.e. the value if quantity were 1 */
  unitPrice: Money;
};

/** The connection type for ClientBillingInvoiceItem. */
export type ClientBillingInvoiceItemConnection = {
  __typename: 'ClientBillingInvoiceItemConnection';
  /** A list of edges. */
  edges: Array<ClientBillingInvoiceItemEdge>;
  /** A list of nodes. */
  nodes: Array<ClientBillingInvoiceItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ClientBillingInvoiceItemEdge = {
  __typename: 'ClientBillingInvoiceItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ClientBillingInvoiceItem;
};

/** Autogenerated input type of ClientBillingInvoiceReconcile */
export type ClientBillingInvoiceReconcileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of invoice */
  invoiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientBillingInvoiceReconcile. */
export type ClientBillingInvoiceReconcilePayload = {
  __typename: 'ClientBillingInvoiceReconcilePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  invoice: ClientBillingInvoice;
};

/** Autogenerated input type of ClientBillingInvoiceSendInvoiceToClientEmail */
export type ClientBillingInvoiceSendInvoiceToClientEmailInput = {
  /** Allow online payment checkbox value */
  allowOnlinePayment: Scalars['Boolean']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Invoice's slug */
  invoiceId: Scalars['ID']['input'];
  /** Additional message */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Email subject */
  subject: Scalars['String']['input'];
  /** Email recipients */
  to: Array<Scalars['EmailAddress']['input']>;
};

/** Autogenerated return type of ClientBillingInvoiceSendInvoiceToClientEmail. */
export type ClientBillingInvoiceSendInvoiceToClientEmailPayload = {
  __typename: 'ClientBillingInvoiceSendInvoiceToClientEmailPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  invoice: ClientBillingInvoice;
};

export enum ClientBillingInvoiceState {
  DELETED = 'DELETED',
  ISSUED = 'ISSUED',
}

/** Autogenerated input type of ClientBillingItemArchive */
export type ClientBillingItemArchiveInput = {
  /** Billing item slugs */
  billingItemIds: Array<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ClientBillingItemArchive. */
export type ClientBillingItemArchivePayload = {
  __typename: 'ClientBillingItemArchivePayload';
  billingItems: Array<BillingItem>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientBillingItemBillAutomatically */
export type ClientBillingItemBillAutomaticallyInput = {
  /** Billing items */
  billingItems: Array<BillingItemInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Date for which all billing items should be billed. (ISO formatted) */
  date: Scalars['Date']['input'];
  /** Payment method to use when collecting payment for this item. To unset the payment method, use an empty string. */
  paymentMethodId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientBillingItemBillAutomatically. */
export type ClientBillingItemBillAutomaticallyPayload = {
  __typename: 'ClientBillingItemBillAutomaticallyPayload';
  billingItems: Array<BillingItem>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientBillingItemBillManually */
export type ClientBillingItemBillManuallyInput = {
  /** Billing items */
  billingItems: Array<BillingItemInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Date (ISO Formatted) for which all billing items should be billed. (ISO Formatted) */
  date: Scalars['Date']['input'];
};

/** Autogenerated return type of ClientBillingItemBillManually. */
export type ClientBillingItemBillManuallyPayload = {
  __typename: 'ClientBillingItemBillManuallyPayload';
  billingItems: Array<BillingItem>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientBillingItemPreviewSmartBillingQuantity */
export type ClientBillingItemPreviewSmartBillingQuantityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the billing item */
  id: Scalars['ID']['input'];
  /** quantity rule to use for smart billing calculation */
  quantityRule: QuantityRuleInput;
};

/** Autogenerated return type of ClientBillingItemPreviewSmartBillingQuantity. */
export type ClientBillingItemPreviewSmartBillingQuantityPayload = {
  __typename: 'ClientBillingItemPreviewSmartBillingQuantityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  smartBillingQuantityRule: BillingSmartBillingQuantityRule;
};

/** Autogenerated input type of ClientBillingItemRefreshSmartBillingQuantity */
export type ClientBillingItemRefreshSmartBillingQuantityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the billing item */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientBillingItemRefreshSmartBillingQuantity. */
export type ClientBillingItemRefreshSmartBillingQuantityPayload = {
  __typename: 'ClientBillingItemRefreshSmartBillingQuantityPayload';
  billingItem: BillingItem;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientBillingItemReschedule */
export type ClientBillingItemRescheduleInput = {
  /** Billing item slugs */
  billingItemIds: Array<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** New billing item date (ISO Formatted) */
  date: Scalars['Date']['input'];
};

/** Autogenerated return type of ClientBillingItemReschedule. */
export type ClientBillingItemReschedulePayload = {
  __typename: 'ClientBillingItemReschedulePayload';
  billingItems: Array<BillingItem>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientBulkArchive */
export type ClientBulkArchiveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  ids: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of ClientBulkArchive. */
export type ClientBulkArchivePayload = {
  __typename: 'ClientBulkArchivePayload';
  /** Async Job Group for the clients being archived in the background */
  asyncJobGroup?: Maybe<AsyncJobGroup>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** The connection type for Client. */
export type ClientConnection = {
  __typename: 'ClientConnection';
  /** A list of edges. */
  edges: Array<ClientEdge>;
  ids: Array<Scalars['ID']['output']>;
  /** A list of nodes. */
  nodes: Array<Client>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ClientCreate */
export type ClientCreateInput = {
  /** An AppClient to map the Client to */
  appClient?: InputMaybe<AppClientInput>;
  client: ClientInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ClientCreate. */
export type ClientCreatePayload = {
  __typename: 'ClientCreatePayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Input type for client duplicate resolution */
export type ClientDuplicateResolutionInput = {
  /** The ID of the app client to resolve the duplicate for */
  appClientId: Scalars['ID']['input'];
  /** The ID of the ignition client to resolve the duplicate for */
  clientSlug: Scalars['ID']['input'];
  /** How to resolve this duplication */
  resolutionType: DuplicateResolutionEnum;
};

/** An edge in a connection. */
export type ClientEdge = {
  __typename: 'ClientEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Client;
};

export type ClientFilter = {
  awaitingVerification?: InputMaybe<Scalars['Boolean']['input']>;
  expiringCards?: InputMaybe<Scalars['Boolean']['input']>;
  idsIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  manualPaymentsDue?: InputMaybe<ClientManualPaymentDueFilter>;
  /** Filter by partial match on name */
  nameCont?: InputMaybe<Scalars['String']['input']>;
  /** Filter by exact match on name */
  nameEq?: InputMaybe<Scalars['String']['input']>;
  proposalFilter?: InputMaybe<ProposalFilter>;
  stateIn?: InputMaybe<Array<ClientState>>;
  stateNotIn?: InputMaybe<Array<ClientState>>;
  tagEq?: InputMaybe<Scalars['String']['input']>;
};

/** A group of clients, of a practice, that can have group engagements. */
export type ClientGroup = {
  __typename: 'ClientGroup';
  contact?: Maybe<Contact>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  referenceNumber: Scalars['ID']['output'];
};

/** Autogenerated input type of ClientGroupsUpdate */
export type ClientGroupsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** client group contact id to update */
  contactId?: InputMaybe<Scalars['ID']['input']>;
  /** client group id */
  id: Scalars['ID']['input'];
  /** client group name to update */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ClientGroupsUpdate. */
export type ClientGroupsUpdatePayload = {
  __typename: 'ClientGroupsUpdatePayload';
  clientGroup: ClientGroup;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientImportCreate */
export type ClientImportCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  file: FilestackInput;
};

/** Autogenerated return type of ClientImportCreate. */
export type ClientImportCreatePayload = {
  __typename: 'ClientImportCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Number of clients successfully imported */
  count: Scalars['Int']['output'];
  /** List of error messages including line number */
  errors: Array<Scalars['String']['output']>;
  /** Import object */
  import?: Maybe<ImportType>;
  /** Is the csv a valid csv for import */
  isValid: Scalars['Boolean']['output'];
};

/** Autogenerated input type of ClientImportFromAppClients */
export type ClientImportFromAppClientsInput = {
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  duplicateResolutions?: InputMaybe<Array<ClientDuplicateResolutionInput>>;
  searchFilters?: InputMaybe<AppClientFilterInputType>;
  selectAll?: InputMaybe<Scalars['Boolean']['input']>;
  selectedAppClientIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of ClientImportFromAppClients. */
export type ClientImportFromAppClientsPayload = {
  __typename: 'ClientImportFromAppClientsPayload';
  /** Async Job Group for the app clients being imported in the background */
  asyncJobGroup?: Maybe<AsyncJobGroup>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientImport */
export type ClientImportInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  importId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientImport. */
export type ClientImportPayload = {
  __typename: 'ClientImportPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  import: ImportType;
};

/** Input data to specify the details for a client. */
export type ClientInput = {
  /** Main address of the client */
  address?: InputMaybe<AddressInput>;
  /** Description or identification of the business structure */
  businessStructure?: InputMaybe<Scalars['String']['input']>;
  /** Legal entity company number */
  companyNumber?: InputMaybe<Scalars['String']['input']>;
  /** Details of the contacts */
  contacts?: InputMaybe<Array<ContactInput>>;
  /** Email settings of the client */
  emailSettings?: InputMaybe<Array<EmailSettingsInput>>;
  /** Fax number of the client */
  fax?: InputMaybe<Scalars['PhoneNumber']['input']>;
  /** End of Fiscal Period: perennial day */
  fiscalPeriodEndDay?: InputMaybe<Scalars['Int']['input']>;
  /** End of Fiscal Period: perennial month */
  fiscalPeriodEndMonth?: InputMaybe<Scalars['Int']['input']>;
  /** Free-form description of whether the client is GST registered or not (may contain malicious Javascript) */
  gstRegistered?: InputMaybe<Scalars['String']['input']>;
  /** ID of the manager user */
  managerId?: InputMaybe<Scalars['ID']['input']>;
  /** Name of the client */
  name: Scalars['String']['input'];
  /** Free-form notes about the client */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** ID of the partner user */
  partnerId?: InputMaybe<Scalars['ID']['input']>;
  /** Phone number of the client */
  phone?: InputMaybe<Scalars['PhoneNumber']['input']>;
  /** Postal address of the client */
  postalAddress?: InputMaybe<AddressInput>;
  /** Tags */
  tagList?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Tax file number */
  taxNumber?: InputMaybe<Scalars['String']['input']>;
  /** Website of the client */
  website?: InputMaybe<Scalars['URL']['input']>;
};

export type ClientInterface = {
  /** Company-specific attributes */
  company: AppClientCompany;
  contacts: AppClientContactConnection;
  /**
   * The default contact information to use to contact this Client,
   * if a specific contact has not been chosen
   */
  defaultContact: AppClientContact;
  id: Scalars['ID']['output'];
  /** Full name */
  name: Scalars['String']['output'];
  /** The physical or shipping address */
  physicalAddress?: Maybe<AppClientAddress>;
  /** The postal or billing address */
  postalAddress?: Maybe<AppClientAddress>;
};

export type ClientInterfaceContactsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export enum ClientManualPaymentDueFilter {
  ALL = 'ALL',
  OVERDUE = 'OVERDUE',
  THIS_MONTH = 'THIS_MONTH',
  THIS_WEEK = 'THIS_WEEK',
}

export type ClientNotificationSettings = {
  __typename: 'ClientNotificationSettings';
  recipients: Array<Recipient>;
};

/** Autogenerated input type of ClientPaymentMethodDelete */
export type ClientPaymentMethodDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Client ID */
  id: Scalars['ID']['input'];
  /** Payment method slug */
  paymentMethodId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientPaymentMethodDelete. */
export type ClientPaymentMethodDeletePayload = {
  __typename: 'ClientPaymentMethodDeletePayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientRemoveSignatory */
export type ClientRemoveSignatoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  contactId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientRemoveSignatory. */
export type ClientRemoveSignatoryPayload = {
  __typename: 'ClientRemoveSignatoryPayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  contact?: Maybe<Contact>;
};

export type ClientResult = {
  __typename: 'ClientResult';
  client: Client;
  createdAt: Scalars['DateTime']['output'];
  groupContactEmail?: Maybe<Scalars['String']['output']>;
  groupName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  manager?: Maybe<Scalars['String']['output']>;
  mostRecentActivityCause?: Maybe<Scalars['String']['output']>;
  /** If present, the most recent activity had an error */
  mostRecentActivityError?: Maybe<Scalars['String']['output']>;
  mostRecentActivityOn?: Maybe<Scalars['Date']['output']>;
  name: Scalars['String']['output'];
  partner?: Maybe<Scalars['String']['output']>;
  primaryContactEmail?: Maybe<Scalars['String']['output']>;
  tags?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

/** Autogenerated input type of ClientServicesAgreedServiceCancel */
export type ClientServicesAgreedServiceCancelInput = {
  /** Slug of Agreed Service */
  agreedServiceId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ClientServicesAgreedServiceCancel. */
export type ClientServicesAgreedServiceCancelPayload = {
  __typename: 'ClientServicesAgreedServiceCancelPayload';
  agreedService: AgreedService;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientServicesAgreedServiceCreate */
export type ClientServicesAgreedServiceCreateInput = {
  agreedServiceInput: AgreedServiceInput;
  /** Client slug */
  clientId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  notification?: InputMaybe<NotificationInput>;
  /** Payment method slug */
  paymentMethodId?: InputMaybe<Scalars['ID']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ClientServicesAgreedServiceCreate. */
export type ClientServicesAgreedServiceCreatePayload = {
  __typename: 'ClientServicesAgreedServiceCreatePayload';
  agreedService: AgreedService;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientServicesAgreedServiceDisableAll */
export type ClientServicesAgreedServiceDisableAllInput = {
  /** Slug of Client */
  clientId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ClientServicesAgreedServiceDisableAll. */
export type ClientServicesAgreedServiceDisableAllPayload = {
  __typename: 'ClientServicesAgreedServiceDisableAllPayload';
  agreedServices: Array<AgreedService>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientServicesAgreedServiceDisable */
export type ClientServicesAgreedServiceDisableInput = {
  /** Slug of Agreed Service */
  agreedServiceId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ClientServicesAgreedServiceDisable. */
export type ClientServicesAgreedServiceDisablePayload = {
  __typename: 'ClientServicesAgreedServiceDisablePayload';
  agreedService: AgreedService;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientServicesAgreedServiceRemovePaymentMethod */
export type ClientServicesAgreedServiceRemovePaymentMethodInput = {
  /** Agreed Service Slug */
  agreedServiceId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ClientServicesAgreedServiceRemovePaymentMethod. */
export type ClientServicesAgreedServiceRemovePaymentMethodPayload = {
  __typename: 'ClientServicesAgreedServiceRemovePaymentMethodPayload';
  agreedService: AgreedService;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientServicesAgreedServiceSetPaymentMethod */
export type ClientServicesAgreedServiceSetPaymentMethodInput = {
  /** Agreed Service Slug */
  agreedServiceId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Payment Method Slug */
  paymentMethodId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientServicesAgreedServiceSetPaymentMethod. */
export type ClientServicesAgreedServiceSetPaymentMethodPayload = {
  __typename: 'ClientServicesAgreedServiceSetPaymentMethodPayload';
  agreedService: AgreedService;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export enum ClientServicesAgreedServiceStateEnum {
  /** Service was cancelled. */
  CANCELLED = 'CANCELLED',
  /** Service is currently inactive. */
  DISABLED = 'DISABLED',
  /** Service is currently active. */
  ENABLED = 'ENABLED',
  /** Service is due to start in the future. */
  UPCOMING = 'UPCOMING',
}

/** Autogenerated input type of ClientServicesAgreedServiceUpdate */
export type ClientServicesAgreedServiceUpdateInput = {
  /** Slug of Agreed Service to be updated */
  agreedServiceId: Scalars['ID']['input'];
  agreedServiceInput: AgreedServiceInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  notification?: InputMaybe<NotificationInput>;
  reason?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ClientServicesAgreedServiceUpdate. */
export type ClientServicesAgreedServiceUpdatePayload = {
  __typename: 'ClientServicesAgreedServiceUpdatePayload';
  agreedService: AgreedService;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientServicesAgreedServicesExport */
export type ClientServicesAgreedServicesExportInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The date to end calculating the total price of agreed services. */
  endDate?: InputMaybe<Scalars['Date']['input']>;
  /** Only agreed services with expiration on or after this date will be included. */
  expiresOnOrAfter?: InputMaybe<Scalars['Date']['input']>;
  /** The date to start calculating the total price of agreed services. */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Autogenerated return type of ClientServicesAgreedServicesExport. */
export type ClientServicesAgreedServicesExportPayload = {
  __typename: 'ClientServicesAgreedServicesExportPayload';
  backgroundJob: BackgroundJob;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientSetAppMapping */
export type ClientSetAppMappingInput = {
  /** The AppClients to map to */
  appClients: Array<AppClientInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Client to map */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientSetAppMapping. */
export type ClientSetAppMappingPayload = {
  __typename: 'ClientSetAppMappingPayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientSetDeployInvoices */
export type ClientSetDeployInvoicesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of client */
  id: Scalars['ID']['input'];
  willDeployInvoices: Scalars['Boolean']['input'];
};

/** Autogenerated return type of ClientSetDeployInvoices. */
export type ClientSetDeployInvoicesPayload = {
  __typename: 'ClientSetDeployInvoicesPayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientSetPaymentMethod */
export type ClientSetPaymentMethodInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Client ID */
  id: Scalars['ID']['input'];
  /**
   * The slug of the payment method to set. If not provided, the payment method will be
   * removed from future billings, and any scheduled payments will be cancelled.
   */
  paymentMethodId?: InputMaybe<Scalars['ID']['input']>;
  /** Specifies whether scheduled payments should also be updated. */
  updateScheduledPayments?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of ClientSetPaymentMethod. */
export type ClientSetPaymentMethodPayload = {
  __typename: 'ClientSetPaymentMethodPayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientSetPrimaryContact */
export type ClientSetPrimaryContactInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  contactId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientSetPrimaryContact. */
export type ClientSetPrimaryContactPayload = {
  __typename: 'ClientSetPrimaryContactPayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  defaultContact?: Maybe<Contact>;
  previousPrimaryContact?: Maybe<Contact>;
  primaryContact?: Maybe<Contact>;
};

/** Autogenerated input type of ClientSetTagsList */
export type ClientSetTagsListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  /** Tags */
  tagList?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated return type of ClientSetTagsList. */
export type ClientSetTagsListPayload = {
  __typename: 'ClientSetTagsListPayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export enum ClientState {
  ACTIVE = 'ACTIVE',
  ARCHIVED = 'ARCHIVED',
  DELETED = 'DELETED',
  INACTIVE = 'INACTIVE',
  LEAD = 'LEAD',
  LOST = 'LOST',
}

/** Autogenerated input type of ClientSurchargeDisable */
export type ClientSurchargeDisableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the client. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientSurchargeDisable. */
export type ClientSurchargeDisablePayload = {
  __typename: 'ClientSurchargeDisablePayload';
  client: Client;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientSurchargeEnable */
export type ClientSurchargeEnableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the client. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientSurchargeEnable. */
export type ClientSurchargeEnablePayload = {
  __typename: 'ClientSurchargeEnablePayload';
  client: Client;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientSwitchPaymentMethod */
export type ClientSwitchPaymentMethodInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The slug of the payment method to be changed. Any future billings or scheduled payments
   * using this payment method will be updated.
   */
  fromPaymentMethodId: Scalars['ID']['input'];
  /** Client ID */
  id: Scalars['ID']['input'];
  /** Specifies whether the from payment method should to be removed after switching. */
  removeFromPaymentMethod?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The slug of the payment method to set. If not provided, the payment method will be
   * removed from future billings, and any scheduled payments will be cancelled.
   */
  toPaymentMethodId?: InputMaybe<Scalars['ID']['input']>;
  /** Specifies whether scheduled payments should also be updated. */
  updateScheduledPayments?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of ClientSwitchPaymentMethod. */
export type ClientSwitchPaymentMethodPayload = {
  __typename: 'ClientSwitchPaymentMethodPayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** ClientSyncType contains details about an App's ClientSync. */
export type ClientSync = {
  __typename: 'ClientSync';
  /** The time the sync completed */
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The error message if state is failed */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** The time the sync failed */
  failedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** The time the sync started */
  startedAt: Scalars['DateTime']['output'];
  /** The sync's current state */
  state: ClientSyncState;
};

/** ClientSyncSettings contains details about an App's ClientSync settings. */
export type ClientSyncSettings = {
  __typename: 'ClientSyncSettings';
  /** Whether the ClientSync settings as configured are valid. */
  isValid: Scalars['Boolean']['output'];
  /** The direction client sync data is synced. */
  syncDirection: ClientSyncSettingsSyncDirection;
  /** Available options for the direction client sync data is synced. */
  syncDirectionOptions: Array<ClientSyncSettingsSyncDirection>;
  /** Which client data will be synced between Ignition and the App. */
  syncScope: ClientSyncSettingsSyncScope;
  /** Available options for which client data will be synced between Ignition and the App. */
  syncScopeOptions: Array<ClientSyncSettingsSyncScope>;
};

/** Input data containing an App's ClientSync settings. */
export type ClientSyncSettingsInput = {
  syncDirection: ClientSyncSettingsSyncDirection;
  syncScope: ClientSyncSettingsSyncScope;
};

export enum ClientSyncSettingsSyncDirection {
  FROM_APP = 'FROM_APP',
  TO_APP = 'TO_APP',
}

export enum ClientSyncSettingsSyncScope {
  CLIENT_NAME = 'CLIENT_NAME',
  EVERYTHING = 'EVERYTHING',
  NOTHING = 'NOTHING',
}

/** Autogenerated input type of ClientSyncSettingsUpdate */
export type ClientSyncSettingsUpdateInput = {
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  clientSyncSettings: ClientSyncSettingsInput;
};

/** Autogenerated return type of ClientSyncSettingsUpdate. */
export type ClientSyncSettingsUpdatePayload = {
  __typename: 'ClientSyncSettingsUpdatePayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export enum ClientSyncState {
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  STARTED = 'STARTED',
}

export enum ClientType {
  /** Client used to demonstrate features without influencing real client data. */
  DEMO = 'DEMO',
  /** Normal clients created by practices */
  STANDARD = 'STANDARD',
}

/** Autogenerated input type of ClientUnarchive */
export type ClientUnarchiveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientUnarchive. */
export type ClientUnarchivePayload = {
  __typename: 'ClientUnarchivePayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ClientUpdate */
export type ClientUpdateInput = {
  client: ClientInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the client. */
  id: Scalars['ID']['input'];
  xeroTrackingOptions?: InputMaybe<Array<SelectedTrackingOptionInput>>;
};

/** Autogenerated return type of ClientUpdate. */
export type ClientUpdatePayload = {
  __typename: 'ClientUpdatePayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export type ClientWorkflowItem = {
  __typename: 'ClientWorkflowItem';
  /** Name of the workflow app this item is configured to deploy to. */
  appName: Scalars['String']['output'];
  budget?: Maybe<Money>;
  categories: Array<WorkflowCategoryType>;
  createdAt: Scalars['DateTime']['output'];
  /** Collection of all deployment attempts made for this item. */
  deployments: ClientWorkflowItemDeploymentConnection;
  description?: Maybe<Scalars['String']['output']>;
  duration?: Maybe<Duration>;
  endDate: Scalars['Date']['output'];
  id: Scalars['ID']['output'];
  /** @deprecated lock_version should only be used internally. */
  lockVersion: Scalars['Int']['output'];
  manager?: Maybe<User>;
  name?: Maybe<Scalars['String']['output']>;
  partner?: Maybe<User>;
  staff: Array<User>;
  startDate: Scalars['Date']['output'];
  state: ClientWorkflowItemState;
  templates: Array<WorkflowTemplateType>;
  updatedAt: Scalars['DateTime']['output'];
};

export type ClientWorkflowItemDeploymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ClientWorkflowItemDeploymentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ClientWorkflowItemDeploymentOrder>;
};

/** The connection type for ClientWorkflowItem. */
export type ClientWorkflowItemConnection = {
  __typename: 'ClientWorkflowItemConnection';
  /** A list of edges. */
  edges: Array<ClientWorkflowItemEdge>;
  /** A list of nodes. */
  nodes: Array<ClientWorkflowItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type ClientWorkflowItemDeployment = {
  __typename: 'ClientWorkflowItemDeployment';
  appName: Scalars['String']['output'];
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  externalId?: Maybe<Scalars['ID']['output']>;
  /** URL of the deployed item on the workflow app (if available). */
  externalUrl?: Maybe<Scalars['String']['output']>;
  failedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  message?: Maybe<Scalars['String']['output']>;
  startedAt?: Maybe<Scalars['DateTime']['output']>;
  state: ClientWorkflowItemDeploymentState;
};

/** The connection type for ClientWorkflowItemDeployment. */
export type ClientWorkflowItemDeploymentConnection = {
  __typename: 'ClientWorkflowItemDeploymentConnection';
  /** A list of edges. */
  edges: Array<ClientWorkflowItemDeploymentEdge>;
  /** A list of nodes. */
  nodes: Array<ClientWorkflowItemDeployment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ClientWorkflowItemDeploymentEdge = {
  __typename: 'ClientWorkflowItemDeploymentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ClientWorkflowItemDeployment;
};

export type ClientWorkflowItemDeploymentFilter = {
  stateIn?: InputMaybe<Array<ClientWorkflowItemState>>;
};

export type ClientWorkflowItemDeploymentOrder = {
  /** Sort by when the deployment was marked as completed. */
  completedAt?: InputMaybe<OrderBy>;
  /** Sort by when the deployment was marked as failed. */
  failedAt?: InputMaybe<OrderBy>;
  /** Sort by when the deployment was started. */
  startedAt?: InputMaybe<OrderBy>;
};

export enum ClientWorkflowItemDeploymentState {
  /** Deployment successfully created the item in the workflow app. */
  COMPLETED = 'COMPLETED',
  /** Deployment failed to create the item in the workflow app. */
  FAILED = 'FAILED',
  /** Deployment is currently attempting to create the item in the workflow app. */
  STARTED = 'STARTED',
}

/** An edge in a connection. */
export type ClientWorkflowItemEdge = {
  __typename: 'ClientWorkflowItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ClientWorkflowItem;
};

export enum ClientWorkflowItemState {
  /** Item has been deleted. Note the item may still exist on the workflow app. */
  DELETED = 'DELETED',
  /** Item has been deployed to the workflow app. */
  DEPLOYED = 'DEPLOYED',
  /** Item is currently being deployed to the workflow app. */
  DEPLOYING = 'DEPLOYING',
  /** Item has not been deployed to the workflow app. */
  UNDEPLOYED = 'UNDEPLOYED',
}

export type ClientWorkflowStrategy = {
  __typename: 'ClientWorkflowStrategy';
  activities: ActivityLogConnection;
  /** The workflow app this strategy is configured to deploy to. */
  appName: Scalars['String']['output'];
  /** If assigned, invoices raised with this billing group will have their credits applied to this workflow strategy. */
  billingGroup?: Maybe<BillingGroup>;
  /** Will receive work credits for services billed using this reference (if set) */
  billingReference?: Maybe<Scalars['String']['output']>;
  budget?: Maybe<Money>;
  categories: Array<WorkflowCategoryType>;
  client: Client;
  /** Time the workflow strategy was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Time the workflow strategy was deactivated. */
  deactivatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Denotes whether this workflow strategy should deploy jobs automatically. */
  deployStrategy: ClientWorkflowStrategyDeployStrategy;
  description?: Maybe<Scalars['String']['output']>;
  duration?: Maybe<Duration>;
  id: Scalars['ID']['output'];
  /** Has this workflow strategy started deploying jobs? */
  isStarted: Scalars['Boolean']['output'];
  items: ClientWorkflowItemConnection;
  lockVersion: Scalars['Int']['output'];
  manager?: Maybe<User>;
  name?: Maybe<Scalars['String']['output']>;
  partner?: Maybe<User>;
  /** Workflow schedule */
  schedule: Schedule;
  staff: Array<User>;
  state: ClientWorkflowStrategyState;
  templates: Array<WorkflowTemplateType>;
  /** Time the workflow strategy was last modified. */
  updatedAt: Scalars['DateTime']['output'];
};

export type ClientWorkflowStrategyActivitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ActivityLogOrder>;
};

export type ClientWorkflowStrategyItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ClientWorkflowStrategy. */
export type ClientWorkflowStrategyConnection = {
  __typename: 'ClientWorkflowStrategyConnection';
  /** A list of edges. */
  edges: Array<ClientWorkflowStrategyEdge>;
  /** A list of nodes. */
  nodes: Array<ClientWorkflowStrategy>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export enum ClientWorkflowStrategyDeployStrategy {
  AUTOMATIC = 'AUTOMATIC',
  MANUAL = 'MANUAL',
}

/** An edge in a connection. */
export type ClientWorkflowStrategyEdge = {
  __typename: 'ClientWorkflowStrategyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ClientWorkflowStrategy;
};

export type ClientWorkflowStrategyFilter = {
  stateIn?: InputMaybe<Array<ClientWorkflowStrategyState>>;
};

export type ClientWorkflowStrategyOrder = {
  /** Sort by when the workflow strategy was created. */
  createdAt?: InputMaybe<OrderBy>;
  /** Sort by when the workflow strategy was deactivated. */
  deactivatedAt?: InputMaybe<OrderBy>;
};

export enum ClientWorkflowStrategyState {
  /** Workflow strategy is active and will deploy items according to the schedule. */
  ACTIVE = 'ACTIVE',
  /** Workflow strategy has been deleted and is no longer available. */
  DELETED = 'DELETED',
  /** Workflow strategy is inactive and will not deploy any further items. */
  INACTIVE = 'INACTIVE',
}

export enum ClientsCount {
  /** 501-1000 clients */
  FIVE_HUNDRED_AND_ONE_TO_ONE_THOUSAND = 'FIVE_HUNDRED_AND_ONE_TO_ONE_THOUSAND',
  /** 101-250 clients */
  ONE_HUNDRED_AND_ONE_TO_TWO_HUNDRED_FIFTY = 'ONE_HUNDRED_AND_ONE_TO_TWO_HUNDRED_FIFTY',
  /** 1001-2000 clients */
  ONE_THOUSAND_AND_ONE_TO_TWO_THOUSAND = 'ONE_THOUSAND_AND_ONE_TO_TWO_THOUSAND',
  /**
   * 1-30 clients
   * @deprecated split into ZERO_TO_NINE and TEN_TO_THIRTY instead
   */
  ONE_TO_THIRTY = 'ONE_TO_THIRTY',
  /** 61-100 clients */
  SIXTY_ONE_TO_ONE_HUNDRED = 'SIXTY_ONE_TO_ONE_HUNDRED',
  /** 10-30 clients */
  TEN_TO_THIRTY = 'TEN_TO_THIRTY',
  /** 31-60 clients */
  THIRTY_ONE_TO_SIXTY = 'THIRTY_ONE_TO_SIXTY',
  /** 251-500 clients */
  TWO_HUNDRED_FIFTY_ONE_TO_FIVE_HUNDRED = 'TWO_HUNDRED_FIFTY_ONE_TO_FIVE_HUNDRED',
  /** 2000+ clients */
  TWO_THOUSAND_PLUS = 'TWO_THOUSAND_PLUS',
  /** 0-9 clients */
  ZERO_TO_NINE = 'ZERO_TO_NINE',
}

export type Collection = {
  __typename: 'Collection';
  amount: Money;
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  disbursal?: Maybe<Disbursal>;
  externalId?: Maybe<Scalars['String']['output']>;
  failedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  message?: Maybe<Scalars['String']['output']>;
  payment: Payment;
  paymentMethod: PaymentMethod;
  scheduledTime?: Maybe<Scalars['DateTime']['output']>;
  startedAt?: Maybe<Scalars['DateTime']['output']>;
  state: PaymentsCollectionState;
  /** Surcharge added to the collection */
  surchargeAmount: Money;
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for Collection. */
export type CollectionConnection = {
  __typename: 'CollectionConnection';
  /** A list of edges. */
  edges: Array<CollectionEdge>;
  /** A list of nodes. */
  nodes: Array<Collection>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CollectionEdge = {
  __typename: 'CollectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Collection;
};

export type Collections = {
  __typename: 'Collections';
  isEnabled: Scalars['Boolean']['output'];
};

export type CollectionsNotificationSettings = {
  __typename: 'CollectionsNotificationSettings';
  toEmailAddresses: Array<Scalars['EmailAddress']['output']>;
};

/** Autogenerated input type of CollectionsNotificationSettingsUpdate */
export type CollectionsNotificationSettingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  toEmailAddresses: Array<Scalars['EmailAddress']['input']>;
};

/** Autogenerated return type of CollectionsNotificationSettingsUpdate. */
export type CollectionsNotificationSettingsUpdatePayload = {
  __typename: 'CollectionsNotificationSettingsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  collectionsNotificationSettings: CollectionsNotificationSettings;
};

/** Autogenerated return type of Connected. */
export type ConnectedPayload = {
  __typename: 'ConnectedPayload';
  quickbooksApp: App;
};

export type Contact = {
  __typename: 'Contact';
  /** Name to be used when addressing letters or post to this Contact */
  addressee?: Maybe<Scalars['String']['output']>;
  client?: Maybe<Client>;
  createdAt: Scalars['DateTime']['output'];
  email?: Maybe<Scalars['EmailAddress']['output']>;
  id: Scalars['ID']['output'];
  isRecipient: Scalars['Boolean']['output'];
  isSignatory: Scalars['Boolean']['output'];
  mobile?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  phone?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['String']['output']>;
  referenceNumber: Scalars['ID']['output'];
  salutation?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  /** @deprecated Use id instead */
  uuid: Scalars['ID']['output'];
};

/** The connection type for Contact. */
export type ContactConnection = {
  __typename: 'ContactConnection';
  /** A list of edges. */
  edges: Array<ContactEdge>;
  /** A list of nodes. */
  nodes: Array<Contact>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ContactEdge = {
  __typename: 'ContactEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Contact;
};

export type ContactInput = {
  addressee?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['EmailAddress']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  isDefault?: InputMaybe<Scalars['Boolean']['input']>;
  isRecipient?: InputMaybe<Scalars['Boolean']['input']>;
  mobile?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  salutation?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of ContactUpdate */
export type ContactUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  contact: UpdateContactInput;
};

/** Autogenerated return type of ContactUpdate. */
export type ContactUpdatePayload = {
  __typename: 'ContactUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  contact?: Maybe<Contact>;
  userErrors?: Maybe<Array<UserError>>;
};

export enum CouponDiscountType {
  AMOUNT = 'AMOUNT',
  PERCENT = 'PERCENT',
}

export type CreditCardPaymentMethod = PaymentsPaymentMethod & {
  __typename: 'CreditCardPaymentMethod';
  createdAt: Scalars['DateTime']['output'];
  displayMethodType: Scalars['String']['output'];
  expiryDate: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isExpired: Scalars['Boolean']['output'];
  isInUse: Scalars['Boolean']['output'];
  isInternational: Scalars['Boolean']['output'];
  isInvalid: Scalars['Boolean']['output'];
  /** Whether a surcharge will be applied when charging this payment method */
  isSurchargeEnabled: Scalars['Boolean']['output'];
  name?: Maybe<Scalars['String']['output']>;
  numberSuffix: Scalars['String']['output'];
  referenceNumber: Scalars['ID']['output'];
  /** The category by which we determine the rate of surcharge */
  surchargeCategory?: Maybe<PaymentMethodSurchargeCategory>;
  /** The rate of surcharge added to this payment method's charges to account for payment fees */
  surchargeRate: Percentage;
  type: PaymentMethodType;
  verified: Scalars['Boolean']['output'];
};

export type Currency = {
  __typename: 'Currency';
  /** character between the whole and fraction amounts */
  decimalMark: Scalars['String']['output'];
  /** the international 3-letter code as defined by the ISO 4217 standard */
  isoCode: Scalars['String']['output'];
  /** the international 3-digit code as defined by the ISO 4217 standard */
  isoNumeric: Scalars['String']['output'];
  /** the currency name */
  name: Scalars['String']['output'];
  /** a numerical value you can use to sort/group the currency list */
  priority: Scalars['Int']['output'];
  /** the name of the fractional monetary unit */
  subunit: Scalars['String']['output'];
  /** the proportion between the unit and the subunit */
  subunitToUnit: Scalars['Int']['output'];
  /** the currency symbol (UTF-8 encoded) */
  symbol: Scalars['String']['output'];
  /** character between each thousands place */
  thousandsSeparator: Scalars['String']['output'];
};

export type CustomTemplateFilter = {
  /** Name of the template */
  nameCont?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerSuccessEngagementLetter = {
  __typename: 'CustomerSuccessEngagementLetter';
  createdAt: Scalars['DateTime']['output'];
  creator: User;
  file: Filestack;
  id: Scalars['ID']['output'];
  state: EngagementLetterState;
};

/** The connection type for CustomerSuccessEngagementLetter. */
export type CustomerSuccessEngagementLetterConnection = {
  __typename: 'CustomerSuccessEngagementLetterConnection';
  /** A list of edges. */
  edges: Array<CustomerSuccessEngagementLetterEdge>;
  /** A list of nodes. */
  nodes: Array<CustomerSuccessEngagementLetter>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of CustomerSuccessEngagementLetterCreate */
export type CustomerSuccessEngagementLetterCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  file: FilestackInput;
};

/** Autogenerated return type of CustomerSuccessEngagementLetterCreate. */
export type CustomerSuccessEngagementLetterCreatePayload = {
  __typename: 'CustomerSuccessEngagementLetterCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagementLetter: CustomerSuccessEngagementLetter;
};

/** An edge in a connection. */
export type CustomerSuccessEngagementLetterEdge = {
  __typename: 'CustomerSuccessEngagementLetterEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: CustomerSuccessEngagementLetter;
};

export type CustomerSuccessMaturityIndex = {
  __typename: 'CustomerSuccessMaturityIndex';
  clientsCount?: Maybe<ClientsCount>;
  clientsCountOptions: Array<Option>;
  id: Scalars['ID']['output'];
  industry?: Maybe<Industry>;
  industryOptions: Array<Option>;
  ledger?: Maybe<Ledger>;
  ledgerOptions: Array<Option>;
  projectedPercentGrowthForThisYear?: Maybe<Percentage>;
  /** The lower bound of the revenue bracket used to determine the revenue score if revenue range is provided from CMI questions */
  revenueBracketBottom?: Maybe<Scalars['Int']['output']>;
  /** The upper bound of the revenue bracket used to determine the revenue score if revenue range is provided from CMI questions */
  revenueBracketTop?: Maybe<Scalars['Int']['output']>;
  revenueLastYear?: Maybe<Money>;
  revenueScore: Scalars['Int']['output'];
  score: Scalars['Int']['output'];
};

/** Autogenerated input type of CustomerSuccessMaturityIndexCalculate */
export type CustomerSuccessMaturityIndexCalculateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  customerSuccessMaturityIndex: MaturityIndexInput;
};

/** Autogenerated return type of CustomerSuccessMaturityIndexCalculate. */
export type CustomerSuccessMaturityIndexCalculatePayload = {
  __typename: 'CustomerSuccessMaturityIndexCalculatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  customerSuccessMaturityIndex?: Maybe<CustomerSuccessMaturityIndexUnion>;
};

/** Possible maturity index types based on version */
export type CustomerSuccessMaturityIndexUnion =
  | CustomerSuccessMaturityIndex
  | CustomerSuccessVersion1MaturityIndex;

/** Autogenerated input type of CustomerSuccessMaturityIndexUpdateIndustry */
export type CustomerSuccessMaturityIndexUpdateIndustryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  industry: Industry;
};

/** Autogenerated return type of CustomerSuccessMaturityIndexUpdateIndustry. */
export type CustomerSuccessMaturityIndexUpdateIndustryPayload = {
  __typename: 'CustomerSuccessMaturityIndexUpdateIndustryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  customerSuccessMaturityIndex?: Maybe<CustomerSuccessMaturityIndexUnion>;
};

export type CustomerSuccessReferralCopy = {
  __typename: 'CustomerSuccessReferralCopy';
  description: Scalars['String']['output'];
  title: Scalars['String']['output'];
};

export type CustomerSuccessVersion1MaturityIndex = {
  __typename: 'CustomerSuccessVersion1MaturityIndex';
  clientsCount?: Maybe<ClientsCount>;
  feeStructure: FeeStructure;
  id: Scalars['ID']['output'];
  industry?: Maybe<Industry>;
  ledger?: Maybe<Ledger>;
  paymentCollectionTool?: Maybe<MaturityIndexPaymentCollectionToolEnum>;
  paymentCollectionToolOther?: Maybe<Scalars['String']['output']>;
  projectedPercentGrowthForThisYear?: Maybe<Percentage>;
  revenueLastYear?: Maybe<Money>;
  score: Scalars['Int']['output'];
  staffCount: StaffCount;
  workflowTool?: Maybe<MaturityIndexWorkflowToolEnum>;
  workflowToolOther?: Maybe<Scalars['String']['output']>;
};

export type Dashboard = {
  __typename: 'Dashboard';
  /** Renders the graph of clients data. */
  clientsGraph: DashboardClientsGraph;
  /** Renders the graph of payments data. */
  paymentsGraph: DashboardPaymentsGraph;
  settings: DashboardSettings;
};

export type DashboardClientsGraphArgs = {
  demo?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DashboardPaymentsGraphArgs = {
  demo?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DashboardBudget = {
  __typename: 'DashboardBudget';
  /** Amount of the budget. */
  amount: Money;
  /** Date of the budget. */
  date: Scalars['Date']['output'];
};

export type DashboardClientVariances = {
  __typename: 'DashboardClientVariances';
  /** Variance in current client count (how much change and in which direction). */
  currentClientsCount: DashboardVarianceCurrentClientsCount;
};

export type DashboardClientsGraph = {
  __typename: 'DashboardClientsGraph';
  /** Number of current clients. */
  currentClientsCount: Scalars['Int']['output'];
  /** Count of clients per month. */
  monthlyClientsCount: Array<DashboardMonthlyClientsCount>;
  /** Number of new clients. */
  newClientsCount: Scalars['Int']['output'];
  /** Grouping all the variances regarding clients. */
  variances: DashboardClientVariances;
};

export type DashboardMonthlyClientsCount = {
  __typename: 'DashboardMonthlyClientsCount';
  /** Number of current clients this month. */
  count: Scalars['Int']['output'];
  date: Scalars['Date']['output'];
};

export type DashboardPaymentsCount = {
  __typename: 'DashboardPaymentsCount';
  count: Scalars['Int']['output'];
};

export type DashboardPaymentsCountPercentage = {
  __typename: 'DashboardPaymentsCountPercentage';
  count: Scalars['Int']['output'];
  percentage: Scalars['Int']['output'];
};

export type DashboardPaymentsCountSum = {
  __typename: 'DashboardPaymentsCountSum';
  count: Scalars['Int']['output'];
  sum: Scalars['Float']['output'];
};

export type DashboardPaymentsData = {
  __typename: 'DashboardPaymentsData';
  /** Number of payments this month. */
  count: Scalars['Int']['output'];
  /** Credited this month. */
  credit: Scalars['Float']['output'];
  /** Projected credits this month. */
  creditProjected: Scalars['Float']['output'];
  /** Month. */
  date: Scalars['Date']['output'];
  /** Debited this month. */
  debit: Scalars['Float']['output'];
  /** Projected debits this month. */
  debitProjected: Scalars['Float']['output'];
  /** Total for the month. */
  total: Scalars['Float']['output'];
};

export type DashboardPaymentsGraph = {
  __typename: 'DashboardPaymentsGraph';
  /** Graph data of payments. */
  data: Array<DashboardPaymentsData>;
  generatedAt: Scalars['DateTime']['output'];
  /** Payments metadata */
  metadata: DashboardPaymentsMetadata;
};

export type DashboardPaymentsMetadata = {
  __typename: 'DashboardPaymentsMetadata';
  /** Number of at risk clients and sum of at risk payments. */
  atRisk: DashboardPaymentsCountSum;
  /** Payments collected. */
  collected: Scalars['Float']['output'];
  /** Number of defaults and sum of defaults. */
  defaults: DashboardPaymentsCountSum;
  /** Number of expiring cards and sum of expiring payments. */
  expiring: DashboardPaymentsCountSum;
  /** Count and percentage of payments. */
  payments: DashboardPaymentsCountPercentage;
  /** Potential payments. */
  potential: Scalars['Float']['output'];
  /** Payments scheduled. */
  scheduled: Scalars['Float']['output'];
  /** Payments total. */
  total: Scalars['Float']['output'];
  /** Number of verifying payments. */
  verifying: DashboardPaymentsCount;
};

/** Autogenerated input type of DashboardRevenueGrowthTargetSet */
export type DashboardRevenueGrowthTargetSetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Estimated percentage growth of revenue for this year */
  projectedGrowthForThisYear: PercentageInput;
  /** Estimate of last year's revenue. */
  revenueLastYear?: InputMaybe<MoneyInput>;
};

/** Autogenerated return type of DashboardRevenueGrowthTargetSet. */
export type DashboardRevenueGrowthTargetSetPayload = {
  __typename: 'DashboardRevenueGrowthTargetSetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  settings?: Maybe<DashboardSettings>;
};

export type DashboardSettings = {
  __typename: 'DashboardSettings';
  /** Estimated yearly budget for the current period. */
  budgets: Array<DashboardBudget>;
  /** Calculated estimate of this year's revenue. */
  growthTarget?: Maybe<Money>;
  /** Recorded estimate of this year's revenue growth rate. */
  projectedGrowthForThisYear?: Maybe<Percentage>;
  /** Latest recorded estimate of last year's revenue. */
  revenueLastYear?: Maybe<Money>;
  /** Recorded staff count of the practice. */
  staffCount?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of DashboardUpdateSettings */
export type DashboardUpdateSettingsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  settings: SettingsInput;
};

/** Autogenerated return type of DashboardUpdateSettings. */
export type DashboardUpdateSettingsPayload = {
  __typename: 'DashboardUpdateSettingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  settings: DashboardSettings;
};

export type DashboardVarianceCurrentClientsCount = {
  __typename: 'DashboardVarianceCurrentClientsCount';
  /** Direction of change (e.g. positive or negative). */
  isPositive: Scalars['Boolean']['output'];
  /** How much the current clients count changed. */
  number: Scalars['Int']['output'];
};

export type DateInput = {
  /** ISO formatted date */
  date?: InputMaybe<Scalars['Date']['input']>;
};

export type DateRangeInput = {
  /** ISO formatted date */
  from?: InputMaybe<Scalars['Date']['input']>;
  /** ISO formatted date */
  to: Scalars['Date']['input'];
};

export enum DefaultBillingType {
  ESTIMATE = 'ESTIMATE',
  INCLUDED = 'INCLUDED',
  ON_COMPLETION = 'ON_COMPLETION',
  RECURRING = 'RECURRING',
  UPFRONT = 'UPFRONT',
}

export type Disbursal = {
  __typename: 'Disbursal';
  amount: Money;
  availableOn: Scalars['Date']['output'];
  clawbacks: ClawbackConnection;
  disputes: PaymentsDisbursalDisputeConnection;
  externalId: Scalars['String']['output'];
  feeAmount: Money;
  feeDescription: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  message?: Maybe<Scalars['String']['output']>;
  /** Flag to indicate if there is any payments fee pending */
  paymentFeesPending: Scalars['Boolean']['output'];
  payments?: Maybe<PaymentConnection>;
  paymentsCount: Scalars['Int']['output'];
  startedAt: Scalars['DateTime']['output'];
  state: PaymentsDisbursalStateEnum;
};

export type DisbursalClawbacksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type DisbursalDisputesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type DisbursalPaymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Disbursal. */
export type DisbursalConnection = {
  __typename: 'DisbursalConnection';
  /** A list of edges. */
  edges: Array<DisbursalEdge>;
  /** A list of nodes. */
  nodes: Array<Disbursal>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DisbursalEdge = {
  __typename: 'DisbursalEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Disbursal;
};

export type DisbursalFilter = {
  /** ISO formatted date */
  availableOnAfter?: InputMaybe<Scalars['Date']['input']>;
  /** ISO formatted date */
  availableOnBefore?: InputMaybe<Scalars['Date']['input']>;
  externalIdEq?: InputMaybe<Scalars['String']['input']>;
  stateEq?: InputMaybe<PaymentsPaymentStateEnum>;
};

export type Disbursals = {
  __typename: 'Disbursals';
  bankAccount?: Maybe<BankAccount>;
  id: Scalars['ID']['output'];
  /** @deprecated Use practice.paymentSettings.isDisbursalsEnabled instead. */
  isEnabled: Scalars['Boolean']['output'];
};

export enum DisbursalsDisablementType {
  DISBURSAL_ACCOUNT_CHANGED = 'DISBURSAL_ACCOUNT_CHANGED',
  FRAUD_DETECTION = 'FRAUD_DETECTION',
  KYC_REQUIRED = 'KYC_REQUIRED',
  REJECTED_BY_STAFF = 'REJECTED_BY_STAFF',
  STRIPE_PAYOUTS_DISABLED = 'STRIPE_PAYOUTS_DISABLED',
  SUBSCRIPTION_EXPIRED = 'SUBSCRIPTION_EXPIRED',
}

/** Discount specified as either a currency amount, or a percentage */
export type DiscountRuleInput = {
  amount?: InputMaybe<AmountDiscountRuleInput>;
  none?: InputMaybe<NoneDiscountRuleInput>;
  percent?: InputMaybe<PercentDiscountRuleInput>;
};

export type DisplayableError = {
  /** Path to the input field which caused the error */
  field?: Maybe<Array<Scalars['String']['output']>>;
  /** The error message */
  message: Scalars['String']['output'];
};

export type DuplicateClientRecord = {
  __typename: 'DuplicateClientRecord';
  /** App client to be imported that's a potential duplicate */
  appClient: AppClient;
  /** Ignition client with whom the app client is a potential duplicate */
  ignitionClient: Client;
};

export enum DuplicateResolutionEnum {
  IMPORT_AS_NEW = 'IMPORT_AS_NEW',
  LINK = 'LINK',
  SKIP = 'SKIP',
}

export type Duration = {
  __typename: 'Duration';
  count: Scalars['Int']['output'];
  interval: DurationInterval;
};

export type DurationInput = {
  count: Scalars['Int']['input'];
  interval: DurationInterval;
};

export enum DurationInterval {
  DAYS = 'DAYS',
  MONTHS = 'MONTHS',
  WEEKS = 'WEEKS',
  YEARS = 'YEARS',
}

export type EmailPreview = {
  __typename: 'EmailPreview';
  /** The rendered HTML email content */
  contentHtml: Scalars['String']['output'];
  /** The sender email address */
  from: Scalars['EmailAddress']['output'];
  /** The subject of the email message */
  subject: Scalars['String']['output'];
  /** A list of destination email addresses */
  to: Array<Scalars['EmailAddress']['output']>;
};

export type EmailSettings = {
  __typename: 'EmailSettings';
  name: EmailSettingsName;
  setting: EmailSettingsSetting;
};

export type EmailSettingsInput = {
  name: EmailSettingsName;
  setting: EmailSettingsSetting;
};

export enum EmailSettingsName {
  INVOICES = 'INVOICES',
  PAYMENT_RECEIPTS = 'PAYMENT_RECEIPTS',
}

export enum EmailSettingsSetting {
  DEFAULT = 'DEFAULT',
  OFF = 'OFF',
  ON = 'ON',
}

export type EmailTemplate = PracticeTemplate & {
  __typename: 'EmailTemplate';
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  slug: Scalars['ID']['output'];
  subject: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type EmailTemplateInput = {
  content: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  subject: Scalars['String']['input'];
};

export type EmailTemplateInterface = {
  subject: Scalars['String']['output'];
};

/** Engagement (CPE Proposal) Jobs */
export type EngagedJob = {
  __typename: 'EngagedJob';
  description?: Maybe<Scalars['String']['output']>;
  engagedServices: Array<EngagedService>;
  id: Scalars['ID']['output'];
  /** Is this a billing job? */
  isBilling: Scalars['Boolean']['output'];
  manager?: Maybe<User>;
  name: Scalars['String']['output'];
  parent?: Maybe<EngagedJob>;
  position: Scalars['Int']['output'];
  recurrence: EngagedJobRecurrenceUnion;
  staff: Array<User>;
};

export type EngagedJobInput = {
  /** Is this a billing job? */
  billing: Scalars['Boolean']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  engagedServices: Array<EngagedServiceInput>;
  /** User who will manage this job. */
  managerId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position: Scalars['Int']['input'];
  recurrence: EngagedJobRecurrenceInput;
  /** Users who will be assigned to this job as staff. */
  staffIds?: Array<Scalars['ID']['input']>;
};

export enum EngagedJobRecurrenceCreateJobsUntil {
  DATE = 'DATE',
  PROPOSAL_COMPLETE = 'PROPOSAL_COMPLETE',
}

/** Recurrence settings for an engaged job. */
export type EngagedJobRecurrenceInput = {
  nonRecurring?: InputMaybe<EngagedJobRecurrenceNonRecurringInput>;
  recurring?: InputMaybe<EngagedJobRecurrenceRecurringInput>;
};

export type EngagedJobRecurrenceNonRecurring = {
  __typename: 'EngagedJobRecurrenceNonRecurring';
  dueDate: Scalars['Date']['output'];
  startDate: Scalars['Date']['output'];
};

export type EngagedJobRecurrenceNonRecurringInput = {
  dueDate: Scalars['Date']['input'];
  startDate: Scalars['Date']['input'];
};

export type EngagedJobRecurrenceRecurring = {
  __typename: 'EngagedJobRecurrenceRecurring';
  createJobsUntil: EngagedJobRecurrenceCreateJobsUntil;
  /** End date for job. N/A unless createJobsUntil is DATE. */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** The interval which jobs will repeat. */
  scheduledInterval: Duration;
  startDate: Scalars['Date']['output'];
};

export type EngagedJobRecurrenceRecurringInput = {
  createJobsUntil: EngagedJobRecurrenceCreateJobsUntil;
  /** End date for job. Ignored if createJobsUntil is PROPOSAL_COMPLETED. */
  endDate?: InputMaybe<Scalars['Date']['input']>;
  /** The interval which jobs will repeat. */
  scheduledInterval: DurationInput;
  startDate: Scalars['Date']['input'];
};

/** Possible recurrence types for an Engaged Job. */
export type EngagedJobRecurrenceUnion =
  | EngagedJobRecurrenceNonRecurring
  | EngagedJobRecurrenceRecurring;

/** Engagement (CPE Proposal) Services */
export type EngagedService = {
  __typename: 'EngagedService';
  billing: EngagedServiceBillingUnion;
  /** The list of comments about this service. */
  comments: Array<EngagementComment>;
  /** Service description */
  description?: Maybe<Scalars['String']['output']>;
  engagedJob: EngagedJob;
  id: Scalars['ID']['output'];
  /** Is this an adjustment service? */
  isAdjustment: Scalars['Boolean']['output'];
  /** Is this service invoiced? */
  isInvoiced: Scalars['Boolean']['output'];
  /** Is this service optional? */
  isOptional: Scalars['Boolean']['output'];
  /** Service name */
  name: Scalars['String']['output'];
  /** @deprecated Use billing { priceRule } instead. */
  priceRule?: Maybe<
    | BillingFixedPriceRule
    | BillingIncludedPriceRule
    | BillingMinimumPriceRule
    | BillingRangePriceRule
    | BillingUnitPriceRule
  >;
  /** Is this service QBO US tax exempt? */
  qboUsTaxExempt: Scalars['Boolean']['output'];
  /** @deprecated Use billing { quantity } instead, where relevant. */
  quantity?: Maybe<Scalars['Int']['output']>;
  /** Schedules invoices */
  schedulesInvoices: Scalars['Boolean']['output'];
  /** The linked library service (not applicable if an adjustment service.) */
  service?: Maybe<Service>;
  /** Assigned custom tax rate for this service. */
  tax?: Maybe<Tax>;
};

export type EngagedServiceBillingEstimateRange = {
  __typename: 'EngagedServiceBillingEstimateRange';
  /** Formatted description of price */
  priceForDisplay: Scalars['String']['output'];
  priceRule: BillingRangePriceRule;
  tax: Tax;
};

export type EngagedServiceBillingEstimateUnit = {
  __typename: 'EngagedServiceBillingEstimateUnit';
  /** Formatted description of price */
  priceForDisplay: Scalars['String']['output'];
  priceRule: BillingUnitPriceRule;
  tax: Tax;
};

export type EngagedServiceBillingIncluded = {
  __typename: 'EngagedServiceBillingIncluded';
  /** Formatted description of price */
  priceForDisplay: Scalars['String']['output'];
  priceRule: BillingIncludedPriceRule;
};

export type EngagedServiceBillingOnCompletion = {
  __typename: 'EngagedServiceBillingOnCompletion';
  depositAmount?: Maybe<Money>;
  depositPercentage?: Maybe<Percentage>;
  /** Deposit price for display */
  depositPriceForDisplay?: Maybe<Scalars['String']['output']>;
  enableDeposit?: Maybe<Scalars['Boolean']['output']>;
  /** Formatted description of price */
  priceForDisplay: Scalars['String']['output'];
  priceRule: BillingFixedPriceRule;
  quantity: Scalars['Int']['output'];
  tax: Tax;
};

export type EngagedServiceBillingRecurring = {
  __typename: 'EngagedServiceBillingRecurring';
  isProrata?: Maybe<Scalars['Boolean']['output']>;
  /** Legacy formatted description of price */
  priceForDisplay: Scalars['String']['output'];
  priceRule: BillingFixedPriceRule;
  /**
   * If prorata is enabled, this is the amount that will be deducted from the on-acceptance prorata amount."
   *
   * For example, if this engaged service is billed as recurring $100, and the engagement has 5 catch up periods,
   * the prorata amount charged on-acceptance will be $500 by default. If the prorata delta is set to $100,
   * only $400 will be charged on-acceptance instead.
   */
  prorataDelta?: Maybe<Scalars['Decimal']['output']>;
  /** Prorata price for display */
  prorataPriceForDisplay?: Maybe<Scalars['String']['output']>;
  quantity: Scalars['Int']['output'];
  tax: Tax;
};

export type EngagedServiceBillingTypeEstimateRangeInput = {
  priceRule: RangePriceRuleInput;
  /** The tax rate for this service. */
  taxId: Scalars['ID']['input'];
};

export type EngagedServiceBillingTypeEstimateUnitInput = {
  priceRule: UnitPriceRuleInput;
  /** The tax rate for this service. */
  taxId: Scalars['ID']['input'];
};

export type EngagedServiceBillingTypeIncludedInput = {
  priceRule: IncludedPriceRuleInput;
};

/** Billing Type settings for an Engaged Service. */
export type EngagedServiceBillingTypeInput = {
  estimateRange?: InputMaybe<EngagedServiceBillingTypeEstimateRangeInput>;
  estimateUnit?: InputMaybe<EngagedServiceBillingTypeEstimateUnitInput>;
  included?: InputMaybe<EngagedServiceBillingTypeIncludedInput>;
  onCompletion?: InputMaybe<EngagedServiceBillingTypeOnCompletionInput>;
  recurring?: InputMaybe<EngagedServiceBillingTypeRecurringInput>;
  upfront?: InputMaybe<EngagedServiceBillingTypeUpfrontInput>;
};

export type EngagedServiceBillingTypeOnCompletionInput = {
  /** If provided, this percentage of the service price will be charged as a deposit on-acceptance. */
  depositPercentage?: InputMaybe<PercentageInput>;
  priceRule: FixedPriceRuleInput;
  quantity?: Scalars['Int']['input'];
  /** The tax rate for this service. */
  taxId: Scalars['ID']['input'];
};

export type EngagedServiceBillingTypeRecurringInput = {
  /** Charge pro-rata for missed billing periods? */
  isProrata?: InputMaybe<Scalars['Boolean']['input']>;
  priceRule: FixedPriceRuleInput;
  /** Amount to subtract from pro-rata amount. */
  prorataDelta?: InputMaybe<Scalars['Decimal']['input']>;
  quantity?: Scalars['Int']['input'];
  /** The tax rate for this service. */
  taxId: Scalars['ID']['input'];
};

export type EngagedServiceBillingTypeUpfrontInput = {
  priceRule: FixedPriceRuleInput;
  quantity?: Scalars['Int']['input'];
  /** The tax rate for this service. */
  taxId: Scalars['ID']['input'];
};

/** Possible billing types for an Engaged Service. */
export type EngagedServiceBillingUnion =
  | EngagedServiceBillingEstimateRange
  | EngagedServiceBillingEstimateUnit
  | EngagedServiceBillingIncluded
  | EngagedServiceBillingOnCompletion
  | EngagedServiceBillingRecurring
  | EngagedServiceBillingUpfront;

export type EngagedServiceBillingUpfront = {
  __typename: 'EngagedServiceBillingUpfront';
  /** Legacy formatted description of price */
  priceForDisplay: Scalars['String']['output'];
  priceRule: BillingFixedPriceRule;
  quantity: Scalars['Int']['output'];
  tax: Tax;
};

export type EngagedServiceInput = {
  billing: EngagedServiceBillingTypeInput;
  description: Scalars['String']['input'];
  isOptional?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  position: Scalars['Int']['input'];
  quantity?: InputMaybe<Scalars['Int']['input']>;
  serviceId: Scalars['ID']['input'];
  /** Whether this service is exempt from tax. */
  taxExempt?: InputMaybe<Scalars['Boolean']['input']>;
  /** The tax assigned to this service. Not required if taxExempt. */
  taxId?: InputMaybe<Scalars['ID']['input']>;
};

/** Engagement (CPE Proposal) */
export type Engagement = {
  __typename: 'Engagement';
  /** The client acceptance page URL. */
  acceptUrl?: Maybe<Scalars['URL']['output']>;
  /** The client acceptance page short URL. */
  acceptUrlShort?: Maybe<Scalars['URL']['output']>;
  /** The acceptance token used to access the client portal. */
  acceptanceToken: Scalars['String']['output'];
  /** The time this engagement was accepted. */
  acceptedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Name of the person who accepted this engagement. */
  acceptedBy?: Maybe<Scalars['String']['output']>;
  /** Was this engagement accepted on behalf by the advisor? */
  acceptedByAccountant: Scalars['Boolean']['output'];
  /** IP Address of the person who accepted this engagement. */
  acceptedFromIpAddress?: Maybe<Scalars['IpAddress']['output']>;
  acceptedPaymentMethodTypes: Array<PaymentMethodType>;
  /** The child engagement, if this is a parent engagement. */
  activeChild?: Maybe<Engagement>;
  /** @deprecated Use billing_period instead. */
  billingFrequency: EngagementBillingFrequency;
  billingPeriod: EngagementBillingPeriod;
  /**
   * How many billing periods this engagement has in total.
   * @deprecated Use billings { totalCount }.
   */
  billingPeriodCount: Scalars['Int']['output'];
  /**
   * How many billing periods this engagement has remaining.
   * @deprecated use billings { remainingCount }
   */
  billingPeriodsRemaining: Scalars['Int']['output'];
  /** Billing counts for this Engagement. */
  billings: EngagementBillings;
  /** An attached PDF brochure (if any). */
  brochure?: Maybe<Filestack>;
  /** Can this engagement be duplicated? */
  canBeCopied: Scalars['Boolean']['output'];
  /** Does this engagement include invoiceable services? */
  canBeInvoiced: Scalars['Boolean']['output'];
  chargesToDate: Scalars['Decimal']['output'];
  client?: Maybe<Client>;
  /** The list of comments on this engagement. */
  comments: Array<EngagementComment>;
  /** The time this engagement was completed. */
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  completionCharges: Scalars['Decimal']['output'];
  contact?: Maybe<Contact>;
  /** Will this engagement continue billing indefinitely? */
  continuousBillingEnabled: Scalars['Boolean']['output'];
  /** The number of comments on this engagement. */
  conversationCount: Scalars['Int']['output'];
  /** The time this engagement was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Was this engagement created via the web connector? */
  createdViaWeb: Scalars['Boolean']['output'];
  /** The user who created this engagement. */
  creator?: Maybe<User>;
  /**
   * Are credit cards accepted for payment on this engagement?
   * @deprecated Use acceptedPaymentMethodTypes instead.
   */
  creditCardAccepted: Scalars['Boolean']['output'];
  /** @deprecated Use willDeployJobs instead. */
  deployJobsEnabled: Scalars['Boolean']['output'];
  /** The number of jobs left to deploy. */
  deployableJobsCount: Scalars['Int']['output'];
  /**
   * Are direct debits accepted for payment on this engagement?
   * @deprecated Use acceptedPaymentMethodTypes instead.
   */
  directDebitAccepted: Scalars['Boolean']['output'];
  /** Whether to display total service prices in the client portal. */
  displayTotals: Scalars['Boolean']['output'];
  /** True when displayTotals is using the practice-level setting instead of an engagement-level one. */
  displayTotalsComeFromPractice: Scalars['Boolean']['output'];
  /** Additional email addresses to which correspondence for this Engagement will be sent. */
  emailList: Array<Scalars['EmailAddress']['output']>;
  /** The date this engagement will end (unless continuously billed). */
  endsOn?: Maybe<Scalars['Date']['output']>;
  engagedJobs: Array<EngagedJob>;
  fiscalPeriodEnd: Scalars['Date']['output'];
  /** The Group Engagemnet this Engagement is part of (if any). */
  groupEngagement?: Maybe<GroupEngagement>;
  /** Has this engagement deployed workflow jobs? */
  hasDeployedJobs: Scalars['Boolean']['output'];
  /** Does this engagement contain estimate services? */
  hasEstimateServices: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** Can this engagement be adjusted? */
  isAdjustable: Scalars['Boolean']['output'];
  /** Is this proposal an estimate only? */
  isEstimateOnly: Scalars['Boolean']['output'];
  /** Does this engagement include pro-rata catchup? */
  isProrataEnabled: Scalars['Boolean']['output'];
  /** The number of jobs this engagement has deployed so far. */
  jobCount: Scalars['Int']['output'];
  /** The day of the month invoices from this engagement will be issued (if billed monthly). */
  monthlyInvoiceDay?: Maybe<Scalars['Int']['output']>;
  /** The name of this engagement. */
  name: Scalars['String']['output'];
  /** The email template. */
  newProposalEmailTemplate: NewProposalEmailTemplate;
  onceOffCharges: Scalars['Decimal']['output'];
  ongoingCharges: Scalars['Decimal']['output'];
  /** This engagement parent, if this is a child engagement. */
  parent?: Maybe<Engagement>;
  /** The attached payment method (if any). */
  paymentMethod?: Maybe<PaymentMethod>;
  /** Are payments accepted on this engagement? */
  paymentMethodAccepted: Scalars['Boolean']['output'];
  /** Is a payment method required to accept this engagement? */
  paymentMethodRequired: Scalars['Boolean']['output'];
  /**
   * Are payments supported by this practice?
   * @deprecated Use paymentSettings instead.
   */
  paymentMethodSupported: Scalars['Boolean']['output'];
  /** A personalized message to be shown in the client portal. */
  personalizedMessage?: Maybe<Scalars['Html']['output']>;
  postAcceptanceVideoUrl?: Maybe<Scalars['URL']['output']>;
  preAcceptanceVideoUrl?: Maybe<Scalars['URL']['output']>;
  /**
   * Number of months rolled up as prorata.
   * @deprecated Use billings { missedCount }.
   */
  prorataMonths: Scalars['Int']['output'];
  /** @deprecated Prefer id unless legacy code requires this value. */
  referenceNumber: Scalars['ID']['output'];
  /** @deprecated Use paymentMethodRequired */
  requiresPaymentMethod: Scalars['Boolean']['output'];
  /** The user who sent this engagement. */
  sender?: Maybe<User>;
  /** The time this engagement was accepted. */
  sentAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether to display individual service prices on the client portal. */
  showServicePrices: Scalars['Boolean']['output'];
  /** @deprecated Use id. */
  slug: Scalars['ID']['output'];
  /** The date this engagement will start. */
  startsOn: Scalars['Date']['output'];
  state: EngagementState;
  /** The tags assigned to this engagement. */
  tagList: Array<Scalars['String']['output']>;
  /** The terms template. */
  termsTemplate: TermsTemplate;
  totalValue: Scalars['Decimal']['output'];
  useNewAcceptPage: Scalars['Boolean']['output'];
  /** @deprecated Use id. */
  uuid: Scalars['ID']['output'];
  willBillContinuously: Scalars['Boolean']['output'];
  /** Whether this engagement will deploy invoices to a connected ledger. */
  willDeployInvoices: Scalars['Boolean']['output'];
  /** Will this engagement deploy workflow jobs? */
  willDeployJobs: Scalars['Boolean']['output'];
  /** Whether this engagement will issue any further invoices (formally can_invoice_services). */
  willIssueInvoices: Scalars['Boolean']['output'];
};

/** Autogenerated input type of EngagementAcceptOnBehalf */
export type EngagementAcceptOnBehalfInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of Engagement to accept. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementAcceptOnBehalf. */
export type EngagementAcceptOnBehalfPayload = {
  __typename: 'EngagementAcceptOnBehalfPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement: Engagement;
};

/** Autogenerated input type of EngagementArchive */
export type EngagementArchiveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of Engagement to archive. */
  id: Scalars['ID']['input'];
  jobDeletionStrategy?: InputMaybe<EngagementJobDeletionStrategy>;
};

/** Autogenerated return type of EngagementArchive. */
export type EngagementArchivePayload = {
  __typename: 'EngagementArchivePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement: Engagement;
};

export enum EngagementBillingFrequency {
  MONTHLY = 'MONTHLY',
  WEEKLY = 'WEEKLY',
}

export enum EngagementBillingPeriod {
  MONTH = 'MONTH',
  WEEK = 'WEEK',
}

/** Provides billing counts for a given Engagement. */
export type EngagementBillings = {
  __typename: 'EngagementBillings';
  /** Total number of missed billing period (aka prorata). */
  missedCount: Scalars['Int']['output'];
  /** Total number of unbilled billing periods. */
  remainingCount: Scalars['Int']['output'];
  /** Total number of billing periods. */
  totalCount: Scalars['Int']['output'];
};

export type EngagementComment = {
  __typename: 'EngagementComment';
  createdAt: Scalars['DateTime']['output'];
  creator?: Maybe<User>;
  id: Scalars['ID']['output'];
  text: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

/** Autogenerated input type of EngagementComplete */
export type EngagementCompleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of Engagement to complete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementComplete. */
export type EngagementCompletePayload = {
  __typename: 'EngagementCompletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement: Engagement;
};

/** The connection type for Engagement. */
export type EngagementConnection = {
  __typename: 'EngagementConnection';
  /** A list of edges. */
  edges: Array<EngagementEdge>;
  /** A list of nodes. */
  nodes: Array<Engagement>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of EngagementCreate */
export type EngagementCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  engagement: EngagementInput;
};

/** Autogenerated return type of EngagementCreate. */
export type EngagementCreatePayload = {
  __typename: 'EngagementCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement: Engagement;
};

/** Autogenerated input type of EngagementDeployJobsSettingUpdate */
export type EngagementDeployJobsSettingUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Enable/Disable deploy jobs flag */
  enabled: Scalars['Boolean']['input'];
  /** The UUID of the Engagement */
  uuid: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementDeployJobsSettingUpdate. */
export type EngagementDeployJobsSettingUpdatePayload = {
  __typename: 'EngagementDeployJobsSettingUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement?: Maybe<Engagement>;
  userErrors?: Maybe<Array<UserError>>;
};

/** Autogenerated input type of EngagementDisableContinuousBilling */
export type EngagementDisableContinuousBillingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of Engagement to disable continuous billing for. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementDisableContinuousBilling. */
export type EngagementDisableContinuousBillingPayload = {
  __typename: 'EngagementDisableContinuousBillingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement: Engagement;
};

/** An edge in a connection. */
export type EngagementEdge = {
  __typename: 'EngagementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Engagement;
};

/** Autogenerated input type of EngagementEnableContinuousBilling */
export type EngagementEnableContinuousBillingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of Engagement to enable continuous billing for. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementEnableContinuousBilling. */
export type EngagementEnableContinuousBillingPayload = {
  __typename: 'EngagementEnableContinuousBillingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement: Engagement;
};

export type EngagementInput = {
  /** The period of time between each billing cycle. */
  billingPeriod: EngagementBillingPeriod;
  /** An attached PDF brochure to be shown in the client portal. */
  brochure?: InputMaybe<FilestackInput>;
  clientId: Scalars['ID']['input'];
  contactId: Scalars['ID']['input'];
  /** Should this engagement be billed continuously? */
  continuousBillingEnabled: Scalars['Boolean']['input'];
  /** Allow the client to provide a credit card for payments? */
  creditCardAccepted?: InputMaybe<Scalars['Boolean']['input']>;
  /** Deploy jobs to the workflow integration (if any)? */
  deployJobs?: InputMaybe<Scalars['Boolean']['input']>;
  /** Allow the client to provide a bank account for payments? */
  directDebitAccepted?: InputMaybe<Scalars['Boolean']['input']>;
  /** Should clients see the total service amounts? */
  displayTotals?: InputMaybe<Scalars['Boolean']['input']>;
  /** The email addresses to which engagement correspondence is sent. */
  email?: InputMaybe<Array<Scalars['EmailAddress']['input']>>;
  /** The date the engagement ends (unless billed continuously). */
  endsOn: Scalars['Date']['input'];
  engagedJobs: Array<EngagedJobInput>;
  fiscalPeriodEnd: Scalars['Date']['input'];
  /** The day of the month the invoice is sent (if billed monthly). */
  monthlyInvoiceDay?: InputMaybe<Scalars['Int']['input']>;
  name?: Scalars['String']['input'];
  newProposalEmailTemplateId: Scalars['ID']['input'];
  /** Require the client to provide a payment method? */
  paymentMethodRequired?: InputMaybe<Scalars['Boolean']['input']>;
  /** A personalized message to be shown in the client portal. */
  personalizedMessage?: InputMaybe<Scalars['String']['input']>;
  /** The 'Next Steps' video. */
  postAcceptanceVideoUrl?: InputMaybe<Scalars['URL']['input']>;
  /** The 'Intro' video. */
  preAcceptanceVideoUrl?: InputMaybe<Scalars['URL']['input']>;
  /** The User who the engagement email will be sent from. */
  senderId?: InputMaybe<Scalars['ID']['input']>;
  /** Whether to show service prices in the client portal. */
  showServicePrices?: InputMaybe<Scalars['Boolean']['input']>;
  /** The date the engagement starts. */
  startsAt: Scalars['Date']['input'];
  termsTemplateId: Scalars['ID']['input'];
  /** Use the new acceptance page? */
  useNewAcceptPage?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum EngagementJobDeletionStrategy {
  /** Delete active jobs. */
  COMPLETE = 'COMPLETE',
  /** Mark active jobs as completed. */
  DELETE = 'DELETE',
}

/** Autogenerated input type of EngagementJobsSend */
export type EngagementJobsSendInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The UUID of the Engagement */
  uuid: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementJobsSend. */
export type EngagementJobsSendPayload = {
  __typename: 'EngagementJobsSendPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement?: Maybe<Engagement>;
  userErrors?: Maybe<Array<UserError>>;
};

export enum EngagementLetterState {
  DELETED = 'DELETED',
  INTEGRATED = 'INTEGRATED',
  PENDING = 'PENDING',
}

export type EngagementLetterTemplate = PracticeTemplate & {
  __typename: 'EngagementLetterTemplate';
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  isDefault: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  slug: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

/** Autogenerated input type of EngagementMarkAsLost */
export type EngagementMarkAsLostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of Engagement to mark as lost. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementMarkAsLost. */
export type EngagementMarkAsLostPayload = {
  __typename: 'EngagementMarkAsLostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement: Engagement;
};

/** Autogenerated input type of EngagementMarkForReview */
export type EngagementMarkForReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of Engagement to mark for review. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementMarkForReview. */
export type EngagementMarkForReviewPayload = {
  __typename: 'EngagementMarkForReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement: Engagement;
};

/** Autogenerated input type of EngagementMoveToAwaitingAcceptance */
export type EngagementMoveToAwaitingAcceptanceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of Engagement to move to awaiting acceptance. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementMoveToAwaitingAcceptance. */
export type EngagementMoveToAwaitingAcceptancePayload = {
  __typename: 'EngagementMoveToAwaitingAcceptancePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement: Engagement;
};

/** Autogenerated input type of EngagementMoveToDraft */
export type EngagementMoveToDraftInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of Engagement to move to draft. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementMoveToDraft. */
export type EngagementMoveToDraftPayload = {
  __typename: 'EngagementMoveToDraftPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement: Engagement;
};

/** Autogenerated input type of EngagementNameChange */
export type EngagementNameChangeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The UUID of the Engagement */
  id: Scalars['ID']['input'];
  /** New name of the Engagement */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of EngagementNameChange. */
export type EngagementNameChangePayload = {
  __typename: 'EngagementNameChangePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement?: Maybe<Engagement>;
  userErrors?: Maybe<Array<UserError>>;
};

/** Autogenerated input type of EngagementReactivate */
export type EngagementReactivateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of Engagement to reactivate. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementReactivate. */
export type EngagementReactivatePayload = {
  __typename: 'EngagementReactivatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement: Engagement;
};

/** Autogenerated input type of EngagementRevoke */
export type EngagementRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of Engagement to revoke. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementRevoke. */
export type EngagementRevokePayload = {
  __typename: 'EngagementRevokePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement: Engagement;
};

/** Autogenerated input type of EngagementSendToClient */
export type EngagementSendToClientInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of Engagement to send. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementSendToClient. */
export type EngagementSendToClientPayload = {
  __typename: 'EngagementSendToClientPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagement: Engagement;
};

export enum EngagementState {
  ACTIVE = 'ACTIVE',
  COMPLETED = 'COMPLETED',
  DELETED = 'DELETED',
  DRAFT = 'DRAFT',
  LOST = 'LOST',
  QUEUED = 'QUEUED',
  SENT = 'SENT',
}

export enum Environment {
  /** Development environment */
  DEVELOPMENT = 'DEVELOPMENT',
  /** Production environment */
  PRODUCTION = 'PRODUCTION',
  /** Staging environment */
  STAGING = 'STAGING',
  /** Test environment */
  TEST = 'TEST',
}

/** Input type for estimate quantity rule. */
export type EstimateQuantityRuleInput = {
  /** Quantity amount */
  amount: Scalars['Decimal']['input'];
};

export type ExitSurvey = {
  __typename: 'ExitSurvey';
  /** Date user left ignition and submitted survey */
  createdAt: Scalars['DateTime']['output'];
  /** Any feedback as to reason for leaving */
  feedback?: Maybe<Scalars['String']['output']>;
  /** Any other payments tool that user will be using */
  paymentAlternative?: Maybe<Scalars['String']['output']>;
  practiceId: Scalars['ID']['output'];
  /** Any other proposal tool that user will be using */
  proposalAlternative?: Maybe<Scalars['String']['output']>;
  /** Reason for leaving ignition */
  reason?: Maybe<Scalars['String']['output']>;
  /** On a scale of 1-10 how likely is an user to come back */
  returnLikelihood?: Maybe<Scalars['Int']['output']>;
  userId: Scalars['ID']['output'];
  uuid: Scalars['ID']['output'];
};

/** Input fields for an exit survey */
export type ExitSurveyInputType = {
  /** Any feedback as to reason for leaving */
  feedback: Scalars['String']['input'];
  /** Any other payments tool that user will be using */
  paymentAlternative?: InputMaybe<Scalars['String']['input']>;
  /** Any other proposal tool that user will be using */
  proposalAlternative?: InputMaybe<Scalars['String']['input']>;
  /** Reason for leaving */
  reason: Scalars['String']['input'];
  /** On a scale of 1-10 how likely is an user to come back */
  returnLikelihood?: InputMaybe<Scalars['Int']['input']>;
};

export type Export = {
  __typename: 'Export';
  id: Scalars['ID']['output'];
  user: User;
};

/** Autogenerated input type of ExportPayments */
export type ExportPaymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ExportPayments. */
export type ExportPaymentsPayload = {
  __typename: 'ExportPaymentsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  export: Export;
};

/** Autogenerated input type of ExportProposals */
export type ExportProposalsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An array of additional string search filters */
  search?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Primary search filter */
  state?: InputMaybe<EngagementState>;
};

/** Autogenerated return type of ExportProposals. */
export type ExportProposalsPayload = {
  __typename: 'ExportProposalsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  export: Export;
};

/** Autogenerated input type of ExportServices */
export type ExportServicesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ExportServices. */
export type ExportServicesPayload = {
  __typename: 'ExportServicesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  export: Export;
};

export type Feature = {
  __typename: 'Feature';
  available: Scalars['Boolean']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

/** The connection type for Feature. */
export type FeatureConnection = {
  __typename: 'FeatureConnection';
  /** Maximum number of active users allowed on a practice */
  activeUsersLimit?: Maybe<Scalars['Int']['output']>;
  /** Describes how long it takes to confirm a bank account */
  bankAccountDescription?: Maybe<Scalars['Html']['output']>;
  /** Whether we can add more users based on current plan */
  canAddMoreUsers: Scalars['Boolean']['output'];
  /** A list of edges. */
  edges: Array<FeatureEdge>;
  /** Whether we can add more signatories to a proposal based on current plan */
  isProposalSignatoriesLimitUpgradeable: Scalars['Boolean']['output'];
  /** A list of nodes. */
  nodes: Array<Feature>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Proposal multiple options are enabled */
  proposalOptionsEnabled: Scalars['Boolean']['output'];
  /** Maximum number of recipients allowed on a proposal */
  proposalRecipientsLimit?: Maybe<Scalars['Int']['output']>;
  /** Maximum number of signatories allowed on a proposal */
  proposalSignatoriesLimit: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type FeatureEdge = {
  __typename: 'FeatureEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Feature;
};

export type FeatureFlag = {
  __typename: 'FeatureFlag';
  id: Scalars['String']['output'];
  isEnabled: Scalars['Boolean']['output'];
};

export enum FeeStructure {
  /** as fixed fee project work */
  FIXED_FEE_PROJECT_WORK = 'FIXED_FEE_PROJECT_WORK',
  /** hourly */
  HOURLY = 'HOURLY',
  /** hourly but switching to fixed fees */
  HOURLY_BUT_SWITCHING = 'HOURLY_BUT_SWITCHING',
  /** as recurring fixed fees */
  RECURRING_FIXED_FEES = 'RECURRING_FIXED_FEES',
}

export type Filestack = {
  __typename: 'Filestack';
  /** The name of the file that was uploaded. */
  filename: Scalars['String']['output'];
  /** The Filestack file handle. */
  handle: Scalars['ID']['output'];
  /** The mimetype of the file, if available. */
  mimetype?: Maybe<Scalars['String']['output']>;
  /** The filename of the source file when uploaded. */
  originalPath: Scalars['String']['output'];
  /** The size of the file in bytes, if available. */
  size: Scalars['Int']['output'];
  /** The source the file was uploaded from. This could be 'local_file_system', 'instagram', etc. */
  source: Scalars['String']['output'];
  /** The status of the upload. */
  status?: Maybe<Scalars['String']['output']>;
  /** This string value is a UUID that can be used to track files in callbacks. */
  uploadId: Scalars['String']['output'];
  /** The Filestack URL that points to the uploaded file. */
  url: Scalars['URL']['output'];
};

export type FilestackInput = {
  filename: Scalars['String']['input'];
  handle: Scalars['ID']['input'];
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalPath: Scalars['String']['input'];
  size: Scalars['Int']['input'];
  source: Scalars['String']['input'];
  status?: InputMaybe<Scalars['String']['input']>;
  uploadId: Scalars['String']['input'];
  url: Scalars['URL']['input'];
};

/** Input type for fixed price rule. */
export type FixedPriceRuleInput = {
  /** Price amount */
  amount: MoneyInput;
};

export enum FrequencyTypeEnum {
  DAILY = 'DAILY',
  MONTHLY = 'MONTHLY',
  WEEKLY = 'WEEKLY',
  YEARLY = 'YEARLY',
}

/** Classic Proposal Editor (CPE) Group Proposal */
export type GroupEngagement = {
  __typename: 'GroupEngagement';
  /** The attached client group (if any). */
  clientGroup?: Maybe<ClientGroup>;
  /** The list of engagements in this group. */
  engagements: Array<Engagement>;
  /** The id of the group engagement. */
  id: Scalars['ID']['output'];
};

/** Deprecated - use the Html type instead. */
export type HtmlText = {
  __typename: 'HtmlText';
  /** @deprecated Use the Html type instead */
  escaped: Scalars['String']['output'];
  /** @deprecated Use the Html type instead */
  raw: Scalars['String']['output'];
};

/** Type for filtering AppServices */
export type IgnitionAppServiceFilterType = {
  /** If true, exclude AppServices mapped to a Service */
  excludeMapped?: InputMaybe<Scalars['Boolean']['input']>;
  /** Return AppServices with names containing this value */
  nameCont?: InputMaybe<Scalars['String']['input']>;
  /** If true, only include AppServices with conversion errors */
  onlyWithConversionErrors?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * An AppService is a counterpart to a Service that exists in an App's domain.
 * AppService can be linked ("mapped") to Services, and can be used to create
 * Services. For example, a Item in QuickBooks or in Xero could be the underlying
 * record behind an AppService.
 */
export type IgnitionAppServiceType = {
  __typename: 'IgnitionAppServiceType';
  app: App;
  /** List of jobs associated with the item */
  asyncJobs?: Maybe<Array<AsyncJob>>;
  description?: Maybe<Scalars['String']['output']>;
  /** An identifier used by the App this AppService belongs to */
  externalId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  price?: Maybe<Money>;
};

/** An image uploaded via Base64 encoding */
export type ImageInput = {
  data: Scalars['String']['input'];
  filename: Scalars['String']['input'];
};

/** Client import */
export type ImportType = {
  __typename: 'ImportType';
  id: Scalars['ID']['output'];
};

/** Input type for minimum price rule. */
export type IncludedPriceRuleInput = {
  /** ISO currency code */
  currency: Scalars['String']['input'];
};

export enum Industry {
  /** accounting */
  ACCOUNTING = 'ACCOUNTING',
  /** bookkeeping */
  BOOKKEEPING = 'BOOKKEEPING',
  /** coaching */
  COACHING = 'COACHING',
  /** consulting */
  CONSULTING = 'CONSULTING',
  /** digital agency */
  DIGITAL_AGENCY = 'DIGITAL_AGENCY',
  /** financial services */
  FINANCIAL_SERVICES = 'FINANCIAL_SERVICES',
  /** IT solutions */
  IT_SOLUTIONS = 'IT_SOLUTIONS',
  /** law */
  LAW = 'LAW',
  /** other */
  OTHER = 'OTHER',
  /** software */
  SOFTWARE = 'SOFTWARE',
}

export type IntroMessageTemplate = PracticeTemplate & {
  __typename: 'IntroMessageTemplate';
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  isDefault: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  slug: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for IntroMessageTemplate. */
export type IntroMessageTemplateConnection = {
  __typename: 'IntroMessageTemplateConnection';
  /** A list of edges. */
  edges: Array<IntroMessageTemplateEdge>;
  /** A list of nodes. */
  nodes: Array<IntroMessageTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of IntroMessageTemplateCreate */
export type IntroMessageTemplateCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  template: TemplateInput;
};

/** Autogenerated return type of IntroMessageTemplateCreate. */
export type IntroMessageTemplateCreatePayload = {
  __typename: 'IntroMessageTemplateCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<IntroMessageTemplate>;
  templates?: Maybe<Templates>;
};

/** Autogenerated input type of IntroMessageTemplateDelete */
export type IntroMessageTemplateDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug or UUID of intro message template */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of IntroMessageTemplateDelete. */
export type IntroMessageTemplateDeletePayload = {
  __typename: 'IntroMessageTemplateDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  templates?: Maybe<Templates>;
};

/** An edge in a connection. */
export type IntroMessageTemplateEdge = {
  __typename: 'IntroMessageTemplateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: IntroMessageTemplate;
};

/** Autogenerated input type of IntroMessageTemplateSetDefault */
export type IntroMessageTemplateSetDefaultInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of intro message template */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of IntroMessageTemplateSetDefault. */
export type IntroMessageTemplateSetDefaultPayload = {
  __typename: 'IntroMessageTemplateSetDefaultPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
  templates?: Maybe<Templates>;
};

/** Autogenerated input type of IntroMessageTemplateUpdate */
export type IntroMessageTemplateUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug or UUID of intro message template */
  id: Scalars['ID']['input'];
  template: TemplateInput;
};

/** Autogenerated return type of IntroMessageTemplateUpdate. */
export type IntroMessageTemplateUpdatePayload = {
  __typename: 'IntroMessageTemplateUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<IntroMessageTemplate>;
  templates?: Maybe<Templates>;
};

/** Input fields for an invitation */
export type InvitationInputType = {
  /** The user's email address */
  email: Scalars['EmailAddress']['input'];
  /** The user's full name */
  fullName: Scalars['String']['input'];
  /** ACCOUNTANT or PRACTICEADMIN */
  role: UserRoleEnum;
};

export type InvitationType = {
  __typename: 'InvitationType';
  /** The invitation's email address */
  email: Scalars['EmailAddress']['output'];
  /** Nature of invitation error (if it exists) */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** Returned user (if invitation is successful) */
  user?: Maybe<User>;
};

export type InvoiceDeploySettings = {
  __typename: 'InvoiceDeploySettings';
  /** The due date of a manual invoice will be this many days after issuing. */
  defaultInvoiceTerms: Scalars['Int']['output'];
  /** The default ledger item to apply to invoice line items, unless they have an explicit mapping. */
  defaultLedgerItemId?: Maybe<Scalars['ID']['output']>;
  /** The default setting for new clients for whether to deploy invoices automatically after being issued. */
  deployInvoices: Scalars['Boolean']['output'];
  /** Whether the InvoiceDeploy settings as configured are valid. */
  isValid: Scalars['Boolean']['output'];
  /** Whether to include the full service description on each invoice item. */
  longItemDescription: Scalars['Boolean']['output'];
  /** The due date of an automatic invoice will be this many days after issuing. */
  recurringInvoiceTerms: Scalars['Int']['output'];
};

export type InvoiceDeploySettingsInput = {
  defaultInvoiceTerms: Scalars['Int']['input'];
  defaultLedgerItemId: Scalars['ID']['input'];
  deployInvoices: Scalars['Boolean']['input'];
  longItemDescription: Scalars['Boolean']['input'];
  recurringInvoiceTerms: Scalars['Int']['input'];
};

/** Autogenerated input type of InvoiceDeploySettingsUpdate */
export type InvoiceDeploySettingsUpdateInput = {
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  invoiceDeploySettings: InvoiceDeploySettingsInput;
};

/** Autogenerated return type of InvoiceDeploySettingsUpdate. */
export type InvoiceDeploySettingsUpdatePayload = {
  __typename: 'InvoiceDeploySettingsUpdatePayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export type InvoiceNotificationSettings = {
  __typename: 'InvoiceNotificationSettings';
  sendNotifications: Scalars['Boolean']['output'];
  tenantId: Scalars['ID']['output'];
  useDefaultSettings: Scalars['Boolean']['output'];
};

export type Ipm = {
  __typename: 'Ipm';
  apiKey?: Maybe<Scalars['String']['output']>;
  lastSynced?: Maybe<Scalars['DateTime']['output']>;
  services: Array<IpmService>;
  status: IpmStatus;
  workTemplateMappings: Array<IpmWorkTemplateMapping>;
  workTemplates: Array<IpmWorkTemplate>;
};

/** Autogenerated input type of IpmAuthorise */
export type IpmAuthoriseInput = {
  /** Ipm api key */
  apiKey: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of IpmAuthorise. */
export type IpmAuthorisePayload = {
  __typename: 'IpmAuthorisePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  ipm?: Maybe<Ipm>;
};

/** Autogenerated input type of IpmDisconnect */
export type IpmDisconnectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of IpmDisconnect. */
export type IpmDisconnectPayload = {
  __typename: 'IpmDisconnectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  ipm?: Maybe<Ipm>;
};

/** Autogenerated input type of IpmEnable */
export type IpmEnableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of IpmEnable. */
export type IpmEnablePayload = {
  __typename: 'IpmEnablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  ipm?: Maybe<Ipm>;
};

export type IpmService = {
  __typename: 'IpmService';
  id: Scalars['ID']['output'];
  subtitle?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
};

export enum IpmStatus {
  AUTHORISED = 'AUTHORISED',
  CONFIRMED = 'CONFIRMED',
  DISCONNECTED = 'DISCONNECTED',
  ENABLED = 'ENABLED',
  UNAUTHORISED = 'UNAUTHORISED',
}

export type IpmWorkTemplate = {
  __typename: 'IpmWorkTemplate';
  id: Scalars['ID']['output'];
  title: Scalars['String']['output'];
};

export type IpmWorkTemplateMapping = {
  __typename: 'IpmWorkTemplateMapping';
  serviceId: Scalars['ID']['output'];
  workTemplateId: Scalars['ID']['output'];
};

export type IpmWorkTemplateMappingInputType = {
  serviceId: Scalars['ID']['input'];
  workTemplateId: Scalars['ID']['input'];
};

/** Autogenerated input type of IpmWorkTemplateMappingsConfirm */
export type IpmWorkTemplateMappingsConfirmInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  mappings: Array<IpmWorkTemplateMappingInputType>;
};

/** Autogenerated return type of IpmWorkTemplateMappingsConfirm. */
export type IpmWorkTemplateMappingsConfirmPayload = {
  __typename: 'IpmWorkTemplateMappingsConfirmPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  ipm?: Maybe<Ipm>;
};

/** Autogenerated input type of IpmWorkTemplateMappingsUpdate */
export type IpmWorkTemplateMappingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  mappings: Array<IpmWorkTemplateMappingInputType>;
};

/** Autogenerated return type of IpmWorkTemplateMappingsUpdate. */
export type IpmWorkTemplateMappingsUpdatePayload = {
  __typename: 'IpmWorkTemplateMappingsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  ipm?: Maybe<Ipm>;
};

/** Autogenerated input type of IpmWorkTemplatesSyncAll */
export type IpmWorkTemplatesSyncAllInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of IpmWorkTemplatesSyncAll. */
export type IpmWorkTemplatesSyncAllPayload = {
  __typename: 'IpmWorkTemplatesSyncAllPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  ipm?: Maybe<Ipm>;
};

export type Karbon = {
  __typename: 'Karbon';
  apiKey?: Maybe<Scalars['String']['output']>;
  services: Array<KarbonService>;
  status: KarbonStatus;
  workTemplateMappings: Array<KarbonWorkTemplateMapping>;
  workTemplates: Array<KarbonWorkTemplate>;
};

/** Autogenerated input type of KarbonAuthorise */
export type KarbonAuthoriseInput = {
  /** Karbon integration api key */
  apiKey: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of KarbonAuthorise. */
export type KarbonAuthorisePayload = {
  __typename: 'KarbonAuthorisePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  karbon?: Maybe<Karbon>;
  userErrors?: Maybe<Array<UserError>>;
};

/** Autogenerated input type of KarbonDisconnect */
export type KarbonDisconnectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of KarbonDisconnect. */
export type KarbonDisconnectPayload = {
  __typename: 'KarbonDisconnectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  karbon?: Maybe<Karbon>;
};

/** Autogenerated input type of KarbonEnable */
export type KarbonEnableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of KarbonEnable. */
export type KarbonEnablePayload = {
  __typename: 'KarbonEnablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  karbon?: Maybe<Karbon>;
};

export type KarbonService = {
  __typename: 'KarbonService';
  id: Scalars['ID']['output'];
  subtitle?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
};

export enum KarbonStatus {
  AUTHORISED = 'AUTHORISED',
  CONFIRMED = 'CONFIRMED',
  DISCONNECTED = 'DISCONNECTED',
  ENABLED = 'ENABLED',
  UNAUTHORISED = 'UNAUTHORISED',
}

export type KarbonWorkTemplate = {
  __typename: 'KarbonWorkTemplate';
  title: Scalars['String']['output'];
  uuid: Scalars['ID']['output'];
};

export type KarbonWorkTemplateMapping = {
  __typename: 'KarbonWorkTemplateMapping';
  serviceId: Scalars['ID']['output'];
  workTemplateId: Scalars['ID']['output'];
};

/** Autogenerated input type of KarbonWorkTemplateMappingsConfirm */
export type KarbonWorkTemplateMappingsConfirmInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  mappings: Array<WorkTemplateMappingInput>;
};

/** Autogenerated return type of KarbonWorkTemplateMappingsConfirm. */
export type KarbonWorkTemplateMappingsConfirmPayload = {
  __typename: 'KarbonWorkTemplateMappingsConfirmPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  karbon?: Maybe<Karbon>;
};

/** Autogenerated input type of KarbonWorkTemplateMappingsUpdate */
export type KarbonWorkTemplateMappingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  mappings: Array<WorkTemplateMappingInput>;
};

/** Autogenerated return type of KarbonWorkTemplateMappingsUpdate. */
export type KarbonWorkTemplateMappingsUpdatePayload = {
  __typename: 'KarbonWorkTemplateMappingsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  karbon?: Maybe<Karbon>;
};

/** Autogenerated input type of KarbonWorkTemplatesSyncAll */
export type KarbonWorkTemplatesSyncAllInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of KarbonWorkTemplatesSyncAll. */
export type KarbonWorkTemplatesSyncAllPayload = {
  __typename: 'KarbonWorkTemplatesSyncAllPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  karbon?: Maybe<Karbon>;
};

export enum Ledger {
  /** a different cloud ledger */
  CLOUD_LEDGER = 'CLOUD_LEDGER',
  /** a desktop ledger */
  DESKTOP_LEDGER = 'DESKTOP_LEDGER',
  /** MYOB Desktop */
  MYOB_DESKTOP = 'MYOB_DESKTOP',
  /** MYOB Online */
  MYOB_ONLINE = 'MYOB_ONLINE',
  /** QuickBooks Online */
  QUICKBOOKS_ONLINE = 'QUICKBOOKS_ONLINE',
  /** Xero */
  XERO = 'XERO',
}

/** Capabilities Ledger Item. */
export type LedgerItem = {
  __typename: 'LedgerItem';
  /** Ledger app */
  app: App;
  /** Ledger Items with the same grouping should be displayed together */
  grouping?: Maybe<Scalars['String']['output']>;
  /** Slug of ledger item */
  id: Scalars['ID']['output'];
  /** Ledger Item Name */
  name: Scalars['String']['output'];
};

/** The connection type for LedgerItem. */
export type LedgerItemConnection = {
  __typename: 'LedgerItemConnection';
  /** A list of edges. */
  edges: Array<LedgerItemEdge>;
  /** A list of nodes. */
  nodes: Array<LedgerItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type LedgerItemEdge = {
  __typename: 'LedgerItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: LedgerItem;
};

/** Input type for Capabilities Ledger Item. */
export type LedgerItemInput = {
  /** Ledger app (Xero or QuickBooks) */
  appName: Scalars['String']['input'];
  /** Slug of ledger item. */
  ledgerItemId: Scalars['ID']['input'];
};

export type MaturityIndexInput = {
  clientsCount: ClientsCount;
  feeStructure?: InputMaybe<FeeStructure>;
  industry: Industry;
  ledger: Ledger;
  paymentCollectionTool?: InputMaybe<MaturityIndexPaymentCollectionToolEnum>;
  paymentCollectionToolOther?: InputMaybe<Scalars['String']['input']>;
  projectedPercentGrowthForThisYear?: InputMaybe<Scalars['BigInt']['input']>;
  revenueBracket?: InputMaybe<MaturityIndexRevenueBracketValueEnum>;
  revenueLastYear?: InputMaybe<Scalars['BigInt']['input']>;
  staffCount?: InputMaybe<StaffCount>;
  workflowTool?: InputMaybe<MaturityIndexWorkflowToolEnum>;
  workflowToolOther?: InputMaybe<Scalars['String']['input']>;
};

export enum MaturityIndexPaymentCollectionToolEnum {
  /** authorize.net */
  AUTHORIZE_NET = 'AUTHORIZE_NET',
  /** bill.com (US) */
  BILL_COM_US = 'BILL_COM_US',
  /** Bpay (AU) */
  BPAY_AU = 'BPAY_AU',
  /** Canopy Tax */
  CANOPY_TAX = 'CANOPY_TAX',
  /** Clients pay invoices with bank transfer/direct deposit */
  CLIENTS_PAY_INVOICES_WITH_BANK_TRANSFER_DIRECT_DEPOSIT = 'CLIENTS_PAY_INVOICES_WITH_BANK_TRANSFER_DIRECT_DEPOSIT',
  /** Clients pay invoices with cheque or cash */
  CLIENTS_PAY_INVOICES_WITH_CHEQUE_OR_CASH = 'CLIENTS_PAY_INVOICES_WITH_CHEQUE_OR_CASH',
  /** Client sets up recurring standing order/eft */
  CLIENT_SETS_UP_RECURRING_STANDING_ORDER_EFT = 'CLIENT_SETS_UP_RECURRING_STANDING_ORDER_EFT',
  /** EziDebit/e-way (AU) */
  EZIDEBIT_E_WAY_AU = 'EZIDEBIT_E_WAY_AU',
  /** GoCardless (Direct) */
  GOCARDLESS_DIRECT = 'GOCARDLESS_DIRECT',
  /** Interac eTransfer (CA) */
  INTERAC_ETRANSFER_CA = 'INTERAC_ETRANSFER_CA',
  /** London & Zurich */
  LONDON_ZURICH = 'LONDON_ZURICH',
  /** Merchant account via my bank */
  MERCHANT_ACCOUNT_VIA_MY_BANK = 'MERCHANT_ACCOUNT_VIA_MY_BANK',
  /** Other */
  OTHER = 'OTHER',
  /** Paypal */
  PAYPAL = 'PAYPAL',
  /** Point of Sale/Terminal */
  POINT_OF_SALE_TERMINAL = 'POINT_OF_SALE_TERMINAL',
  /** I use/I intend to use Ignition Payments */
  PRACTICE_IGNITION_PAYMENTS = 'PRACTICE_IGNITION_PAYMENTS',
  /** QuickBooks Payments */
  QUICKBOOKS_PAYMENTS = 'QUICKBOOKS_PAYMENTS',
  /** Rotessa (CA) */
  ROTESSA_CA = 'ROTESSA_CA',
  /** Square Online Payments */
  SQUARE_ONLINE_PAYMENTS = 'SQUARE_ONLINE_PAYMENTS',
  /** Square Terminal */
  SQUARE_TERMINAL = 'SQUARE_TERMINAL',
  /** Stripe (Direct) */
  STRIPE_DIRECT = 'STRIPE_DIRECT',
  /** Xero Online payments w/ Gocardless */
  XERO_ONLINE_PAYMENTS_W_GOCARDLESS = 'XERO_ONLINE_PAYMENTS_W_GOCARDLESS',
  /** Xero Online payments w/ Stripe */
  XERO_ONLINE_PAYMENTS_W_STRIPE = 'XERO_ONLINE_PAYMENTS_W_STRIPE',
}

export enum MaturityIndexRevenueBracketValueEnum {
  HIGH = 'HIGH',
  HIGHEST = 'HIGHEST',
  HIGH_MID = 'HIGH_MID',
  LOW = 'LOW',
  LOWEST = 'LOWEST',
  LOW_MID = 'LOW_MID',
}

export enum MaturityIndexWorkflowToolEnum {
  /** AccountancyManager (UK) */
  ACCOUNTANCYMANAGER_UK = 'ACCOUNTANCYMANAGER_UK',
  /** Aero workflow */
  AERO_WORKFLOW = 'AERO_WORKFLOW',
  /** Airtable */
  AIRTABLE = 'AIRTABLE',
  /** APS / Reckon */
  APS_RECKON = 'APS_RECKON',
  /** Asana */
  ASANA = 'ASANA',
  /** Capium */
  CAPIUM = 'CAPIUM',
  /** CCH axcess */
  CCH_AXCESS = 'CCH_AXCESS',
  /** CCH iFirm */
  CCH_IFIRM = 'CCH_IFIRM',
  /** Clickup */
  CLICKUP = 'CLICKUP',
  /** Digita */
  DIGITA = 'DIGITA',
  /** Google sheets */
  GOOGLE_SHEETS = 'GOOGLE_SHEETS',
  /** HubSpot */
  HUBSPOT = 'HUBSPOT',
  /** Intuit Practice Manager */
  INTUIT_PRACTICE_MANAGER = 'INTUIT_PRACTICE_MANAGER',
  /** In-house built solution */
  IN_HOUSE_BUILT_SOLUTION = 'IN_HOUSE_BUILT_SOLUTION',
  /** IRIS */
  IRIS = 'IRIS',
  /** IRIS Practice Engine */
  IRIS_PRACTICE_ENGINE = 'IRIS_PRACTICE_ENGINE',
  /** Jetpack workflow */
  JETPACK_WORKFLOW = 'JETPACK_WORKFLOW',
  /** Karbon */
  KARBON = 'KARBON',
  /** Microsoft Dynamics */
  MICROSOFT_DYNAMICS = 'MICROSOFT_DYNAMICS',
  /** Microsoft Excel */
  MICROSOFT_EXCEL = 'MICROSOFT_EXCEL',
  /** Monday.com */
  MONDAY_COM = 'MONDAY_COM',
  /** Nomisma */
  NOMISMA = 'NOMISMA',
  /** None */
  NONE = 'NONE',
  /** Onvio */
  ONVIO = 'ONVIO',
  /** Other */
  OTHER = 'OTHER',
  /** Pixie */
  PIXIE = 'PIXIE',
  /** QuickBooks Online Accountant */
  QUICKBOOKS_ONLINE_ACCOUNTANT = 'QUICKBOOKS_ONLINE_ACCOUNTANT',
  /** Sage Handisoft */
  SAGE_HANDISOFT = 'SAGE_HANDISOFT',
  /** Senta */
  SENTA = 'SENTA',
  /** TaxCalc */
  TAXCALC = 'TAXCALC',
  /** Thomson Reuters Practice CS */
  THOMSON_REUTERS_PRACTICE_CS = 'THOMSON_REUTERS_PRACTICE_CS',
  /** Trello */
  TRELLO = 'TRELLO',
  /** Workflow Max */
  WORKFLOW_MAX = 'WORKFLOW_MAX',
  /** Xero Practice Manager */
  XERO_PRACTICE_MANAGER = 'XERO_PRACTICE_MANAGER',
  /** Zoho CRM */
  ZOHO_CRM = 'ZOHO_CRM',
}

/** Input type for minimum price rule. */
export type MinimumPriceRuleInput = {
  /** Minimum price amount */
  min: MoneyInput;
};

export type Money = {
  __typename: 'Money';
  cents: Scalars['BigInt']['output'];
  currency: Currency;
  dollars: Scalars['Decimal']['output'];
  format: Scalars['String']['output'];
};

export type MoneyInput = {
  cents: Scalars['BigInt']['input'];
  currency: Scalars['String']['input'];
};

export type Mutation = {
  __typename: 'Mutation';
  acknowledgementAdd?: Maybe<AcknowledgementAddPayload>;
  acknowledgementRemove?: Maybe<AcknowledgementRemovePayload>;
  appClientSyncSettingsUpdate?: Maybe<ClientSyncSettingsUpdatePayload>;
  /** Connect a user-configurable App */
  appConnect?: Maybe<AppConnectPayload>;
  /** Disconnect a user-configurable App */
  appDisconnect?: Maybe<AppDisconnectPayload>;
  /** Enable a user-configurable App */
  appEnable?: Maybe<AppEnablePayload>;
  appInvoiceDeploySettingsUpdate?: Maybe<InvoiceDeploySettingsUpdatePayload>;
  /** Create Ignition Services from AppServices */
  appServicesBulkCreate?: Maybe<ServicesBulkCreatePayload>;
  /** Update sync settings for an App */
  appSetClientSyncSettings?: Maybe<AppSetClientSyncSettingsPayload>;
  /** Request a data sync for an App */
  appSync?: Maybe<AppSyncPayload>;
  bankAccountFailureEmailTemplateUpdate?: Maybe<BankAccountFailureEmailTemplateUpdatePayload>;
  bankAccountVerificationEmailTemplateUpdate?: Maybe<BankAccountVerificationEmailTemplateUpdatePayload>;
  /** Add a custom unit price rule name */
  billingPriceRuleAddUnitName?: Maybe<BillingPriceRuleAddUnitNamePayload>;
  /** Delete a custom unit name */
  billingPriceRuleDeleteUnitName?: Maybe<BillingPriceRuleDeleteUnitNamePayload>;
  /** Update Branding Theme Colour */
  brandingThemeColourUpdate?: Maybe<BrandingThemeColourUpdatePayload>;
  /** Unset Branding Theme DefaultBrochure */
  brandingThemeDefaultBrochureUnset?: Maybe<BrandingThemeDefaultBrochureUnsetPayload>;
  /** Update Branding Theme DefaultBrochure */
  brandingThemeDefaultBrochureUpdate?: Maybe<BrandingThemeDefaultBrochureUpdatePayload>;
  /** Unset Branding Theme Logo */
  brandingThemeLogoUnset?: Maybe<BrandingThemeLogoUnsetPayload>;
  /** Update Branding Theme Logo */
  brandingThemeLogoUpdate?: Maybe<BrandingThemeLogoUpdatePayload>;
  /** Update Branding Theme Attributes (Logo, Colour, Default Brochure) */
  brandingThemeUpdate?: Maybe<BrandingThemeUpdatePayload>;
  /** Create brochure for current practice. */
  brochureCreate?: Maybe<BrochureCreatePayload>;
  /** Set a contact as a default secondary signatory for a client. */
  clientAddSignatory?: Maybe<ClientAddSignatoryPayload>;
  /** Archives a client synchronously */
  clientArchive?: Maybe<ClientArchivePayload>;
  /** Configure a billing item to bill automatically on the specified date using the specified payment method. */
  clientBillingBillingItemBillAutomatically?: Maybe<ClientBillingItemBillAutomaticallyPayload>;
  /** Configure a billing item to bill manually on the specified date. */
  clientBillingBillingItemBillManually?: Maybe<ClientBillingItemBillManuallyPayload>;
  /** Preview the amount and last updated at of a smart billing quantity rule */
  clientBillingBillingItemPreviewSmartBillingQuantity?: Maybe<ClientBillingItemPreviewSmartBillingQuantityPayload>;
  /** Refresh the amount and last updated at of a smart billing quantity rule */
  clientBillingBillingItemRefreshSmartBillingQuantity?: Maybe<ClientBillingItemRefreshSmartBillingQuantityPayload>;
  /** Deploy client billing invoice */
  clientBillingInvoiceDeploy?: Maybe<ClientBillingInvoiceDeployPayload>;
  /** Issues client billing invoice */
  clientBillingInvoiceIssue?: Maybe<ClientBillingInvoiceIssuePayload>;
  /** Reconcile client billing invoice */
  clientBillingInvoiceReconcile?: Maybe<ClientBillingInvoiceReconcilePayload>;
  /** Sends invoice to client email */
  clientBillingInvoiceSendInvoiceToClientEmail?: Maybe<ClientBillingInvoiceSendInvoiceToClientEmailPayload>;
  /** Archive billing items */
  clientBillingItemArchive?: Maybe<ClientBillingItemArchivePayload>;
  /** Reschedule billing items to a different invoice date */
  clientBillingItemReschedule?: Maybe<ClientBillingItemReschedulePayload>;
  /** Archives the clients */
  clientBulkArchive?: Maybe<ClientBulkArchivePayload>;
  /** Create a client */
  clientCreate?: Maybe<ClientCreatePayload>;
  /** Update client groups */
  clientGroupsUpdate?: Maybe<ClientGroupsUpdatePayload>;
  clientImport?: Maybe<ClientImportPayload>;
  /** Create client import */
  clientImportCreate?: Maybe<ClientImportCreatePayload>;
  /** Import clients into Ignition from App Clients */
  clientImportFromAppClients?: Maybe<ClientImportFromAppClientsPayload>;
  /** Delete a client's payment method */
  clientPaymentMethodDelete?: Maybe<ClientPaymentMethodDeletePayload>;
  /** Removes a signatory contact from a client */
  clientRemoveSignatory?: Maybe<ClientRemoveSignatoryPayload>;
  /** Cancel an agreed service. */
  clientServicesAgreedServiceCancel?: Maybe<ClientServicesAgreedServiceCancelPayload>;
  /** Create an agreed service (Instant Bill). */
  clientServicesAgreedServiceCreate?: Maybe<ClientServicesAgreedServiceCreatePayload>;
  /** Disable an agreed service. */
  clientServicesAgreedServiceDisable?: Maybe<ClientServicesAgreedServiceDisablePayload>;
  /** Disable all agreed services for a client. */
  clientServicesAgreedServiceDisableAll?: Maybe<ClientServicesAgreedServiceDisableAllPayload>;
  /** Remove payment method from agreed service (i.e. set to Arrange payment manually). */
  clientServicesAgreedServiceRemovePaymentMethod?: Maybe<ClientServicesAgreedServiceRemovePaymentMethodPayload>;
  /** Set payment method on agreed service. */
  clientServicesAgreedServiceSetPaymentMethod?: Maybe<ClientServicesAgreedServiceSetPaymentMethodPayload>;
  /** Update an agreed service. */
  clientServicesAgreedServiceUpdate?: Maybe<ClientServicesAgreedServiceUpdatePayload>;
  /** Exports clients' agreed services */
  clientServicesAgreedServicesExport?: Maybe<ClientServicesAgreedServicesExportPayload>;
  /** Maps a Client to an AppClient, creating a link which can be used by the integration that the AppClient comes from */
  clientSetAppMapping?: Maybe<ClientSetAppMappingPayload>;
  /** Update client's deploy invoices flag. */
  clientSetDeployInvoices?: Maybe<ClientSetDeployInvoicesPayload>;
  /** Set the payment method for all future billing of the client. */
  clientSetPaymentMethod?: Maybe<ClientSetPaymentMethodPayload>;
  /** Set a contact as the primary contact for a client. Dummy mutation for now. */
  clientSetPrimaryContact?: Maybe<ClientSetPrimaryContactPayload>;
  /** Update client's tag list info. */
  clientSetTagsList?: Maybe<ClientSetTagsListPayload>;
  /** Disables surcharges for all of the client's current and future payment methods */
  clientSurchargeDisable?: Maybe<ClientSurchargeDisablePayload>;
  /** Enables surcharges for all of the client's relevant current and future payment methods */
  clientSurchargeEnable?: Maybe<ClientSurchargeEnablePayload>;
  /** Switch payment method on the client's agreed services, billable services, billing items and payments */
  clientSwitchPaymentMethod?: Maybe<ClientSwitchPaymentMethodPayload>;
  /** Unarchives the client */
  clientUnarchive?: Maybe<ClientUnarchivePayload>;
  /** Update a client */
  clientUpdate?: Maybe<ClientUpdatePayload>;
  /** Request deployment of a workflow item to the workflow app. */
  clientWorkflowItemStartDeployment?: Maybe<ClientWorkflowItemStartDeploymentPayload>;
  /** Creates a new workflow strategy for the client. */
  clientWorkflowStrategyCreate?: Maybe<ClientWorkflowStrategyCreatePayload>;
  /**
   * Mark a workflow strategy as inactive. Once inactive, any remaining undeployed
   * workflow items will be removed and no further deploys will occur.
   */
  clientWorkflowStrategyDeactivate?: Maybe<ClientWorkflowStrategyDeactivatePayload>;
  /** Deletes a workflow strategy and all of it's items. Only permitted if no workflow items have been deployed. */
  clientWorkflowStrategyDelete?: Maybe<ClientWorkflowStrategyDeletePayload>;
  /** Creates a copy of a workflow strategy */
  clientWorkflowStrategyDuplicate?: Maybe<ClientWorkflowStrategyDuplicatePayload>;
  /** Set workflow strategy to receive billing credits from a billing group. */
  clientWorkflowStrategySetBillingGroup?: Maybe<ClientWorkflowStrategySetBillingGroupPayload>;
  /**
   * Set workflow strategy to receive billing credits from the client billing group.
   * @deprecated Use setBillingGroup
   */
  clientWorkflowStrategySetClientBillingGroup?: Maybe<ClientWorkflowStrategySetClientBillingGroupPayload>;
  /** Sets the deploy strategy for a workflow strategy. */
  clientWorkflowStrategySetDeployStrategy?: Maybe<ClientWorkflowStrategySetDeployStrategyPayload>;
  /** Sets the general settings for a workflow strategy. */
  clientWorkflowStrategySetGeneralSettings?: Maybe<ClientWorkflowStrategySetGeneralSettingsPayload>;
  /**
   * Set a one-time (non recurring) schedule for a workflow strategy on a specified date.
   *
   * Can only be changed if the workflow strategy has not yet started.
   */
  clientWorkflowStrategySetOneTimeSchedule?: Maybe<ClientWorkflowStrategySetOneTimeSchedulePayload>;
  /**
   * Set a recurring schedule for a workflow strategy starting from the specified date.
   *
   * Can only be changed if the workflow strategy has not yet started.
   */
  clientWorkflowStrategySetRecurringSchedule?: Maybe<ClientWorkflowStrategySetRecurringSchedulePayload>;
  /**
   * Removes the billing group from a workflow strategy.
   *
   * Workflow strategies with no billing group will not receive billing credits.
   */
  clientWorkflowStrategyUnsetBillingGroup?: Maybe<ClientWorkflowStrategyUnsetBillingGroupPayload>;
  collectionsNotificationSettingsUpdate?: Maybe<CollectionsNotificationSettingsUpdatePayload>;
  /** Update contact's info. */
  contactUpdate?: Maybe<ContactUpdatePayload>;
  customerSuccessMaturityIndexCalculate?: Maybe<CustomerSuccessMaturityIndexCalculatePayload>;
  customerSuccessMaturityIndexUpdateIndustry?: Maybe<CustomerSuccessMaturityIndexUpdateIndustryPayload>;
  /** Set new revenue growth target to recalculate CMI score */
  dashboardRevenueGrowthTargetSet?: Maybe<DashboardRevenueGrowthTargetSetPayload>;
  /** Update practice's dashboard settings */
  dashboardUpdate?: Maybe<DashboardUpdateSettingsPayload>;
  /** Accept a CPE Proposal (Engagement) on behalf of the client. */
  engagementAcceptOnBehalf?: Maybe<EngagementAcceptOnBehalfPayload>;
  /** Archive a CPE Proposal (Engagement) */
  engagementArchive?: Maybe<EngagementArchivePayload>;
  /** Complete a CPE Proposal (Engagement) */
  engagementComplete?: Maybe<EngagementCompletePayload>;
  /** Create an Engagement (CPE Proposal). */
  engagementCreate?: Maybe<EngagementCreatePayload>;
  engagementDeployJobsSettingUpdate?: Maybe<EngagementDeployJobsSettingUpdatePayload>;
  /** Disable continuous billing on a CPE Proposal (Engagement). */
  engagementDisableContinuousBilling?: Maybe<EngagementDisableContinuousBillingPayload>;
  /** Enable continuous billing on a CPE Proposal (Engagement). */
  engagementEnableContinuousBilling?: Maybe<EngagementEnableContinuousBillingPayload>;
  engagementJobsSend?: Maybe<EngagementJobsSendPayload>;
  engagementLetterCreate?: Maybe<CustomerSuccessEngagementLetterCreatePayload>;
  /** Mark a CPE Proposal (Engagement) as lost. */
  engagementMarkAsLost?: Maybe<EngagementMarkAsLostPayload>;
  /** Mark a CPE Proposal (Engagement) for review. */
  engagementMarkForReview?: Maybe<EngagementMarkForReviewPayload>;
  /** Move a CPE Proposal (Engagement) to awaiting acceptance without sending to the client. */
  engagementMoveToAwaitingAcceptance?: Maybe<EngagementMoveToAwaitingAcceptancePayload>;
  /** Move a CPE Proposal (Engagement) to draft. */
  engagementMoveToDraft?: Maybe<EngagementMoveToDraftPayload>;
  /** Change engagement name. */
  engagementNameChange?: Maybe<EngagementNameChangePayload>;
  /** Reactivate a completed CPE Proposal (Engagement). */
  engagementReactivate?: Maybe<EngagementReactivatePayload>;
  /** Revoke a CPE Proposal (Engagement). */
  engagementRevoke?: Maybe<EngagementRevokePayload>;
  /** Send a CPE Proposal (Engagement) to the client. */
  engagementSendToClient?: Maybe<EngagementSendToClientPayload>;
  /** Exports payments csv */
  exportPayments?: Maybe<ExportPaymentsPayload>;
  /** Export CPE proposals as a csv */
  exportProposals?: Maybe<ExportProposalsPayload>;
  /** Exports services csv */
  exportServices?: Maybe<ExportServicesPayload>;
  introMessageTemplateCreate?: Maybe<IntroMessageTemplateCreatePayload>;
  introMessageTemplateDelete?: Maybe<IntroMessageTemplateDeletePayload>;
  introMessageTemplateSetDefault?: Maybe<IntroMessageTemplateSetDefaultPayload>;
  introMessageTemplateUpdate?: Maybe<IntroMessageTemplateUpdatePayload>;
  ipmAuthorise?: Maybe<IpmAuthorisePayload>;
  ipmDisconnect?: Maybe<IpmDisconnectPayload>;
  ipmEnable?: Maybe<IpmEnablePayload>;
  ipmWorkTemplateMappingsConfirm?: Maybe<IpmWorkTemplateMappingsConfirmPayload>;
  ipmWorkTemplateMappingsUpdate?: Maybe<IpmWorkTemplateMappingsUpdatePayload>;
  ipmWorkTemplatesSyncAll?: Maybe<IpmWorkTemplatesSyncAllPayload>;
  karbonAuthorise?: Maybe<KarbonAuthorisePayload>;
  karbonDisconnect?: Maybe<KarbonDisconnectPayload>;
  karbonEnable?: Maybe<KarbonEnablePayload>;
  karbonWorkTemplateMappingsConfirm?: Maybe<KarbonWorkTemplateMappingsConfirmPayload>;
  karbonWorkTemplateMappingsUpdate?: Maybe<KarbonWorkTemplateMappingsUpdatePayload>;
  karbonWorkTemplatesSyncAll?: Maybe<KarbonWorkTemplatesSyncAllPayload>;
  newGroupProposalEmailTemplateUpdate?: Maybe<NewGroupProposalEmailTemplateUpdatePayload>;
  newProposalEmailTemplateArchive?: Maybe<NewProposalEmailTemplateArchivePayload>;
  newProposalEmailTemplateCreate?: Maybe<NewProposalEmailTemplateCreatePayload>;
  newProposalEmailTemplateUpdate?: Maybe<NewProposalEmailTemplateUpdatePayload>;
  newSubmissionEmailTemplateUpdate?: Maybe<NewSubmissionEmailTemplateUpdatePayload>;
  nextStepsMessageTemplateCreate?: Maybe<NextStepsMessageTemplateCreatePayload>;
  nextStepsMessageTemplateDelete?: Maybe<NextStepsMessageTemplateDeletePayload>;
  nextStepsMessageTemplateSetDefault?: Maybe<NextStepsMessageTemplateSetDefaultPayload>;
  nextStepsMessageTemplateUpdate?: Maybe<NextStepsMessageTemplateUpdatePayload>;
  notificationsMarkAllReadBeforeTime?: Maybe<NotificationsMarkAllReadBeforeTimePayload>;
  /** Mark one or more notifications as read */
  notificationsMarkAsRead?: Maybe<NotificationsMarkAsReadPayload>;
  notificationsSettingsSetScope?: Maybe<NotificationsSettingsSetScopePayload>;
  notificationsSettingsSetSetting?: Maybe<NotificationsSettingsSetSettingPayload>;
  notificationsViewed?: Maybe<NotificationsViewedPayload>;
  /** Cancels an uncollected payment */
  paymentCancel?: Maybe<PaymentCancelPayload>;
  /** Create a payment method from a setup intent */
  paymentMethodCreateFromSetupIntent?: Maybe<PaymentMethodCreateFromSetupIntentPayload>;
  /** Request payment method from a client. Does not send an email */
  paymentMethodRequestCreate?: Maybe<PaymentMethodRequestCreatePayload>;
  /** Request a refund for a payment */
  paymentRefundRequest?: Maybe<PaymentRefundRequestPayload>;
  /** Schedule collection of a payment */
  paymentScheduleCollection?: Maybe<PaymentScheduleCollectionPayload>;
  /** Start collection of a payment */
  paymentStartCollection?: Maybe<PaymentStartCollectionPayload>;
  /** Unschedule a scheduled collection on a payment */
  paymentUnscheduleCollection?: Maybe<PaymentUnscheduleCollectionPayload>;
  /** Update what types of collections this practice will require/accept */
  paymentsCollectionSettingsUpdate?: Maybe<PaymentsCollectionSettingsUpdatePayload>;
  /** Update the disbursal account for payments */
  paymentsDisbursalAccountUpdate?: Maybe<PaymentsDisbursalAccountUpdatePayload>;
  paymentsDisbursalsExport?: Maybe<PaymentsDisbursalsExportPayload>;
  /** Asynchronously request payment methods from clients via email */
  paymentsSendPaymentMethodRequestToClients?: Maybe<SendPaymentMethodRequestToClientsPayload>;
  /** Create a payment method setup intent for a client */
  paymentsSetupIntentCreate?: Maybe<PaymentMethodSetupIntentCreatePayload>;
  /** Allow the practice to stop using surcharges to pass on payment fees to their clients */
  paymentsSurchargeDisable?: Maybe<SurchargeDisablePayload>;
  /** Allow the practice to use surcharges to pass on payment fees to their clients */
  paymentsSurchargeEnable?: Maybe<SurchargeEnablePayload>;
  paymentsTermsUpdate?: Maybe<PaymentsTermsUpdatePayload>;
  practiceBillingCancelSubscription?: Maybe<PracticeBillingCancelSubscriptionPayload>;
  practiceBillingReportPaymentChallengeError?: Maybe<PracticeBillingReportPaymentChallengeErrorPayload>;
  practiceBillingResolvePaymentChallenge?: Maybe<PracticeBillingResolvePaymentChallengePayload>;
  practiceBillingSetSubscription?: Maybe<PracticeBillingSetSubscriptionPayload>;
  /** Confirm practice details upon sign up */
  practiceConfirmDetails?: Maybe<PracticeConfirmDetailsPayload>;
  /** Confirm practice details and calculate cmi upon signing up with a ledger SSO */
  practiceConfirmDetailsFromLedgerSso?: Maybe<PracticeConfirmDetailsFromLedgerSsoPayload>;
  /** Generates a url to start the retention process */
  practiceRetentionUrl?: Maybe<PracticeRetentionUrlPayload>;
  practiceSetDefaultNewProposalEmailTemplate?: Maybe<PracticeSetDefaultNewProposalEmailTemplatePayload>;
  practiceSetDefaultTax?: Maybe<PracticeSetDefaultTaxPayload>;
  practiceSetDefaultTermsTemplate?: Maybe<PracticeSetDefaultTermsTemplatePayload>;
  /** Set the practice's intent for signing up with ignition */
  practiceSetIntent?: Maybe<PracticeSetIntentPayload>;
  practiceSetPreferredLandingPage?: Maybe<PracticeSetPreferredLandingPagePayload>;
  practiceSetPreferredProposalEditor?: Maybe<PracticeSetPreferredProposalEditorPayload>;
  proconnectConnect?: Maybe<ProconnectConnectPayload>;
  proconnectDisconnect?: Maybe<ProconnectDisconnectPayload>;
  proposalAcceptedBrowserTemplateUpdate?: Maybe<ProposalAcceptedBrowserTemplateUpdatePayload>;
  proposalAcceptedEmailTemplateUpdate?: Maybe<ProposalAcceptedEmailTemplateUpdatePayload>;
  /** Add or reset workflows based on the workflow app settings. */
  proposalAddDefaultWorkflow?: Maybe<ProposalAddDefaultWorkflowPayload>;
  /**
   * Deprecated. Adds a service group with multiple billing schedules. Use the
   * regular 'ProposalAddServiceGroup' mutation instead as it is identical
   */
  proposalAddMultipleBillingServiceGroup?: Maybe<ProposalAddMultipleBillingServiceGroupPayload>;
  /** Add a service group with once-off on acceptance billing strategy */
  proposalAddOnAcceptanceServiceGroup?: Maybe<ProposalAddOnAcceptanceServiceGroupPayload>;
  /** Add an option to a proposal */
  proposalAddOption?: Maybe<ProposalAddOptionPayload>;
  /** adds a project to a proposal option */
  proposalAddProject?: Maybe<ProposalAddProjectPayload>;
  /** adds a proposed service to a service group */
  proposalAddProposedService?: Maybe<ProposalAddProposedServicePayload>;
  /** adds a recipient to proposal */
  proposalAddRecipient?: Maybe<ProposalAddRecipientPayload>;
  /** Add a service group with recurring billing strategy */
  proposalAddRecurringServiceGroup?: Maybe<ProposalAddRecurringServiceGroupPayload>;
  /**
   * Add a service group to a project
   * @deprecated Use proposalAddOnAcceptanceServiceGroup instead
   */
  proposalAddServiceGroup?: Maybe<ProposalAddServiceGroupPayload>;
  /** Add a Workflow Strategy to a Proposal. */
  proposalAddWorkflowStrategy?: Maybe<ProposalAddWorkflowStrategyPayload>;
  /** Add a staff to a Workflow Strategy. */
  proposalAddWorkflowStrategyStaff?: Maybe<ProposalAddWorkflowStrategyStaffPayload>;
  /** Add a template to a Workflow Strategy. */
  proposalAddWorkflowStrategyTemplate?: Maybe<ProposalAddWorkflowStrategyTemplatePayload>;
  /** archives a proposal */
  proposalArchive?: Maybe<ProposalArchivePayload>;
  /** Create a draft proposal and set its client if clientId is provided. */
  proposalCreate?: Maybe<ProposalCreatePayload>;
  /** Create multiple proposals */
  proposalCreateBulk?: Maybe<ProposalCreateBulkPayload>;
  /** Create a draft proposal with demo client set. */
  proposalCreateWithDemoClient?: Maybe<ProposalCreateWithDemoClientPayload>;
  /** Create a new proposal with placeholder client set. */
  proposalCreateWithPlaceholderClient?: Maybe<ProposalCreateWithPlaceholderClientPayload>;
  /** Create a custom template from a proposal */
  proposalCustomTemplateCreateFromProposal?: Maybe<ProposalCustomTemplateCreateFromProposalPayload>;
  /** Delete a custom template */
  proposalCustomTemplateDelete?: Maybe<ProposalCustomTemplateDeletePayload>;
  /** Create a custom template preview proposal */
  proposalCustomTemplatePreview?: Maybe<ProposalCustomTemplatePreviewPayload>;
  /** Replace a custom template with new proposal data */
  proposalCustomTemplateReplace?: Maybe<ProposalCustomTemplateReplacePayload>;
  /** duplicates a proposal */
  proposalDuplicate?: Maybe<ProposalDuplicatePayload>;
  /** duplicates a proposal option */
  proposalDuplicateOption?: Maybe<ProposalOptionDuplicatePayload>;
  /** Duplicate project from a proposal */
  proposalDuplicateProject?: Maybe<ProposalDuplicateProjectPayload>;
  /** Duplicate proposed service from a proposal */
  proposalDuplicateProposedService?: Maybe<ProposalDuplicateProposedServicePayload>;
  /** Duplicate service group from a proposal */
  proposalDuplicateServiceGroup?: Maybe<ProposalDuplicateServiceGroupPayload>;
  /** Increase service prices of a proposal. */
  proposalIncreaseServicePrices?: Maybe<ProposalIncreaseServicePricesPayload>;
  /** marks a proposal as lost */
  proposalMarkAsLost?: Maybe<ProposalMarkAsLostPayload>;
  /** Move options within proposal */
  proposalMoveOption?: Maybe<ProposalMoveOptionPayload>;
  /** move project within a proposal option */
  proposalMoveProject?: Maybe<ProposalMoveProjectPayload>;
  /** move proposed service within and between proposal service groups */
  proposalMoveProposedService?: Maybe<ProposalMoveProposedServicePayload>;
  /** Move service group within and between proposal projects */
  proposalMoveServiceGroup?: Maybe<ProposalMoveServiceGroupPayload>;
  /** move proposal to awaiting acceptance */
  proposalMoveToAwaitingAcceptance?: Maybe<ProposalMoveToAwaitingAcceptancePayload>;
  /** Request the lastest amount be fetched for the smart quantity attached to a given proposed service */
  proposalRefreshProposedServiceSmartQuantity?: Maybe<ProposalRefreshProposedServiceSmartQuantityPayload>;
  /** remove option from a proposal */
  proposalRemoveOption?: Maybe<ProposalRemoveOptionPayload>;
  /** remove project from a proposal */
  proposalRemoveProject?: Maybe<ProposalRemoveProjectPayload>;
  /** remove proposed service from a proposal */
  proposalRemoveProposedService?: Maybe<ProposalRemoveProposedServicePayload>;
  /** removes a recipient on proposal */
  proposalRemoveRecipient?: Maybe<ProposalRemoveRecipientPayload>;
  /** Remove service group from a proposal */
  proposalRemoveServiceGroup?: Maybe<ProposalRemoveServiceGroupPayload>;
  /** Remove a Workflow Strategy from a Proposal. */
  proposalRemoveWorkflowStrategy?: Maybe<ProposalRemoveWorkflowStrategyPayload>;
  /** Remove a staff from a Workflow Strategy. */
  proposalRemoveWorkflowStrategyStaff?: Maybe<ProposalRemoveWorkflowStrategyStaffPayload>;
  /** Remove a template from a Workflow Strategy. */
  proposalRemoveWorkflowStrategyTemplate?: Maybe<ProposalRemoveWorkflowStrategyTemplatePayload>;
  /** Renews a proposal */
  proposalRenew?: Maybe<ProposalRenewPayload>;
  /** Renew multiple proposals */
  proposalRenewBulk?: Maybe<ProposalRenewBulkPayload>;
  /**
   * Reset an option to the default state.
   * This will remove any customisation made to the option.
   */
  proposalResetOption?: Maybe<ProposalResetOptionPayload>;
  /**
   * Reset a project to the default state.
   * This will remove any services added or customisation made to the project.
   */
  proposalResetProject?: Maybe<ProposalResetProjectPayload>;
  /** Approve an proposal. */
  proposalReviewApprove?: Maybe<ProposalReviewApprovePayload>;
  /** Request a change or changes to a proposal. */
  proposalReviewRequestChange?: Maybe<ProposalReviewRequestChangePayload>;
  /** Request a Review of a proposal. */
  proposalReviewRequestReview?: Maybe<ProposalReviewRequestReviewPayload>;
  /** revoke a proposal */
  proposalRevoke?: Maybe<ProposalRevokePayload>;
  /** saves a proposal for later */
  proposalSave?: Maybe<ProposalSavePayload>;
  /** Send a demo proposal to a specific email address */
  proposalSendDemo?: Maybe<SendDemoProposalPayload>;
  /** send a test proposal to a specific email address */
  proposalSendTestProposal?: Maybe<SendTestProposalPayload>;
  /** send proposal to client */
  proposalSendToClient?: Maybe<ProposalSendToClientPayload>;
  /** Send multiple proposals to their respective clients */
  proposalSendToClientBulk?: Maybe<ProposalSendToClientBulkPayload>;
  /** send proposal to signatory */
  proposalSendToSignatory?: Maybe<ProposalSendToSignatoryPayload>;
  /** Change the way services from this proposal are grouped for billing. */
  proposalSetBillingGroupedBy?: Maybe<ProposalSetBillingGroupedByPayload>;
  /** Set proposal's brochure */
  proposalSetBrochure?: Maybe<ProposalSetBrochurePayload>;
  /** Set proposal's client */
  proposalSetClient?: Maybe<ProposalSetClientPayload>;
  /** set the email template of a proposal */
  proposalSetEmailTemplate?: Maybe<ProposalSetEmailTemplatePayload>;
  /** set the minimum length of the proposed contract */
  proposalSetMinimumContractLength?: Maybe<ProposalSetMinimumContractLengthPayload>;
  /** Set proposal's name */
  proposalSetName?: Maybe<ProposalSetNamePayload>;
  /** Set the next steps message for a proposal */
  proposalSetNextStepsMessage?: Maybe<ProposalSetNextStepsMessagePayload>;
  /** set display of one time date on proposal */
  proposalSetOneTimeDateDisplay?: Maybe<ProposalSetOneTimeDateDisplayPayload>;
  /** Set proposal option's description */
  proposalSetOptionDescription?: Maybe<ProposalOptionSetDescriptionPayload>;
  /** Set proposal option's name */
  proposalSetOptionName?: Maybe<ProposalOptionSetNamePayload>;
  /** Set proposal's payment settings */
  proposalSetPaymentSettings?: Maybe<ProposalSetPaymentSettingsPayload>;
  /** set the personalised message for a proposal */
  proposalSetPersonalisedMessage?: Maybe<ProposalSetPersonalisedMessagePayload>;
  /** Set post acceptance video url */
  proposalSetPostAcceptanceVideo?: Maybe<ProposalSetPostAcceptanceVideoPayload>;
  /** set current practice as sender of a proposal */
  proposalSetPracticeAsSender?: Maybe<ProposalSetPracticeAsSenderPayload>;
  /** Set pre acceptance video url */
  proposalSetPreAcceptanceVideo?: Maybe<ProposalSetPreAcceptanceVideoPayload>;
  /** set the description of a proposed project */
  proposalSetProjectDescription?: Maybe<ProposalSetProjectDescriptionPayload>;
  /** set the graphql_name of a proposed project */
  proposalSetProjectName?: Maybe<ProposalSetProjectNamePayload>;
  /** set display of a proposal's value */
  proposalSetProposalValueDisplay?: Maybe<ProposalSetProposalValueDisplayPayload>;
  /** set account for proposed service */
  proposalSetProposedServiceAccount?: Maybe<ProposalSetProposedServiceAccountPayload>;
  /** set the description of a proposed service */
  proposalSetProposedServiceDescription?: Maybe<ProposalSetProposedServiceDescriptionPayload>;
  /** set fixed price for a proposed service */
  proposalSetProposedServiceFixedPrice?: Maybe<ProposalSetProposedServiceFixedPricePayload>;
  /** set included price for a proposed service */
  proposalSetProposedServiceIncludedPrice?: Maybe<ProposalSetProposedServiceIncludedPricePayload>;
  /** set the minimum for a proposed service */
  proposalSetProposedServiceMinimumPrice?: Maybe<ProposalSetProposedServiceMinimumPricePayload>;
  /** set invoice strategy of a proposed service portion */
  proposalSetProposedServicePortionInvoiceStrategy?: Maybe<ProposalSetProposedServicePortionInvoiceStrategyPayload>;
  /** set price of a proposed service portion */
  proposalSetProposedServicePortionPrice?: Maybe<ProposalSetProposedServicePortionPricePayload>;
  /** sets the price range for a proposed service */
  proposalSetProposedServicePriceRange?: Maybe<ProposalSetProposedServicePriceRangePayload>;
  /** set quantity rule for a proposed service */
  proposalSetProposedServiceQuantityRule?: Maybe<ProposalSetProposedServiceQuantityRulePayload>;
  /** set the tax type of a proposed service */
  proposalSetProposedServiceTax?: Maybe<ProposalSetProposedServiceTaxPayload>;
  /** Set the tax exempt flag of a proposed service.  Only used for proposals which are using proposal level taxes. */
  proposalSetProposedServiceTaxExempt?: Maybe<ProposalSetProposedServiceTaxExemptPayload>;
  /** set unit price for a proposed service */
  proposalSetProposedServiceUnitPrice?: Maybe<ProposalSetProposedServiceUnitPricePayload>;
  /** Set proposal's recommended option */
  proposalSetRecommendedOption?: Maybe<ProposalSetRecommendedOptionPayload>;
  /** set one or more billing schedules on a service group */
  proposalSetServiceGroupBillingSchedules?: Maybe<ProposalSetServiceGroupBillingSchedulesPayload>;
  /** set display of detailed service prices on proposal */
  proposalSetServicePriceDisplay?: Maybe<ProposalSetServicePriceDisplayPayload>;
  /** sets the signatories for a proposal */
  proposalSetSignatories?: Maybe<ProposalSetSignatoriesPayload>;
  /**
   * Set proposal's tax.  This is only used for proposals that are using proposal
   * level taxes.  If using service level taxes, ProposalSetProposedServiceTax
   * should be used instead.
   */
  proposalSetTax?: Maybe<ProposalSetTaxPayload>;
  /** set the terms template of a proposal */
  proposalSetTermsTemplate?: Maybe<ProposalSetTermsTemplatePayload>;
  /** set an user as sender of a proposal */
  proposalSetUserAsSender?: Maybe<ProposalSetUserAsSenderPayload>;
  /** Update the budget on a Workflow Strategy. */
  proposalSetWorkflowStrategyBudget?: Maybe<ProposalSetWorkflowStrategyBudgetPayload>;
  /** Update the categories on a Workflow Strategy. */
  proposalSetWorkflowStrategyCategories?: Maybe<ProposalSetWorkflowStrategyCategoriesPayload>;
  /** Update the description on a Workflow Strategy. */
  proposalSetWorkflowStrategyDescription?: Maybe<ProposalSetWorkflowStrategyDescriptionPayload>;
  /** Update the duration on a Workflow Strategy. */
  proposalSetWorkflowStrategyDuration?: Maybe<ProposalSetWorkflowStrategyDurationPayload>;
  /** Update the manager on a Workflow Strategy. */
  proposalSetWorkflowStrategyManager?: Maybe<ProposalSetWorkflowStrategyManagerPayload>;
  /** Update the name on a Workflow Strategy. */
  proposalSetWorkflowStrategyName?: Maybe<ProposalSetWorkflowStrategyNamePayload>;
  /** Update the partner on a Workflow Strategy. */
  proposalSetWorkflowStrategyPartner?: Maybe<ProposalSetWorkflowStrategyPartnerPayload>;
  /** Set the Workflow Strategy schedule to non-recurring. */
  proposalSetWorkflowStrategyRecurrenceOnce?: Maybe<ProposalSetWorkflowStrategyRecurrenceOncePayload>;
  /** Set the Workflow Strategy schedule to recurring. */
  proposalSetWorkflowStrategyRecurring?: Maybe<ProposalSetWorkflowStrategyRecurringPayload>;
  /** Set the Workflow Strategy schedule start date. */
  proposalSetWorkflowStrategyStartOnDate?: Maybe<ProposalSetWorkflowStrategyStartOnDatePayload>;
  /** Update the templates on a Workflow Strategy. */
  proposalSetWorkflowStrategyTemplates?: Maybe<ProposalSetWorkflowStrategyTemplatesPayload>;
  /** sign on behalf of all unsigned signatories */
  proposalSignOnBehalfForAll?: Maybe<ProposalSignOnBehalfForAllPayload>;
  /** set proposal to start on acceptance */
  proposalStartOnAcceptance?: Maybe<ProposalStartOnAcceptancePayload>;
  /** set the date the proposed contract starts on */
  proposalStartOnDate?: Maybe<ProposalStartOnDatePayload>;
  /** Create a proposal from a template */
  proposalTemplateUse?: Maybe<ProposalTemplateUsePayload>;
  /** Unset proposal's brochure */
  proposalUnsetBrochure?: Maybe<ProposalUnsetBrochurePayload>;
  /** Unset proposal's recommended option */
  proposalUnsetRecommendedOption?: Maybe<ProposalUnsetRecommendedOptionPayload>;
  /** Remove a manager from a Workflow Strategy. */
  proposalUnsetWorkflowStrategyManager?: Maybe<ProposalUnsetWorkflowStrategyManagerPayload>;
  /** Remove a partner from a Workflow Strategy. */
  proposalUnsetWorkflowStrategyPartner?: Maybe<ProposalUnsetWorkflowStrategyPartnerPayload>;
  /** Update proposed service from a service in a proposal. */
  proposalUpdateProposedService?: Maybe<ProposalUpdateProposedServicePayload>;
  /** Sets the deploy strategy for all workflows for the specified app. */
  proposalWorkflowSettingsSetDeployStrategy?: Maybe<ProposalWorkflowSettingsSetDeployStrategyPayload>;
  /** Set the workflow strategy to receive billing credits from the client billing group. */
  proposalWorkflowStrategySetClientBillingGroup?: Maybe<ProposalWorkflowStrategySetClientBillingGroupPayload>;
  /** Set the workflow strategy to receive billing credits from a Project billing group. */
  proposalWorkflowStrategySetProjectBillingGroup?: Maybe<ProposalWorkflowStrategySetProjectBillingGroupPayload>;
  /** Set the workflow strategy to receive billing credits from the Proposal billing group. */
  proposalWorkflowStrategySetProposalBillingGroup?: Maybe<ProposalWorkflowStrategySetProposalBillingGroupPayload>;
  /** Set the Workflow Strategy schedule to start on proposal acceptance. */
  proposalWorkflowStrategyStartOnAcceptance?: Maybe<ProposalWorkflowStrategyStartOnAcceptancePayload>;
  /** Set the Workflow Strategy schedule to start on proposal start date. */
  proposalWorkflowStrategyStartOnProposalStart?: Maybe<ProposalWorkflowStrategyStartOnProposalStartPayload>;
  /** Unset the billing group on a Workflow Strategy. */
  proposalWorkflowStrategyUnsetBillingGroup?: Maybe<ProposalWorkflowStrategyUnsetBillingGroupPayload>;
  /** Creates a Background Job for emailing proposal CSVs to the current user */
  proposalsExport?: Maybe<ProposalsExportPayload>;
  quickbooksDisconnect?: Maybe<QuickbooksDisconnectPayload>;
  quickbooksEnable?: Maybe<QuickbooksEnablePayload>;
  /** Create proposals from recurring transactions */
  quickbooksProposalsBulkCreateFromRecurringTransactions?: Maybe<ProposalsBulkCreateFromRecurringTransactionsPayload>;
  quickbooksSettingsUpdate?: Maybe<QuickbooksSettingsUpdatePayload>;
  quickbooksTaxCodeMappingCreate?: Maybe<QuickbooksTaxCodeMappingCreatePayload>;
  quickbooksTaxCodeMappingsUpdate?: Maybe<QuickbooksTaxCodeMappingsUpdatePayload>;
  /** Triggers a future CSV export with the given filters and returns immediately */
  searchExportCsv?: Maybe<SearchExportCsvPayload>;
  /** Add Mapping between a Service and Workflow Templates */
  serviceAddWorkflowTemplateMappings?: Maybe<ServiceAddWorkflowTemplateMappingsPayload>;
  /** Create a service in service library */
  serviceCreate?: Maybe<ServiceCreatePayload>;
  /** Archives the services */
  serviceDelete?: Maybe<ServiceDeletePayload>;
  /** Remove Mapping between a Service and Workflow Templates */
  serviceDeleteWorkflowTemplateMappings?: Maybe<ServiceDeleteWorkflowTemplateMappingsPayload>;
  /** Ai Simplify Service Description */
  serviceEnhanceAiServiceDescription?: Maybe<EnhanceAiServiceDescriptionPayload>;
  /** Ai Generate Service Description */
  serviceGenerateAiServiceDescription?: Maybe<ServiceGenerateAiServiceDescriptionPayload>;
  serviceGroupCreate?: Maybe<ServiceGroupCreatePayload>;
  /** Import services */
  serviceImport?: Maybe<ServiceImportPayload>;
  serviceRevenueExport?: Maybe<ServiceRevenueExportPayload>;
  /** Set Mapping between a Service and Workflow Templates */
  serviceSetWorkflowTemplateMappings?: Maybe<ServiceSetWorkflowTemplateMappingsPayload>;
  /** Generate token for service */
  serviceTokenGenerate?: Maybe<ServiceTokenGeneratePayload>;
  /** revoke token for service */
  serviceTokenRevoke?: Maybe<ServiceTokenRevokePayload>;
  /** Update a service in service library */
  serviceUpdate?: Maybe<ServiceUpdatePayload>;
  taxCreate?: Maybe<TaxCreatePayload>;
  /** Maps a list of Taxes to AppTaxes, creating a link which can be used by the integration that the AppTax comes from. */
  taxSetAppMappings?: Maybe<TaxSetAppMappingsPayload>;
  termsTemplateCreate?: Maybe<TermsTemplateCreatePayload>;
  termsTemplateDelete?: Maybe<TermsTemplateDeletePayload>;
  termsTemplateUpdate?: Maybe<TermsTemplateUpdatePayload>;
  userCreate?: Maybe<UserCreatePayload>;
  userDelete?: Maybe<UserDeletePayload>;
  userInvite?: Maybe<UserInvitePayload>;
  userInviteAll?: Maybe<UserInviteAllPayload>;
  /** Sign out current user and clear out current session's user tokens */
  userLogout?: Maybe<UserLogoutPayload>;
  /** Update user's password in app. It requires user token app scope to execute the mutation. */
  userPasswordUpdate?: Maybe<UserPasswordUpdatePayload>;
  /** Register a referral URL that the user can share with others to participate in the referrals scheme */
  userRegisterReferralUrl?: Maybe<UserRegisterReferralUrlPayload>;
  /** The practice principal can reset a users TFA_ENABLED to false */
  userResetTwoFactorAuth?: Maybe<UserResetTwoFactorAuthPayload>;
  /** Send an email with a user's referral URL to participate in the referrals scheme */
  userSendReferralInviteEmail?: Maybe<UserSendReferralInviteEmailPayload>;
  /** Send a the tfa code to the current users mobile */
  userSendTwoFactorAuthSmsCode?: Maybe<UserSendTwoFactorAuthSmsCodePayload>;
  /** Maps a User to an AppUser, creating a link which can be used by the integration that the AppUser comes from */
  userSetAppMapping?: Maybe<UserSetAppMappingPayload>;
  userUpdate?: Maybe<UserUpdatePayload>;
  userUpdateWeeklySummaryEmail?: Maybe<UserUpdateWeeklySummaryEmailPayload>;
  /** Uploads a user avatar. */
  userUploadAvatar?: Maybe<UploadAvatarPayload>;
  /** Create proposals from repeating invoices */
  xeroProposalsBulkCreateFromRepeatingInvoices?: Maybe<ProposalsBulkCreateFromRepeatingInvoicesPayload>;
  xeroTaxRateMappingCreate?: Maybe<XeroTaxRateMappingCreatePayload>;
  xeroTaxRateMappingsUpdate?: Maybe<XeroTaxRateMappingsUpdatePayload>;
};

export type MutationAcknowledgementAddArgs = {
  input: AcknowledgementAddInput;
};

export type MutationAcknowledgementRemoveArgs = {
  input: AcknowledgementRemoveInput;
};

export type MutationAppClientSyncSettingsUpdateArgs = {
  input: ClientSyncSettingsUpdateInput;
};

export type MutationAppConnectArgs = {
  input: AppConnectInput;
};

export type MutationAppDisconnectArgs = {
  input: AppDisconnectInput;
};

export type MutationAppEnableArgs = {
  input: AppEnableInput;
};

export type MutationAppInvoiceDeploySettingsUpdateArgs = {
  input: InvoiceDeploySettingsUpdateInput;
};

export type MutationAppServicesBulkCreateArgs = {
  input: ServicesBulkCreateInput;
};

export type MutationAppSetClientSyncSettingsArgs = {
  input: AppSetClientSyncSettingsInput;
};

export type MutationAppSyncArgs = {
  input: AppSyncInput;
};

export type MutationBankAccountFailureEmailTemplateUpdateArgs = {
  input: BankAccountFailureEmailTemplateUpdateInput;
};

export type MutationBankAccountVerificationEmailTemplateUpdateArgs = {
  input: BankAccountVerificationEmailTemplateUpdateInput;
};

export type MutationBillingPriceRuleAddUnitNameArgs = {
  input: BillingPriceRuleAddUnitNameInput;
};

export type MutationBillingPriceRuleDeleteUnitNameArgs = {
  input: BillingPriceRuleDeleteUnitNameInput;
};

export type MutationBrandingThemeColourUpdateArgs = {
  input: BrandingThemeColourUpdateInput;
};

export type MutationBrandingThemeDefaultBrochureUnsetArgs = {
  input: BrandingThemeDefaultBrochureUnsetInput;
};

export type MutationBrandingThemeDefaultBrochureUpdateArgs = {
  input: BrandingThemeDefaultBrochureUpdateInput;
};

export type MutationBrandingThemeLogoUnsetArgs = {
  input: BrandingThemeLogoUnsetInput;
};

export type MutationBrandingThemeLogoUpdateArgs = {
  input: BrandingThemeLogoUpdateInput;
};

export type MutationBrandingThemeUpdateArgs = {
  input: BrandingThemeUpdateInput;
};

export type MutationBrochureCreateArgs = {
  input: BrochureCreateInput;
};

export type MutationClientAddSignatoryArgs = {
  input: ClientAddSignatoryInput;
};

export type MutationClientArchiveArgs = {
  input: ClientArchiveInput;
};

export type MutationClientBillingBillingItemBillAutomaticallyArgs = {
  input: ClientBillingItemBillAutomaticallyInput;
};

export type MutationClientBillingBillingItemBillManuallyArgs = {
  input: ClientBillingItemBillManuallyInput;
};

export type MutationClientBillingBillingItemPreviewSmartBillingQuantityArgs = {
  input: ClientBillingItemPreviewSmartBillingQuantityInput;
};

export type MutationClientBillingBillingItemRefreshSmartBillingQuantityArgs = {
  input: ClientBillingItemRefreshSmartBillingQuantityInput;
};

export type MutationClientBillingInvoiceDeployArgs = {
  input: ClientBillingInvoiceDeployInput;
};

export type MutationClientBillingInvoiceIssueArgs = {
  input: ClientBillingInvoiceIssueInput;
};

export type MutationClientBillingInvoiceReconcileArgs = {
  input: ClientBillingInvoiceReconcileInput;
};

export type MutationClientBillingInvoiceSendInvoiceToClientEmailArgs = {
  input: ClientBillingInvoiceSendInvoiceToClientEmailInput;
};

export type MutationClientBillingItemArchiveArgs = {
  input: ClientBillingItemArchiveInput;
};

export type MutationClientBillingItemRescheduleArgs = {
  input: ClientBillingItemRescheduleInput;
};

export type MutationClientBulkArchiveArgs = {
  input: ClientBulkArchiveInput;
};

export type MutationClientCreateArgs = {
  input: ClientCreateInput;
};

export type MutationClientGroupsUpdateArgs = {
  input: ClientGroupsUpdateInput;
};

export type MutationClientImportArgs = {
  input: ClientImportInput;
};

export type MutationClientImportCreateArgs = {
  input: ClientImportCreateInput;
};

export type MutationClientImportFromAppClientsArgs = {
  input: ClientImportFromAppClientsInput;
};

export type MutationClientPaymentMethodDeleteArgs = {
  input: ClientPaymentMethodDeleteInput;
};

export type MutationClientRemoveSignatoryArgs = {
  input: ClientRemoveSignatoryInput;
};

export type MutationClientServicesAgreedServiceCancelArgs = {
  input: ClientServicesAgreedServiceCancelInput;
};

export type MutationClientServicesAgreedServiceCreateArgs = {
  input: ClientServicesAgreedServiceCreateInput;
};

export type MutationClientServicesAgreedServiceDisableArgs = {
  input: ClientServicesAgreedServiceDisableInput;
};

export type MutationClientServicesAgreedServiceDisableAllArgs = {
  input: ClientServicesAgreedServiceDisableAllInput;
};

export type MutationClientServicesAgreedServiceRemovePaymentMethodArgs = {
  input: ClientServicesAgreedServiceRemovePaymentMethodInput;
};

export type MutationClientServicesAgreedServiceSetPaymentMethodArgs = {
  input: ClientServicesAgreedServiceSetPaymentMethodInput;
};

export type MutationClientServicesAgreedServiceUpdateArgs = {
  input: ClientServicesAgreedServiceUpdateInput;
};

export type MutationClientServicesAgreedServicesExportArgs = {
  input: ClientServicesAgreedServicesExportInput;
};

export type MutationClientSetAppMappingArgs = {
  input: ClientSetAppMappingInput;
};

export type MutationClientSetDeployInvoicesArgs = {
  input: ClientSetDeployInvoicesInput;
};

export type MutationClientSetPaymentMethodArgs = {
  input: ClientSetPaymentMethodInput;
};

export type MutationClientSetPrimaryContactArgs = {
  input: ClientSetPrimaryContactInput;
};

export type MutationClientSetTagsListArgs = {
  input: ClientSetTagsListInput;
};

export type MutationClientSurchargeDisableArgs = {
  input: ClientSurchargeDisableInput;
};

export type MutationClientSurchargeEnableArgs = {
  input: ClientSurchargeEnableInput;
};

export type MutationClientSwitchPaymentMethodArgs = {
  input: ClientSwitchPaymentMethodInput;
};

export type MutationClientUnarchiveArgs = {
  input: ClientUnarchiveInput;
};

export type MutationClientUpdateArgs = {
  input: ClientUpdateInput;
};

export type MutationClientWorkflowItemStartDeploymentArgs = {
  input: ClientWorkflowItemStartDeploymentInput;
};

export type MutationClientWorkflowStrategyCreateArgs = {
  input: ClientWorkflowStrategyCreateInput;
};

export type MutationClientWorkflowStrategyDeactivateArgs = {
  input: ClientWorkflowStrategyDeactivateInput;
};

export type MutationClientWorkflowStrategyDeleteArgs = {
  input: ClientWorkflowStrategyDeleteInput;
};

export type MutationClientWorkflowStrategyDuplicateArgs = {
  input: ClientWorkflowStrategyDuplicateInput;
};

export type MutationClientWorkflowStrategySetBillingGroupArgs = {
  input: ClientWorkflowStrategySetBillingGroupInput;
};

export type MutationClientWorkflowStrategySetClientBillingGroupArgs = {
  input: ClientWorkflowStrategySetClientBillingGroupInput;
};

export type MutationClientWorkflowStrategySetDeployStrategyArgs = {
  input: ClientWorkflowStrategySetDeployStrategyInput;
};

export type MutationClientWorkflowStrategySetGeneralSettingsArgs = {
  input: ClientWorkflowStrategySetGeneralSettingsInput;
};

export type MutationClientWorkflowStrategySetOneTimeScheduleArgs = {
  input: ClientWorkflowStrategySetOneTimeScheduleInput;
};

export type MutationClientWorkflowStrategySetRecurringScheduleArgs = {
  input: ClientWorkflowStrategySetRecurringScheduleInput;
};

export type MutationClientWorkflowStrategyUnsetBillingGroupArgs = {
  input: ClientWorkflowStrategyUnsetBillingGroupInput;
};

export type MutationCollectionsNotificationSettingsUpdateArgs = {
  input: CollectionsNotificationSettingsUpdateInput;
};

export type MutationContactUpdateArgs = {
  input: ContactUpdateInput;
};

export type MutationCustomerSuccessMaturityIndexCalculateArgs = {
  input: CustomerSuccessMaturityIndexCalculateInput;
};

export type MutationCustomerSuccessMaturityIndexUpdateIndustryArgs = {
  input: CustomerSuccessMaturityIndexUpdateIndustryInput;
};

export type MutationDashboardRevenueGrowthTargetSetArgs = {
  input: DashboardRevenueGrowthTargetSetInput;
};

export type MutationDashboardUpdateArgs = {
  input: DashboardUpdateSettingsInput;
};

export type MutationEngagementAcceptOnBehalfArgs = {
  input: EngagementAcceptOnBehalfInput;
};

export type MutationEngagementArchiveArgs = {
  input: EngagementArchiveInput;
};

export type MutationEngagementCompleteArgs = {
  input: EngagementCompleteInput;
};

export type MutationEngagementCreateArgs = {
  input: EngagementCreateInput;
};

export type MutationEngagementDeployJobsSettingUpdateArgs = {
  input: EngagementDeployJobsSettingUpdateInput;
};

export type MutationEngagementDisableContinuousBillingArgs = {
  input: EngagementDisableContinuousBillingInput;
};

export type MutationEngagementEnableContinuousBillingArgs = {
  input: EngagementEnableContinuousBillingInput;
};

export type MutationEngagementJobsSendArgs = {
  input: EngagementJobsSendInput;
};

export type MutationEngagementLetterCreateArgs = {
  input: CustomerSuccessEngagementLetterCreateInput;
};

export type MutationEngagementMarkAsLostArgs = {
  input: EngagementMarkAsLostInput;
};

export type MutationEngagementMarkForReviewArgs = {
  input: EngagementMarkForReviewInput;
};

export type MutationEngagementMoveToAwaitingAcceptanceArgs = {
  input: EngagementMoveToAwaitingAcceptanceInput;
};

export type MutationEngagementMoveToDraftArgs = {
  input: EngagementMoveToDraftInput;
};

export type MutationEngagementNameChangeArgs = {
  input: EngagementNameChangeInput;
};

export type MutationEngagementReactivateArgs = {
  input: EngagementReactivateInput;
};

export type MutationEngagementRevokeArgs = {
  input: EngagementRevokeInput;
};

export type MutationEngagementSendToClientArgs = {
  input: EngagementSendToClientInput;
};

export type MutationExportPaymentsArgs = {
  input: ExportPaymentsInput;
};

export type MutationExportProposalsArgs = {
  input: ExportProposalsInput;
};

export type MutationExportServicesArgs = {
  input: ExportServicesInput;
};

export type MutationIntroMessageTemplateCreateArgs = {
  input: IntroMessageTemplateCreateInput;
};

export type MutationIntroMessageTemplateDeleteArgs = {
  input: IntroMessageTemplateDeleteInput;
};

export type MutationIntroMessageTemplateSetDefaultArgs = {
  input: IntroMessageTemplateSetDefaultInput;
};

export type MutationIntroMessageTemplateUpdateArgs = {
  input: IntroMessageTemplateUpdateInput;
};

export type MutationIpmAuthoriseArgs = {
  input: IpmAuthoriseInput;
};

export type MutationIpmDisconnectArgs = {
  input: IpmDisconnectInput;
};

export type MutationIpmEnableArgs = {
  input: IpmEnableInput;
};

export type MutationIpmWorkTemplateMappingsConfirmArgs = {
  input: IpmWorkTemplateMappingsConfirmInput;
};

export type MutationIpmWorkTemplateMappingsUpdateArgs = {
  input: IpmWorkTemplateMappingsUpdateInput;
};

export type MutationIpmWorkTemplatesSyncAllArgs = {
  input: IpmWorkTemplatesSyncAllInput;
};

export type MutationKarbonAuthoriseArgs = {
  input: KarbonAuthoriseInput;
};

export type MutationKarbonDisconnectArgs = {
  input: KarbonDisconnectInput;
};

export type MutationKarbonEnableArgs = {
  input: KarbonEnableInput;
};

export type MutationKarbonWorkTemplateMappingsConfirmArgs = {
  input: KarbonWorkTemplateMappingsConfirmInput;
};

export type MutationKarbonWorkTemplateMappingsUpdateArgs = {
  input: KarbonWorkTemplateMappingsUpdateInput;
};

export type MutationKarbonWorkTemplatesSyncAllArgs = {
  input: KarbonWorkTemplatesSyncAllInput;
};

export type MutationNewGroupProposalEmailTemplateUpdateArgs = {
  input: NewGroupProposalEmailTemplateUpdateInput;
};

export type MutationNewProposalEmailTemplateArchiveArgs = {
  input: NewProposalEmailTemplateArchiveInput;
};

export type MutationNewProposalEmailTemplateCreateArgs = {
  input: NewProposalEmailTemplateCreateInput;
};

export type MutationNewProposalEmailTemplateUpdateArgs = {
  input: NewProposalEmailTemplateUpdateInput;
};

export type MutationNewSubmissionEmailTemplateUpdateArgs = {
  input: NewSubmissionEmailTemplateUpdateInput;
};

export type MutationNextStepsMessageTemplateCreateArgs = {
  input: NextStepsMessageTemplateCreateInput;
};

export type MutationNextStepsMessageTemplateDeleteArgs = {
  input: NextStepsMessageTemplateDeleteInput;
};

export type MutationNextStepsMessageTemplateSetDefaultArgs = {
  input: NextStepsMessageTemplateSetDefaultInput;
};

export type MutationNextStepsMessageTemplateUpdateArgs = {
  input: NextStepsMessageTemplateUpdateInput;
};

export type MutationNotificationsMarkAllReadBeforeTimeArgs = {
  input: NotificationsMarkAllReadBeforeTimeInput;
};

export type MutationNotificationsMarkAsReadArgs = {
  input: NotificationsMarkAsReadInput;
};

export type MutationNotificationsSettingsSetScopeArgs = {
  input: NotificationsSettingsSetScopeInput;
};

export type MutationNotificationsSettingsSetSettingArgs = {
  input: NotificationsSettingsSetSettingInput;
};

export type MutationNotificationsViewedArgs = {
  input: NotificationsViewedInput;
};

export type MutationPaymentCancelArgs = {
  input: PaymentCancelInput;
};

export type MutationPaymentMethodCreateFromSetupIntentArgs = {
  input: PaymentMethodCreateFromSetupIntentInput;
};

export type MutationPaymentMethodRequestCreateArgs = {
  input: PaymentMethodRequestCreateInput;
};

export type MutationPaymentRefundRequestArgs = {
  input: PaymentRefundRequestInput;
};

export type MutationPaymentScheduleCollectionArgs = {
  input: PaymentScheduleCollectionInput;
};

export type MutationPaymentStartCollectionArgs = {
  input: PaymentStartCollectionInput;
};

export type MutationPaymentUnscheduleCollectionArgs = {
  input: PaymentUnscheduleCollectionInput;
};

export type MutationPaymentsCollectionSettingsUpdateArgs = {
  input: PaymentsCollectionSettingsUpdateInput;
};

export type MutationPaymentsDisbursalAccountUpdateArgs = {
  input: PaymentsDisbursalAccountUpdateInput;
};

export type MutationPaymentsDisbursalsExportArgs = {
  input: PaymentsDisbursalsExportInput;
};

export type MutationPaymentsSendPaymentMethodRequestToClientsArgs = {
  input: SendPaymentMethodRequestToClientsInput;
};

export type MutationPaymentsSetupIntentCreateArgs = {
  input: PaymentMethodSetupIntentCreateInput;
};

export type MutationPaymentsSurchargeDisableArgs = {
  input: SurchargeDisableInput;
};

export type MutationPaymentsSurchargeEnableArgs = {
  input: SurchargeEnableInput;
};

export type MutationPaymentsTermsUpdateArgs = {
  input: PaymentsTermsUpdateInput;
};

export type MutationPracticeBillingCancelSubscriptionArgs = {
  input: PracticeBillingCancelSubscriptionInput;
};

export type MutationPracticeBillingReportPaymentChallengeErrorArgs = {
  input: PracticeBillingReportPaymentChallengeErrorInput;
};

export type MutationPracticeBillingResolvePaymentChallengeArgs = {
  input: PracticeBillingResolvePaymentChallengeInput;
};

export type MutationPracticeBillingSetSubscriptionArgs = {
  input: PracticeBillingSetSubscriptionInput;
};

export type MutationPracticeConfirmDetailsArgs = {
  input: PracticeConfirmDetailsInput;
};

export type MutationPracticeConfirmDetailsFromLedgerSsoArgs = {
  input: PracticeConfirmDetailsFromLedgerSsoInput;
};

export type MutationPracticeRetentionUrlArgs = {
  input: PracticeRetentionUrlInput;
};

export type MutationPracticeSetDefaultNewProposalEmailTemplateArgs = {
  input: PracticeSetDefaultNewProposalEmailTemplateInput;
};

export type MutationPracticeSetDefaultTaxArgs = {
  input: PracticeSetDefaultTaxInput;
};

export type MutationPracticeSetDefaultTermsTemplateArgs = {
  input: PracticeSetDefaultTermsTemplateInput;
};

export type MutationPracticeSetIntentArgs = {
  input: PracticeSetIntentInput;
};

export type MutationPracticeSetPreferredLandingPageArgs = {
  input: PracticeSetPreferredLandingPageInput;
};

export type MutationPracticeSetPreferredProposalEditorArgs = {
  input: PracticeSetPreferredProposalEditorInput;
};

export type MutationProconnectConnectArgs = {
  input: ProconnectConnectInput;
};

export type MutationProconnectDisconnectArgs = {
  input: ProconnectDisconnectInput;
};

export type MutationProposalAcceptedBrowserTemplateUpdateArgs = {
  input: ProposalAcceptedBrowserTemplateUpdateInput;
};

export type MutationProposalAcceptedEmailTemplateUpdateArgs = {
  input: ProposalAcceptedEmailTemplateUpdateInput;
};

export type MutationProposalAddDefaultWorkflowArgs = {
  input: ProposalAddDefaultWorkflowInput;
};

export type MutationProposalAddMultipleBillingServiceGroupArgs = {
  input: ProposalAddMultipleBillingServiceGroupInput;
};

export type MutationProposalAddOnAcceptanceServiceGroupArgs = {
  input: ProposalAddOnAcceptanceServiceGroupInput;
};

export type MutationProposalAddOptionArgs = {
  input: ProposalAddOptionInput;
};

export type MutationProposalAddProjectArgs = {
  input: ProposalAddProjectInput;
};

export type MutationProposalAddProposedServiceArgs = {
  input: ProposalAddProposedServiceInput;
};

export type MutationProposalAddRecipientArgs = {
  input: ProposalAddRecipientInput;
};

export type MutationProposalAddRecurringServiceGroupArgs = {
  input: ProposalAddRecurringServiceGroupInput;
};

export type MutationProposalAddServiceGroupArgs = {
  input: ProposalAddServiceGroupInput;
};

export type MutationProposalAddWorkflowStrategyArgs = {
  input: ProposalAddWorkflowStrategyInput;
};

export type MutationProposalAddWorkflowStrategyStaffArgs = {
  input: ProposalAddWorkflowStrategyStaffInput;
};

export type MutationProposalAddWorkflowStrategyTemplateArgs = {
  input: ProposalAddWorkflowStrategyTemplateInput;
};

export type MutationProposalArchiveArgs = {
  input: ProposalArchiveInput;
};

export type MutationProposalCreateArgs = {
  input: ProposalCreateInput;
};

export type MutationProposalCreateBulkArgs = {
  input: ProposalCreateBulkInput;
};

export type MutationProposalCreateWithDemoClientArgs = {
  input: ProposalCreateWithDemoClientInput;
};

export type MutationProposalCreateWithPlaceholderClientArgs = {
  input: ProposalCreateWithPlaceholderClientInput;
};

export type MutationProposalCustomTemplateCreateFromProposalArgs = {
  input: ProposalCustomTemplateCreateFromProposalInput;
};

export type MutationProposalCustomTemplateDeleteArgs = {
  input: ProposalCustomTemplateDeleteInput;
};

export type MutationProposalCustomTemplatePreviewArgs = {
  input: ProposalCustomTemplatePreviewInput;
};

export type MutationProposalCustomTemplateReplaceArgs = {
  input: ProposalCustomTemplateReplaceInput;
};

export type MutationProposalDuplicateArgs = {
  input: ProposalDuplicateInput;
};

export type MutationProposalDuplicateOptionArgs = {
  input: ProposalOptionDuplicateInput;
};

export type MutationProposalDuplicateProjectArgs = {
  input: ProposalDuplicateProjectInput;
};

export type MutationProposalDuplicateProposedServiceArgs = {
  input: ProposalDuplicateProposedServiceInput;
};

export type MutationProposalDuplicateServiceGroupArgs = {
  input: ProposalDuplicateServiceGroupInput;
};

export type MutationProposalIncreaseServicePricesArgs = {
  input: ProposalIncreaseServicePricesInput;
};

export type MutationProposalMarkAsLostArgs = {
  input: ProposalMarkAsLostInput;
};

export type MutationProposalMoveOptionArgs = {
  input: ProposalMoveOptionInput;
};

export type MutationProposalMoveProjectArgs = {
  input: ProposalMoveProjectInput;
};

export type MutationProposalMoveProposedServiceArgs = {
  input: ProposalMoveProposedServiceInput;
};

export type MutationProposalMoveServiceGroupArgs = {
  input: ProposalMoveServiceGroupInput;
};

export type MutationProposalMoveToAwaitingAcceptanceArgs = {
  input: ProposalMoveToAwaitingAcceptanceInput;
};

export type MutationProposalRefreshProposedServiceSmartQuantityArgs = {
  input: ProposalRefreshProposedServiceSmartQuantityInput;
};

export type MutationProposalRemoveOptionArgs = {
  input: ProposalRemoveOptionInput;
};

export type MutationProposalRemoveProjectArgs = {
  input: ProposalRemoveProjectInput;
};

export type MutationProposalRemoveProposedServiceArgs = {
  input: ProposalRemoveProposedServiceInput;
};

export type MutationProposalRemoveRecipientArgs = {
  input: ProposalRemoveRecipientInput;
};

export type MutationProposalRemoveServiceGroupArgs = {
  input: ProposalRemoveServiceGroupInput;
};

export type MutationProposalRemoveWorkflowStrategyArgs = {
  input: ProposalRemoveWorkflowStrategyInput;
};

export type MutationProposalRemoveWorkflowStrategyStaffArgs = {
  input: ProposalRemoveWorkflowStrategyStaffInput;
};

export type MutationProposalRemoveWorkflowStrategyTemplateArgs = {
  input: ProposalRemoveWorkflowStrategyTemplateInput;
};

export type MutationProposalRenewArgs = {
  input: ProposalRenewInput;
};

export type MutationProposalRenewBulkArgs = {
  input: ProposalRenewBulkInput;
};

export type MutationProposalResetOptionArgs = {
  input: ProposalResetOptionInput;
};

export type MutationProposalResetProjectArgs = {
  input: ProposalResetProjectInput;
};

export type MutationProposalReviewApproveArgs = {
  input: ProposalReviewApproveInput;
};

export type MutationProposalReviewRequestChangeArgs = {
  input: ProposalReviewRequestChangeInput;
};

export type MutationProposalReviewRequestReviewArgs = {
  input: ProposalReviewRequestReviewInput;
};

export type MutationProposalRevokeArgs = {
  input: ProposalRevokeInput;
};

export type MutationProposalSaveArgs = {
  input: ProposalSaveInput;
};

export type MutationProposalSendDemoArgs = {
  input: SendDemoProposalInput;
};

export type MutationProposalSendTestProposalArgs = {
  input: SendTestProposalInput;
};

export type MutationProposalSendToClientArgs = {
  input: ProposalSendToClientInput;
};

export type MutationProposalSendToClientBulkArgs = {
  input: ProposalSendToClientBulkInput;
};

export type MutationProposalSendToSignatoryArgs = {
  input: ProposalSendToSignatoryInput;
};

export type MutationProposalSetBillingGroupedByArgs = {
  input: ProposalSetBillingGroupedByInput;
};

export type MutationProposalSetBrochureArgs = {
  input: ProposalSetBrochureInput;
};

export type MutationProposalSetClientArgs = {
  input: ProposalSetClientInput;
};

export type MutationProposalSetEmailTemplateArgs = {
  input: ProposalSetEmailTemplateInput;
};

export type MutationProposalSetMinimumContractLengthArgs = {
  input: ProposalSetMinimumContractLengthInput;
};

export type MutationProposalSetNameArgs = {
  input: ProposalSetNameInput;
};

export type MutationProposalSetNextStepsMessageArgs = {
  input: ProposalSetNextStepsMessageInput;
};

export type MutationProposalSetOneTimeDateDisplayArgs = {
  input: ProposalSetOneTimeDateDisplayInput;
};

export type MutationProposalSetOptionDescriptionArgs = {
  input: ProposalOptionSetDescriptionInput;
};

export type MutationProposalSetOptionNameArgs = {
  input: ProposalOptionSetNameInput;
};

export type MutationProposalSetPaymentSettingsArgs = {
  input: ProposalSetPaymentSettingsInput;
};

export type MutationProposalSetPersonalisedMessageArgs = {
  input: ProposalSetPersonalisedMessageInput;
};

export type MutationProposalSetPostAcceptanceVideoArgs = {
  input: ProposalSetPostAcceptanceVideoInput;
};

export type MutationProposalSetPracticeAsSenderArgs = {
  input: ProposalSetPracticeAsSenderInput;
};

export type MutationProposalSetPreAcceptanceVideoArgs = {
  input: ProposalSetPreAcceptanceVideoInput;
};

export type MutationProposalSetProjectDescriptionArgs = {
  input: ProposalSetProjectDescriptionInput;
};

export type MutationProposalSetProjectNameArgs = {
  input: ProposalSetProjectNameInput;
};

export type MutationProposalSetProposalValueDisplayArgs = {
  input: ProposalSetProposalValueDisplayInput;
};

export type MutationProposalSetProposedServiceAccountArgs = {
  input: ProposalSetProposedServiceAccountInput;
};

export type MutationProposalSetProposedServiceDescriptionArgs = {
  input: ProposalSetProposedServiceDescriptionInput;
};

export type MutationProposalSetProposedServiceFixedPriceArgs = {
  input: ProposalSetProposedServiceFixedPriceInput;
};

export type MutationProposalSetProposedServiceIncludedPriceArgs = {
  input: ProposalSetProposedServiceIncludedPriceInput;
};

export type MutationProposalSetProposedServiceMinimumPriceArgs = {
  input: ProposalSetProposedServiceMinimumPriceInput;
};

export type MutationProposalSetProposedServicePortionInvoiceStrategyArgs = {
  input: ProposalSetProposedServicePortionInvoiceStrategyInput;
};

export type MutationProposalSetProposedServicePortionPriceArgs = {
  input: ProposalSetProposedServicePortionPriceInput;
};

export type MutationProposalSetProposedServicePriceRangeArgs = {
  input: ProposalSetProposedServicePriceRangeInput;
};

export type MutationProposalSetProposedServiceQuantityRuleArgs = {
  input: ProposalSetProposedServiceQuantityRuleInput;
};

export type MutationProposalSetProposedServiceTaxArgs = {
  input: ProposalSetProposedServiceTaxInput;
};

export type MutationProposalSetProposedServiceTaxExemptArgs = {
  input: ProposalSetProposedServiceTaxExemptInput;
};

export type MutationProposalSetProposedServiceUnitPriceArgs = {
  input: ProposalSetProposedServiceUnitPriceInput;
};

export type MutationProposalSetRecommendedOptionArgs = {
  input: ProposalSetRecommendedOptionInput;
};

export type MutationProposalSetServiceGroupBillingSchedulesArgs = {
  input: ProposalSetServiceGroupBillingSchedulesInput;
};

export type MutationProposalSetServicePriceDisplayArgs = {
  input: ProposalSetServicePriceDisplayInput;
};

export type MutationProposalSetSignatoriesArgs = {
  input: ProposalSetSignatoriesInput;
};

export type MutationProposalSetTaxArgs = {
  input: ProposalSetTaxInput;
};

export type MutationProposalSetTermsTemplateArgs = {
  input: ProposalSetTermsTemplateInput;
};

export type MutationProposalSetUserAsSenderArgs = {
  input: ProposalSetUserAsSenderInput;
};

export type MutationProposalSetWorkflowStrategyBudgetArgs = {
  input: ProposalSetWorkflowStrategyBudgetInput;
};

export type MutationProposalSetWorkflowStrategyCategoriesArgs = {
  input: ProposalSetWorkflowStrategyCategoriesInput;
};

export type MutationProposalSetWorkflowStrategyDescriptionArgs = {
  input: ProposalSetWorkflowStrategyDescriptionInput;
};

export type MutationProposalSetWorkflowStrategyDurationArgs = {
  input: ProposalSetWorkflowStrategyDurationInput;
};

export type MutationProposalSetWorkflowStrategyManagerArgs = {
  input: ProposalSetWorkflowStrategyManagerInput;
};

export type MutationProposalSetWorkflowStrategyNameArgs = {
  input: ProposalSetWorkflowStrategyNameInput;
};

export type MutationProposalSetWorkflowStrategyPartnerArgs = {
  input: ProposalSetWorkflowStrategyPartnerInput;
};

export type MutationProposalSetWorkflowStrategyRecurrenceOnceArgs = {
  input: ProposalSetWorkflowStrategyRecurrenceOnceInput;
};

export type MutationProposalSetWorkflowStrategyRecurringArgs = {
  input: ProposalSetWorkflowStrategyRecurringInput;
};

export type MutationProposalSetWorkflowStrategyStartOnDateArgs = {
  input: ProposalSetWorkflowStrategyStartOnDateInput;
};

export type MutationProposalSetWorkflowStrategyTemplatesArgs = {
  input: ProposalSetWorkflowStrategyTemplatesInput;
};

export type MutationProposalSignOnBehalfForAllArgs = {
  input: ProposalSignOnBehalfForAllInput;
};

export type MutationProposalStartOnAcceptanceArgs = {
  input: ProposalStartOnAcceptanceInput;
};

export type MutationProposalStartOnDateArgs = {
  input: ProposalStartOnDateInput;
};

export type MutationProposalTemplateUseArgs = {
  input: ProposalTemplateUseInput;
};

export type MutationProposalUnsetBrochureArgs = {
  input: ProposalUnsetBrochureInput;
};

export type MutationProposalUnsetRecommendedOptionArgs = {
  input: ProposalUnsetRecommendedOptionInput;
};

export type MutationProposalUnsetWorkflowStrategyManagerArgs = {
  input: ProposalUnsetWorkflowStrategyManagerInput;
};

export type MutationProposalUnsetWorkflowStrategyPartnerArgs = {
  input: ProposalUnsetWorkflowStrategyPartnerInput;
};

export type MutationProposalUpdateProposedServiceArgs = {
  input: ProposalUpdateProposedServiceInput;
};

export type MutationProposalWorkflowSettingsSetDeployStrategyArgs = {
  input: ProposalWorkflowSettingsSetDeployStrategyInput;
};

export type MutationProposalWorkflowStrategySetClientBillingGroupArgs = {
  input: ProposalWorkflowStrategySetClientBillingGroupInput;
};

export type MutationProposalWorkflowStrategySetProjectBillingGroupArgs = {
  input: ProposalWorkflowStrategySetProjectBillingGroupInput;
};

export type MutationProposalWorkflowStrategySetProposalBillingGroupArgs = {
  input: ProposalWorkflowStrategySetProposalBillingGroupInput;
};

export type MutationProposalWorkflowStrategyStartOnAcceptanceArgs = {
  input: ProposalWorkflowStrategyStartOnAcceptanceInput;
};

export type MutationProposalWorkflowStrategyStartOnProposalStartArgs = {
  input: ProposalWorkflowStrategyStartOnProposalStartInput;
};

export type MutationProposalWorkflowStrategyUnsetBillingGroupArgs = {
  input: ProposalWorkflowStrategyUnsetBillingGroupInput;
};

export type MutationProposalsExportArgs = {
  input: ProposalsExportInput;
};

export type MutationQuickbooksDisconnectArgs = {
  input: QuickbooksDisconnectInput;
};

export type MutationQuickbooksEnableArgs = {
  input: QuickbooksEnableInput;
};

export type MutationQuickbooksProposalsBulkCreateFromRecurringTransactionsArgs =
  {
    input: ProposalsBulkCreateFromRecurringTransactionsInput;
  };

export type MutationQuickbooksSettingsUpdateArgs = {
  input: QuickbooksSettingsUpdateInput;
};

export type MutationQuickbooksTaxCodeMappingCreateArgs = {
  input: QuickbooksTaxCodeMappingCreateInput;
};

export type MutationQuickbooksTaxCodeMappingsUpdateArgs = {
  input: QuickbooksTaxCodeMappingsUpdateInput;
};

export type MutationSearchExportCsvArgs = {
  input: SearchExportCsvInput;
};

export type MutationServiceAddWorkflowTemplateMappingsArgs = {
  input: ServiceAddWorkflowTemplateMappingsInput;
};

export type MutationServiceCreateArgs = {
  input: ServiceCreateInput;
};

export type MutationServiceDeleteArgs = {
  input: ServiceDeleteInput;
};

export type MutationServiceDeleteWorkflowTemplateMappingsArgs = {
  input: ServiceDeleteWorkflowTemplateMappingsInput;
};

export type MutationServiceEnhanceAiServiceDescriptionArgs = {
  input: EnhanceAiServiceDescriptionInput;
};

export type MutationServiceGenerateAiServiceDescriptionArgs = {
  input: ServiceGenerateAiServiceDescriptionInput;
};

export type MutationServiceGroupCreateArgs = {
  input: ServiceGroupCreateInput;
};

export type MutationServiceImportArgs = {
  input: ServiceImportInput;
};

export type MutationServiceRevenueExportArgs = {
  input: ServiceRevenueExportInput;
};

export type MutationServiceSetWorkflowTemplateMappingsArgs = {
  input: ServiceSetWorkflowTemplateMappingsInput;
};

export type MutationServiceTokenGenerateArgs = {
  input: ServiceTokenGenerateInput;
};

export type MutationServiceTokenRevokeArgs = {
  input: ServiceTokenRevokeInput;
};

export type MutationServiceUpdateArgs = {
  input: ServiceUpdateInput;
};

export type MutationTaxCreateArgs = {
  input: TaxCreateInput;
};

export type MutationTaxSetAppMappingsArgs = {
  input: TaxSetAppMappingsInput;
};

export type MutationTermsTemplateCreateArgs = {
  input: TermsTemplateCreateInput;
};

export type MutationTermsTemplateDeleteArgs = {
  input: TermsTemplateDeleteInput;
};

export type MutationTermsTemplateUpdateArgs = {
  input: TermsTemplateUpdateInput;
};

export type MutationUserCreateArgs = {
  input: UserCreateInput;
};

export type MutationUserDeleteArgs = {
  input: UserDeleteInput;
};

export type MutationUserInviteArgs = {
  input: UserInviteInput;
};

export type MutationUserInviteAllArgs = {
  input: UserInviteAllInput;
};

export type MutationUserLogoutArgs = {
  input: UserLogoutInput;
};

export type MutationUserPasswordUpdateArgs = {
  input: UserPasswordUpdateInput;
};

export type MutationUserRegisterReferralUrlArgs = {
  input: UserRegisterReferralUrlInput;
};

export type MutationUserResetTwoFactorAuthArgs = {
  input: UserResetTwoFactorAuthInput;
};

export type MutationUserSendReferralInviteEmailArgs = {
  input: UserSendReferralInviteEmailInput;
};

export type MutationUserSendTwoFactorAuthSmsCodeArgs = {
  input: UserSendTwoFactorAuthSmsCodeInput;
};

export type MutationUserSetAppMappingArgs = {
  input: UserSetAppMappingInput;
};

export type MutationUserUpdateArgs = {
  input: UserUpdateInput;
};

export type MutationUserUpdateWeeklySummaryEmailArgs = {
  input: UserUpdateWeeklySummaryEmailInput;
};

export type MutationUserUploadAvatarArgs = {
  input: UploadAvatarInput;
};

export type MutationXeroProposalsBulkCreateFromRepeatingInvoicesArgs = {
  input: ProposalsBulkCreateFromRepeatingInvoicesInput;
};

export type MutationXeroTaxRateMappingCreateArgs = {
  input: XeroTaxRateMappingCreateInput;
};

export type MutationXeroTaxRateMappingsUpdateArgs = {
  input: XeroTaxRateMappingsUpdateInput;
};

export type NewGroupProposalEmailTemplate = EmailTemplateInterface &
  PracticeTemplate & {
    __typename: 'NewGroupProposalEmailTemplate';
    content: Scalars['String']['output'];
    contentHtml: Scalars['String']['output'];
    createdAt: Scalars['DateTime']['output'];
    description?: Maybe<Scalars['String']['output']>;
    id: Scalars['ID']['output'];
    name: Scalars['String']['output'];
    slug: Scalars['ID']['output'];
    subject: Scalars['String']['output'];
    updatedAt: Scalars['DateTime']['output'];
  };

/** Autogenerated input type of NewGroupProposalEmailTemplateUpdate */
export type NewGroupProposalEmailTemplateUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of new group proposal email template */
  id: Scalars['ID']['input'];
  template: EmailTemplateInput;
};

/** Autogenerated return type of NewGroupProposalEmailTemplateUpdate. */
export type NewGroupProposalEmailTemplateUpdatePayload = {
  __typename: 'NewGroupProposalEmailTemplateUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<NewGroupProposalEmailTemplate>;
  templates?: Maybe<Templates>;
};

export type NewProposalEmailTemplate = EmailTemplateInterface &
  PracticeTemplate & {
    __typename: 'NewProposalEmailTemplate';
    content: Scalars['String']['output'];
    contentHtml: Scalars['String']['output'];
    createdAt: Scalars['DateTime']['output'];
    description?: Maybe<Scalars['String']['output']>;
    id: Scalars['ID']['output'];
    isDefault: Scalars['Boolean']['output'];
    name: Scalars['String']['output'];
    slug: Scalars['ID']['output'];
    subject: Scalars['String']['output'];
    updatedAt: Scalars['DateTime']['output'];
  };

/** Autogenerated input type of NewProposalEmailTemplateArchive */
export type NewProposalEmailTemplateArchiveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of new proposal email template */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of NewProposalEmailTemplateArchive. */
export type NewProposalEmailTemplateArchivePayload = {
  __typename: 'NewProposalEmailTemplateArchivePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  templates?: Maybe<Templates>;
};

/** The connection type for NewProposalEmailTemplate. */
export type NewProposalEmailTemplateConnection = {
  __typename: 'NewProposalEmailTemplateConnection';
  /** A list of edges. */
  edges: Array<NewProposalEmailTemplateEdge>;
  /** A list of nodes. */
  nodes: Array<NewProposalEmailTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of NewProposalEmailTemplateCreate */
export type NewProposalEmailTemplateCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  template: EmailTemplateInput;
};

/** Autogenerated return type of NewProposalEmailTemplateCreate. */
export type NewProposalEmailTemplateCreatePayload = {
  __typename: 'NewProposalEmailTemplateCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<NewProposalEmailTemplate>;
  templates?: Maybe<Templates>;
};

/** An edge in a connection. */
export type NewProposalEmailTemplateEdge = {
  __typename: 'NewProposalEmailTemplateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: NewProposalEmailTemplate;
};

/** Autogenerated input type of NewProposalEmailTemplateUpdate */
export type NewProposalEmailTemplateUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of new proposal email template */
  id: Scalars['ID']['input'];
  template: EmailTemplateInput;
};

/** Autogenerated return type of NewProposalEmailTemplateUpdate. */
export type NewProposalEmailTemplateUpdatePayload = {
  __typename: 'NewProposalEmailTemplateUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<NewProposalEmailTemplate>;
  templates?: Maybe<Templates>;
};

export type NewSubmissionEmailTemplate = EmailTemplateInterface &
  PracticeTemplate & {
    __typename: 'NewSubmissionEmailTemplate';
    content: Scalars['String']['output'];
    contentHtml: Scalars['String']['output'];
    createdAt: Scalars['DateTime']['output'];
    description?: Maybe<Scalars['String']['output']>;
    id: Scalars['ID']['output'];
    name: Scalars['String']['output'];
    slug: Scalars['ID']['output'];
    subject: Scalars['String']['output'];
    updatedAt: Scalars['DateTime']['output'];
  };

/** Autogenerated input type of NewSubmissionEmailTemplateUpdate */
export type NewSubmissionEmailTemplateUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of new submission email template */
  id: Scalars['ID']['input'];
  template: EmailTemplateInput;
};

/** Autogenerated return type of NewSubmissionEmailTemplateUpdate. */
export type NewSubmissionEmailTemplateUpdatePayload = {
  __typename: 'NewSubmissionEmailTemplateUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<NewSubmissionEmailTemplate>;
  templates?: Maybe<Templates>;
};

export type NextStepsMessageTemplate = PracticeTemplate & {
  __typename: 'NextStepsMessageTemplate';
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  isDefault: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  slug: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for NextStepsMessageTemplate. */
export type NextStepsMessageTemplateConnection = {
  __typename: 'NextStepsMessageTemplateConnection';
  /** A list of edges. */
  edges: Array<NextStepsMessageTemplateEdge>;
  /** A list of nodes. */
  nodes: Array<NextStepsMessageTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of NextStepsMessageTemplateCreate */
export type NextStepsMessageTemplateCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  template: TemplateInput;
};

/** Autogenerated return type of NextStepsMessageTemplateCreate. */
export type NextStepsMessageTemplateCreatePayload = {
  __typename: 'NextStepsMessageTemplateCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<NextStepsMessageTemplate>;
  templates?: Maybe<Templates>;
};

/** Autogenerated input type of NextStepsMessageTemplateDelete */
export type NextStepsMessageTemplateDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug or UUID of next steps message template */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of NextStepsMessageTemplateDelete. */
export type NextStepsMessageTemplateDeletePayload = {
  __typename: 'NextStepsMessageTemplateDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  templates?: Maybe<Templates>;
};

/** An edge in a connection. */
export type NextStepsMessageTemplateEdge = {
  __typename: 'NextStepsMessageTemplateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: NextStepsMessageTemplate;
};

/** Autogenerated input type of NextStepsMessageTemplateSetDefault */
export type NextStepsMessageTemplateSetDefaultInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of next steps message template */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of NextStepsMessageTemplateSetDefault. */
export type NextStepsMessageTemplateSetDefaultPayload = {
  __typename: 'NextStepsMessageTemplateSetDefaultPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
  templates?: Maybe<Templates>;
};

/** Autogenerated input type of NextStepsMessageTemplateUpdate */
export type NextStepsMessageTemplateUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug or UUID of next steps message template */
  id: Scalars['ID']['input'];
  template: TemplateInput;
};

/** Autogenerated return type of NextStepsMessageTemplateUpdate. */
export type NextStepsMessageTemplateUpdatePayload = {
  __typename: 'NextStepsMessageTemplateUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<NextStepsMessageTemplate>;
  templates?: Maybe<Templates>;
};

/** No discount */
export type NoneDiscountRuleInput = {
  /** Currency code, defaults to practice billing currency if not supplied */
  currency?: InputMaybe<Scalars['String']['input']>;
};

export type NotificationInput = {
  emailAddresses: Array<Scalars['EmailAddress']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  subject: Scalars['String']['input'];
};

export type NotificationsActor = {
  __typename: 'NotificationsActor';
  avatarUrl?: Maybe<Scalars['URL']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
};

/** The connection type for NotificationsNotification. */
export type NotificationsConnection = {
  __typename: 'NotificationsConnection';
  /** A list of edges. */
  edges: Array<NotificationsNotificationEdge>;
  /** A list of nodes. */
  nodes: Array<NotificationsNotification>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  unseenCount: Scalars['Int']['output'];
};

/** Type for filtering Notifications */
export type NotificationsFilter = {
  /** Notifications which occurred at or after this datetime */
  occurredAtOrAfter?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Autogenerated input type of NotificationsMarkAllReadBeforeTime */
export type NotificationsMarkAllReadBeforeTimeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Mark notifications as read which were created at or before this datetime */
  createdAtOrBefore: Scalars['DateTime']['input'];
};

/** Autogenerated return type of NotificationsMarkAllReadBeforeTime. */
export type NotificationsMarkAllReadBeforeTimePayload = {
  __typename: 'NotificationsMarkAllReadBeforeTimePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Notifications marked as read */
  notifications: Array<NotificationsNotification>;
  user: User;
};

/** Autogenerated input type of NotificationsMarkAsRead */
export type NotificationsMarkAsReadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of NotificationsMarkAsRead. */
export type NotificationsMarkAsReadPayload = {
  __typename: 'NotificationsMarkAsReadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user: User;
};

export type NotificationsNotification = {
  __typename: 'NotificationsNotification';
  actor?: Maybe<NotificationsActor>;
  body?: Maybe<Array<Scalars['String']['output']>>;
  /** When the notification record was created. Use for datetime arguments for marking as seen and read. */
  createdAt: Scalars['DateTime']['output'];
  extraDetail?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  notificationObject: NotificationsObject;
  /** When the event which triggered the notification occurred. Use for presentation. */
  occurredAt: Scalars['DateTime']['output'];
  read: Scalars['Boolean']['output'];
  title: Scalars['String']['output'];
  typeId: Scalars['String']['output'];
};

/** An edge in a connection. */
export type NotificationsNotificationEdge = {
  __typename: 'NotificationsNotificationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: NotificationsNotification;
};

export type NotificationsObject = {
  __typename: 'NotificationsObject';
  notificationObjectId?: Maybe<Scalars['ID']['output']>;
  objectType?: Maybe<NotificationsObjectType>;
  url?: Maybe<Scalars['URL']['output']>;
};

export enum NotificationsObjectType {
  PROPOSAL = 'PROPOSAL',
}

export enum NotificationsSettingsChannel {
  EMAIL = 'EMAIL',
  IN_APP = 'IN_APP',
}

export type NotificationsSettingsChannelSetting = {
  __typename: 'NotificationsSettingsChannelSetting';
  channel: NotificationsSettingsChannel;
  enabled: Scalars['Boolean']['output'];
  readonly: Scalars['Boolean']['output'];
};

export enum NotificationsSettingsGroup {
  PROPOSALS = 'PROPOSALS',
}

export enum NotificationsSettingsScope {
  ALL = 'ALL',
  ASSOCIATED = 'ASSOCIATED',
  NONE = 'NONE',
}

/** Autogenerated input type of NotificationsSettingsSetScope */
export type NotificationsSettingsSetScopeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  scope: NotificationsSettingsScope;
};

/** Autogenerated return type of NotificationsSettingsSetScope. */
export type NotificationsSettingsSetScopePayload = {
  __typename: 'NotificationsSettingsSetScopePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user: User;
};

/** Autogenerated input type of NotificationsSettingsSetSetting */
export type NotificationsSettingsSetSettingInput = {
  channel: NotificationsSettingsChannel;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  enabled: Scalars['Boolean']['input'];
  settingId: NotificationsSettingsSettingId;
};

/** Autogenerated return type of NotificationsSettingsSetSetting. */
export type NotificationsSettingsSetSettingPayload = {
  __typename: 'NotificationsSettingsSetSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user: User;
};

export type NotificationsSettingsSetting = {
  __typename: 'NotificationsSettingsSetting';
  channelSetting: Array<NotificationsSettingsChannelSetting>;
  group: NotificationsSettingsGroup;
  settingId: NotificationsSettingsSettingId;
};

export enum NotificationsSettingsSettingId {
  PROPOSAL_ACCEPTED = 'PROPOSAL_ACCEPTED',
  PROPOSAL_REVIEWS = 'PROPOSAL_REVIEWS',
}

export type NotificationsSettingsSettings = {
  __typename: 'NotificationsSettingsSettings';
  scope: NotificationsSettingsScope;
  settings: Array<NotificationsSettingsSetting>;
};

/** Autogenerated input type of NotificationsViewed */
export type NotificationsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The created at datetime of the last notification seen by the user */
  viewedAt: Scalars['DateTime']['input'];
};

/** Autogenerated return type of NotificationsViewed. */
export type NotificationsViewedPayload = {
  __typename: 'NotificationsViewedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user: User;
};

export type OembedVideo = {
  __typename: 'OembedVideo';
  html: Scalars['String']['output'];
  providerName: Scalars['String']['output'];
  thumbnailUrl?: Maybe<Scalars['URL']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};

export type Option = {
  __typename: 'Option';
  /** Description as shown to the user */
  description: Scalars['String']['output'];
  /** Option value name */
  value: Scalars['String']['output'];
};

export enum OrderBy {
  /** Sort by lowest values first. */
  ASCENDING = 'ASCENDING',
  /** Sort by highest values first. */
  DESCENDING = 'DESCENDING',
}

export type Origin = {
  __typename: 'Origin';
  id: Scalars['ID']['output'];
  sources: Array<OriginSource>;
};

export type OriginSource = {
  __typename: 'OriginSource';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  reference: Scalars['String']['output'];
  referenceNumber?: Maybe<Scalars['String']['output']>;
  type: OriginSourceTypeEnum;
};

export enum OriginSourceTypeEnum {
  CLIENT = 'CLIENT',
  ENGAGEMENT = 'ENGAGEMENT',
  PROJECT = 'PROJECT',
  PROPOSAL = 'PROPOSAL',
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']['output']>;
};

export type PaginationInput = {
  /** 1-based results page number to return */
  pageNumber: Scalars['Int']['input'];
  /** Number of results rows to return */
  pageSize: Scalars['Int']['input'];
};

export type Payment = {
  __typename: 'Payment';
  activities: ActivityLogConnection;
  amount: Money;
  availableOn?: Maybe<Scalars['Date']['output']>;
  canCancel: Scalars['Boolean']['output'];
  canCollect: Scalars['Boolean']['output'];
  canRetry: Scalars['Boolean']['output'];
  client: Client;
  collections: CollectionConnection;
  createdAt: Scalars['DateTime']['output'];
  /** Fee associated with the payment collection, null implying the payment fee has not yet been generated */
  fee?: Maybe<PaymentsFee>;
  /** @deprecated Use fee.amount instead */
  feeAmount: Money;
  id: Scalars['ID']['output'];
  invoice: ClientBillingInvoice;
  /**
   * Flag to indicate if the payment is allowed for refund.
   * Only payments in collected, disbursed or disbursing state are allowed for requesting a refund.
   */
  isRefundable: Scalars['Boolean']['output'];
  paymentMethod: PaymentMethod;
  reference: Scalars['String']['output'];
  scheduleCollectionPortalUrl: Scalars['String']['output'];
  scheduledCollectionTime?: Maybe<Scalars['DateTime']['output']>;
  state: PaymentsPaymentStateEnum;
  /** Surcharge added to the payment */
  surchargeAmount?: Maybe<Money>;
  updatedAt: Scalars['DateTime']['output'];
};

export type PaymentActivitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ActivityLogOrder>;
};

export type PaymentCollectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of PaymentCancel */
export type PaymentCancelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of payment */
  paymentId: Scalars['ID']['input'];
};

/** Autogenerated return type of PaymentCancel. */
export type PaymentCancelPayload = {
  __typename: 'PaymentCancelPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  payment: Payment;
};

/** The connection type for Payment. */
export type PaymentConnection = {
  __typename: 'PaymentConnection';
  /** A list of edges. */
  edges: Array<PaymentEdge>;
  /** A list of nodes. */
  nodes: Array<Payment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalAmount: Money;
  totalCount: Scalars['Int']['output'];
  totalFee: PaymentsFee;
};

/** An edge in a connection. */
export type PaymentEdge = {
  __typename: 'PaymentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Payment;
};

export type PaymentFilter = {
  /** ISO formatted date */
  availableOnGteq?: InputMaybe<Scalars['Date']['input']>;
  /** ISO formatted date */
  availableOnLteq?: InputMaybe<Scalars['Date']['input']>;
  /** Payments whose latest collection attempt failed. */
  latestCollectionFailed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Payments that use this payment method. */
  paymentMethodId?: InputMaybe<Scalars['ID']['input']>;
  /** Payments whose payment method is verified or not. */
  paymentMethodVerified?: InputMaybe<Scalars['Boolean']['input']>;
  stateEq?: InputMaybe<PaymentsPaymentStateEnum>;
  stateIn?: InputMaybe<Array<PaymentsPaymentStateEnum>>;
  stateNotIn?: InputMaybe<Array<PaymentsPaymentStateEnum>>;
  /** Payments which are currently scheduled to collect. */
  withScheduledCollection?: InputMaybe<Scalars['Boolean']['input']>;
  /** Payments which are not currently scheduled to collect. */
  withoutScheduledCollection?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PaymentGateway = {
  __typename: 'PaymentGateway';
  gatewayId: Scalars['String']['output'];
  paymentMethodTypes: Array<PaymentMethodType>;
  processorId: Scalars['String']['output'];
  statementDescriptor: Scalars['String']['output'];
};

/** The connection type for PaymentGateway. */
export type PaymentGatewayConnectionType = {
  __typename: 'PaymentGatewayConnectionType';
  creditCard?: Maybe<PaymentGateway>;
  directDebit?: Maybe<PaymentGateway>;
  /** A list of edges. */
  edges: Array<PaymentGatewayEdge>;
  /** A list of nodes. */
  nodes: Array<PaymentGateway>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PaymentGatewayEdge = {
  __typename: 'PaymentGatewayEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: PaymentGateway;
};

/** A method for making payments; mainly Credit Card and Direct Debit methods. */
export type PaymentMethod = {
  __typename: 'PaymentMethod';
  /** @deprecated replaced by usage of StripeJS on the frontend */
  bacsDebitMandateUrl?: Maybe<Scalars['URL']['output']>;
  createdAt: Scalars['DateTime']['output'];
  displayMethodType: Scalars['String']['output'];
  displayName: Scalars['String']['output'];
  /** ISO formatted date */
  expiryDate?: Maybe<Scalars['Date']['output']>;
  id: Scalars['ID']['output'];
  isCollecting: Scalars['Boolean']['output'];
  isDeleted: Scalars['Boolean']['output'];
  isExpired: Scalars['Boolean']['output'];
  isInUse: Scalars['Boolean']['output'];
  /** @deprecated Avoid Booleans with a built-in negation */
  isInvalid: Scalars['Boolean']['output'];
  /** Whether a surcharge will be applied when charging this payment method */
  isSurchargeEnabled: Scalars['Boolean']['output'];
  isValid: Scalars['Boolean']['output'];
  isVerified: Scalars['Boolean']['output'];
  /** Name on card (if applicable) */
  name?: Maybe<Scalars['String']['output']>;
  numberSuffix: Scalars['String']['output'];
  /** Time taken to process payment (in days). */
  processingTime: Scalars['Int']['output'];
  referenceNumber: Scalars['ID']['output'];
  /** The category by which we determine the rate of surcharge */
  surchargeCategory?: Maybe<PaymentMethodSurchargeCategory>;
  /** The rate of surcharge added to this payment method's charges to account for payment fees */
  surchargeRate: Percentage;
  type: PaymentMethodType;
  verificationUrl?: Maybe<Scalars['URL']['output']>;
};

/** Options for payment method acceptance status */
export enum PaymentMethodAcceptanceStatus {
  ACCEPTED = 'ACCEPTED',
  SUPPORTED = 'SUPPORTED',
  UNSUPPORTED = 'UNSUPPORTED',
}

/** Autogenerated input type of PaymentMethodCreateFromSetupIntent */
export type PaymentMethodCreateFromSetupIntentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Stripe ID of the setup intent */
  setupIntentStripeId: Scalars['ID']['input'];
  /** Use payment method for future invoices or not */
  useForFutureInvoices?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of PaymentMethodCreateFromSetupIntent. */
export type PaymentMethodCreateFromSetupIntentPayload = {
  __typename: 'PaymentMethodCreateFromSetupIntentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  paymentMethod: BankAccountPaymentMethod | CreditCardPaymentMethod;
};

export type PaymentMethodRequest = {
  __typename: 'PaymentMethodRequest';
  /** Is credit card accepted in the client portal link generated from this request */
  creditCardAccepted: Scalars['Boolean']['output'];
  /** Is direct debit accepted in the client portal link generated from this request */
  directDebitAccepted: Scalars['Boolean']['output'];
  /** Error message received during the processing of a payment method request. */
  errorMessage?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  mostRecentActivityAt: Scalars['DateTime']['output'];
  /** The client-accessible portal url where the payment method should be added */
  portalUrl: Scalars['URL']['output'];
  requestType: PaymentMethodRequestType;
  state: PaymentMethodRequestState;
  /** Use this payment method for future billing items */
  usePaymentMethodForFutureInvoices: Scalars['Boolean']['output'];
};

/** The connection type for PaymentMethodRequest. */
export type PaymentMethodRequestConnection = {
  __typename: 'PaymentMethodRequestConnection';
  /** A list of edges. */
  edges: Array<PaymentMethodRequestEdge>;
  /** A list of nodes. */
  nodes: Array<PaymentMethodRequest>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of PaymentMethodRequestCreate */
export type PaymentMethodRequestCreateInput = {
  /** The ID of the client for the request */
  clientId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Allowed payment methods in the client portal request */
  creditCardAccepted: Scalars['Boolean']['input'];
  /** Allowed payment methods in the client portal request */
  directDebitAccepted: Scalars['Boolean']['input'];
  /** Use this payment method for future billing items */
  useMethodInFuture: Scalars['Boolean']['input'];
};

/** Autogenerated return type of PaymentMethodRequestCreate. */
export type PaymentMethodRequestCreatePayload = {
  __typename: 'PaymentMethodRequestCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  paymentMethodRequest: PaymentMethodRequest;
};

/** An edge in a connection. */
export type PaymentMethodRequestEdge = {
  __typename: 'PaymentMethodRequestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: PaymentMethodRequest;
};

export type PaymentMethodRequestFilter = {
  requestTypeEq?: InputMaybe<PaymentMethodRequestType>;
};

export type PaymentMethodRequestGroup = {
  __typename: 'PaymentMethodRequestGroup';
  clients: Array<Client>;
  /** Is credit card accepted in the client portal link generated from this request */
  creditCardAccepted: Scalars['Boolean']['output'];
  /** Is direct debit accepted in the client portal link generated from this request */
  directDebitAccepted: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** Message text included in the notification to the client */
  messageText: Scalars['String']['output'];
  /** Use this payment method for future billing items */
  useMethodInFuture: Scalars['Boolean']['output'];
};

export enum PaymentMethodRequestState {
  ACTIONED = 'ACTIONED',
  FAILED = 'FAILED',
  PENDING = 'PENDING',
  SENT = 'SENT',
}

export enum PaymentMethodRequestType {
  EMAIL = 'EMAIL',
  SHARED_LINK = 'SHARED_LINK',
}

/** Autogenerated input type of PaymentMethodSetupIntentCreate */
export type PaymentMethodSetupIntentCreateInput = {
  /** The client id of the setup intent */
  clientId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Type of payment method */
  scopeId?: InputMaybe<Scalars['ID']['input']>;
  /** Type of transaction */
  transactionType?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of PaymentMethodSetupIntentCreate. */
export type PaymentMethodSetupIntentCreatePayload = {
  __typename: 'PaymentMethodSetupIntentCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  clientSecret: Scalars['String']['output'];
};

/** Options for payment method surcharge category */
export enum PaymentMethodSurchargeCategory {
  CREDIT_CARD = 'CREDIT_CARD',
  DEBIT_CARD = 'DEBIT_CARD',
  PREPAID_CARD = 'PREPAID_CARD',
  UNKNOWN_CARD = 'UNKNOWN_CARD',
}

export enum PaymentMethodType {
  BANK_ACCOUNT = 'BANK_ACCOUNT',
  CREDIT_CARD = 'CREDIT_CARD',
}

export type PaymentNotificationSettings = {
  __typename: 'PaymentNotificationSettings';
  sendNotifications: Scalars['Boolean']['output'];
  tenantId: Scalars['ID']['output'];
  useDefaultSettings: Scalars['Boolean']['output'];
};

/** Autogenerated input type of PaymentRefundRequest */
export type PaymentRefundRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Payment ID */
  paymentId: Scalars['ID']['input'];
  /** Reason for the return */
  reason: Scalars['String']['input'];
};

/** Autogenerated return type of PaymentRefundRequest. */
export type PaymentRefundRequestPayload = {
  __typename: 'PaymentRefundRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  refund?: Maybe<PaymentsRefund>;
};

/** Autogenerated input type of PaymentScheduleCollection */
export type PaymentScheduleCollectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Invoice slug */
  invoiceId: Scalars['ID']['input'];
  /** Payment method slug */
  paymentMethodId: Scalars['ID']['input'];
  /** Time to start collection */
  time: Scalars['DateTime']['input'];
};

/** Autogenerated return type of PaymentScheduleCollection. */
export type PaymentScheduleCollectionPayload = {
  __typename: 'PaymentScheduleCollectionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  payment: Payment;
};

export type PaymentSettings = {
  __typename: 'PaymentSettings';
  /** State of payments collections setting */
  collectionsState: PaymentsCollectionsSettingState;
  /** Acceptance status for credit card payments */
  creditCardAcceptance: PaymentMethodAcceptanceStatus;
  /** Acceptance status for direct debit payments */
  directDebitAcceptance: PaymentMethodAcceptanceStatus;
  /** The bank account for disbursal */
  disbursalAccount?: Maybe<BankAccount>;
  /** Disbursals Disablement Type */
  disbursalsDisablementType?: Maybe<DisbursalsDisablementType>;
  /** State of payments disbursals setting */
  disbursalsState: PaymentsDisbursalsSettingState;
  /** ID of current payments settings */
  id: Scalars['ID']['output'];
  /** Are disbursals enabled? */
  isDisbursalsEnabled: Scalars['Boolean']['output'];
  /** Whether Stripe has rejected the account */
  isRejected: Scalars['Boolean']['output'];
  /** Whether surcharges are restricted to only the 'credit_card' surcharge category */
  isSurchargeCreditCardsOnly: Scalars['Boolean']['output'];
  /** Whether a practice can use surcharges to pass on payment fees to their clients */
  isSurchargeEnabled: Scalars['Boolean']['output'];
  /** State of payments onboarding */
  onboardingState: PaymentsOnboardingState;
  /** Indicates whether the customer allows online payments */
  onlinePaymentAllowed: Scalars['Boolean']['output'];
  /** Indicates whether he customer require a client to attach a payment method to proposals on acceptance */
  paymentMethodRequired: Scalars['Boolean']['output'];
  /** Description of the most recent change to surcharge settings */
  surchargeLastUpdateMessage?: Maybe<Scalars['String']['output']>;
  /** Rate at which applicable cards are surcharged */
  surchargeRate: Percentage;
  /** Date by which verification is required to keep the account enabled */
  verificationDeadline?: Maybe<Scalars['DateTime']['output']>;
};

/** Autogenerated input type of PaymentStartCollection */
export type PaymentStartCollectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Invoice slug */
  invoiceId: Scalars['ID']['input'];
  /** Slug of payment method */
  paymentMethodId: Scalars['ID']['input'];
};

/** Autogenerated return type of PaymentStartCollection. */
export type PaymentStartCollectionPayload = {
  __typename: 'PaymentStartCollectionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  payment?: Maybe<Payment>;
};

/** Autogenerated input type of PaymentUnscheduleCollection */
export type PaymentUnscheduleCollectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of payment */
  paymentId: Scalars['ID']['input'];
};

/** Autogenerated return type of PaymentUnscheduleCollection. */
export type PaymentUnscheduleCollectionPayload = {
  __typename: 'PaymentUnscheduleCollectionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  payment: Payment;
};

export type Payments = {
  __typename: 'Payments';
  /**
   * Information about payments collected from clients on behalf of this practice
   * @deprecated Use isEnabled or isSupported on payments object
   */
  collections?: Maybe<Collections>;
  /** Whether this practice is collecting payments via credit card */
  creditCardAccepted: Scalars['Boolean']['output'];
  /** Whether credit card payments are active in this practice's Stripe account */
  creditCardAvailable: Scalars['Boolean']['output'];
  /** Whether credit card payments are supported in this practice's region */
  creditCardSupported: Scalars['Boolean']['output'];
  /** Whether this practice is collecting payments via direct debit */
  directDebitAccepted: Scalars['Boolean']['output'];
  /** Whether direct debit payments are active in this practice's Stripe account */
  directDebitAvailable: Scalars['Boolean']['output'];
  /** Whether direct debit payments are supported in this practice's region */
  directDebitSupported: Scalars['Boolean']['output'];
  /** Information about money disbursed to this practice */
  disbursals?: Maybe<Disbursals>;
  /**
   * Whether the user needs to go through an external process with a payment
   * processing partner to give extra information to the payment processor
   */
  externalVerificationRequired: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** Whether payments can currently be collected */
  isEnabled: Scalars['Boolean']['output'];
  /** Whether payments can be enabled */
  isSupported: Scalars['Boolean']['output'];
  /** Number of days a payment will be collected after an invoice for one-off payment is raised */
  onceOffTerms: Scalars['Int']['output'];
  /** Whether this practice is allowing online payment */
  onlinePaymentAllowed: Scalars['Boolean']['output'];
  /** Renders a HTML Payment Method Request email, with generic placeholders */
  paymentMethodRequestEmailPreview: EmailPreview;
  /** Whether this practice requires a valid payment method from a client when a proposal is accepted */
  paymentMethodRequired: Scalars['Boolean']['output'];
  /** Number of days a payment will be collected after an invoice for a recurring payment is raised */
  recurringTerms: Scalars['Int']['output'];
  /** Locale specific text strings for payment related phrases */
  translations: PaymentsTranslations;
};

export type PaymentsPaymentMethodRequestEmailPreviewArgs = {
  message: Scalars['String']['input'];
  to?: InputMaybe<Array<Scalars['EmailAddress']['input']>>;
};

export enum PaymentsClawbackState {
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  STARTED = 'STARTED',
}

/** Autogenerated input type of PaymentsCollectionSettingsUpdate */
export type PaymentsCollectionSettingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  creditCardAccepted: Scalars['Boolean']['input'];
  directDebitAccepted: Scalars['Boolean']['input'];
  onlinePaymentAllowed?: InputMaybe<Scalars['Boolean']['input']>;
  paymentMethodRequired: Scalars['Boolean']['input'];
};

/** Autogenerated return type of PaymentsCollectionSettingsUpdate. */
export type PaymentsCollectionSettingsUpdatePayload = {
  __typename: 'PaymentsCollectionSettingsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  payments?: Maybe<Payments>;
  /** @deprecated Use payments instead */
  practice: Practice;
};

export enum PaymentsCollectionState {
  AUTHENTICATION_REQUIRED = 'AUTHENTICATION_REQUIRED',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  STARTED = 'STARTED',
}

export enum PaymentsCollectionsSettingState {
  /** Customer is enabled to collect payments from their clients */
  ENABLED = 'ENABLED',
  /** Customer has been disabled by our provider for collecting payments */
  PROVIDER_CHARGES_DISABLED = 'PROVIDER_CHARGES_DISABLED',
  /** Customer requires onboarding with our payments provider before they can collect payments from clients */
  PROVIDER_ONBOARDING_REQUIRED = 'PROVIDER_ONBOARDING_REQUIRED',
  /** Customer requires a valid Ignition subscription before collecting payments from clients */
  SUBSCRIPTION_EXPIRED = 'SUBSCRIPTION_EXPIRED',
}

/** Autogenerated input type of PaymentsDisbursalAccountUpdate */
export type PaymentsDisbursalAccountUpdateInput = {
  accountName: Scalars['String']['input'];
  accountNumber: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  descriptor: Scalars['String']['input'];
  routingNumber: Scalars['String']['input'];
};

/** Autogenerated return type of PaymentsDisbursalAccountUpdate. */
export type PaymentsDisbursalAccountUpdatePayload = {
  __typename: 'PaymentsDisbursalAccountUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  disbursals?: Maybe<Disbursals>;
  /** @deprecated Use disbursals instead */
  practice: Practice;
};

export type PaymentsDisbursalDispute = {
  __typename: 'PaymentsDisbursalDispute';
  amount: Money;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** Payment associated with the dispute */
  payment: Payment;
  state: PaymentsDisputeState;
};

/** The connection type for PaymentsDisbursalDispute. */
export type PaymentsDisbursalDisputeConnection = {
  __typename: 'PaymentsDisbursalDisputeConnection';
  /** A list of edges. */
  edges: Array<PaymentsDisbursalDisputeEdge>;
  /** A list of nodes. */
  nodes: Array<PaymentsDisbursalDispute>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalAmount: Money;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PaymentsDisbursalDisputeEdge = {
  __typename: 'PaymentsDisbursalDisputeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: PaymentsDisbursalDispute;
};

export enum PaymentsDisbursalStateEnum {
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  STARTED = 'STARTED',
}

export enum PaymentsDisbursalsExport {
  /** For creating a report with clawbacks and collections individually listed */
  PAYMENTS_CLAWBACKS_COLLECTIONS = 'PAYMENTS_CLAWBACKS_COLLECTIONS',
  /** For creating a report of disbursal totals (e.g. total of all clawbacks and collections per disbursal) */
  PAYMENTS_DISBURSALS = 'PAYMENTS_DISBURSALS',
}

/** Autogenerated input type of PaymentsDisbursalsExport */
export type PaymentsDisbursalsExportInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ISO formatted date */
  endDate?: InputMaybe<Scalars['Date']['input']>;
  exportType: PaymentsDisbursalsExport;
  /** ISO formatted date */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Autogenerated return type of PaymentsDisbursalsExport. */
export type PaymentsDisbursalsExportPayload = {
  __typename: 'PaymentsDisbursalsExportPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  export: Export;
};

export enum PaymentsDisbursalsSettingState {
  /** Customer has updated their disbursal account information and require F&R checks to have disbursals enabled */
  DISBURSAL_ACCOUNT_CHANGED = 'DISBURSAL_ACCOUNT_CHANGED',
  /** Customer is enabled to have money disbursed to their allocated account */
  ENABLED = 'ENABLED',
  /** Customer is pending F&R checks to enable disbursals */
  FRAUD_DETECTION = 'FRAUD_DETECTION',
  /** Customer requires F&R checks to enable disbursals */
  KYC_REQUIRED = 'KYC_REQUIRED',
  /** Customer must complete provider verification steps before enablement of disbursals */
  PROVIDER_PAYOUTS_DISABLED = 'PROVIDER_PAYOUTS_DISABLED',
  /** Customer has been rejected as a suitable candidate for Ignition Payments */
  REJECTED_BY_STAFF = 'REJECTED_BY_STAFF',
  /** Customer requires an active Ignition subscription to enable disbursals */
  SUBSCRIPTION_EXPIRED = 'SUBSCRIPTION_EXPIRED',
}

export enum PaymentsDisputeState {
  LOST = 'LOST',
  STARTED = 'STARTED',
  WON = 'WON',
}

/** Additional expenses added to the price of a transaction */
export type PaymentsFee = {
  __typename: 'PaymentsFee';
  /** A amount per charge */
  amount?: Maybe<Money>;
  /** The description of the fee based on */
  description?: Maybe<Scalars['String']['output']>;
};

export type PaymentsNotificationsRecipientGroup = {
  __typename: 'PaymentsNotificationsRecipientGroup';
  emailAddresses: Array<Scalars['EmailAddress']['output']>;
};

export enum PaymentsOnboardingState {
  /** Customer has onboarded to all provider and Ignition requested steps */
  COMPLETED = 'COMPLETED',
  /**
   * Customer is required to complete Ignition Onboarding with our F&R team before
   * being enabled for all Ignition Payments features
   */
  ONBOARDING_REQUIRED = 'ONBOARDING_REQUIRED',
  /** Customer is required to complete provider onboarding before using Ignition Payments */
  PROVIDER_ONBOARDING_REQUIRED = 'PROVIDER_ONBOARDING_REQUIRED',
}

/** An interface type for payment method */
export type PaymentsPaymentMethod = {
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  isInUse: Scalars['Boolean']['output'];
  isInvalid: Scalars['Boolean']['output'];
  name?: Maybe<Scalars['String']['output']>;
  numberSuffix: Scalars['String']['output'];
  referenceNumber: Scalars['ID']['output'];
  verified: Scalars['Boolean']['output'];
};

export enum PaymentsPaymentStateEnum {
  CANCELLED = 'CANCELLED',
  CLAWING_BACK = 'CLAWING_BACK',
  COLLECTED = 'COLLECTED',
  COLLECTING = 'COLLECTING',
  DISBURSED = 'DISBURSED',
  DISBURSING = 'DISBURSING',
  REFUNDED = 'REFUNDED',
  REFUNDING = 'REFUNDING',
  UNCOLLECTED = 'UNCOLLECTED',
}

export type PaymentsRefund = {
  __typename: 'PaymentsRefund';
  amount: Money;
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  message?: Maybe<Scalars['String']['output']>;
  payment: Payment;
  reason?: Maybe<Scalars['String']['output']>;
  startedAt?: Maybe<Scalars['DateTime']['output']>;
  state: PaymentsRefundState;
  updatedAt: Scalars['DateTime']['output'];
};

export enum PaymentsRefundState {
  APPROVED = 'APPROVED',
  COMPLETED = 'COMPLETED',
  DECLINED = 'DECLINED',
  FAILED = 'FAILED',
  PENDING = 'PENDING',
  STARTED = 'STARTED',
}

/** Autogenerated input type of PaymentsTermsUpdate */
export type PaymentsTermsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  onceOffTerms?: InputMaybe<Scalars['Int']['input']>;
  recurringTerms?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of PaymentsTermsUpdate. */
export type PaymentsTermsUpdatePayload = {
  __typename: 'PaymentsTermsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  payments: Payments;
  /** @deprecated Use payments instead */
  practice: Practice;
};

export type PaymentsTranslations = {
  __typename: 'PaymentsTranslations';
  accountNumber: Scalars['String']['output'];
  directDebit: Scalars['String']['output'];
  routingNumber: Scalars['String']['output'];
};

/** Discount specified as a percentage */
export type PercentDiscountRuleInput = {
  percentage?: InputMaybe<PercentageInput>;
};

export type Percentage = {
  __typename: 'Percentage';
  format: Scalars['String']['output'];
  value: Scalars['Decimal']['output'];
};

export type PercentageInput = {
  /** Value as a percentage, e.g. 10% */
  percentage?: InputMaybe<Scalars['Float']['input']>;
  /** Percentage as a value, e.g. 0.1 */
  value?: InputMaybe<Scalars['Float']['input']>;
};

export type Placeholder = {
  __typename: 'Placeholder';
  /** Description of the placeholder */
  description: Scalars['String']['output'];
  /** id of the placeholder */
  id: Scalars['String']['output'];
  /** Name of placeholder for users */
  name: Scalars['String']['output'];
  /** Path used by Liquid to render the value */
  path: Scalars['String']['output'];
  /** A hard-coded sample value for this placeholder */
  sampleValue?: Maybe<Scalars['String']['output']>;
  /** State of the placeholder */
  state: PlaceholderState;
  /** The actual value when a scope is provided */
  value?: Maybe<Scalars['String']['output']>;
};

export enum PlaceholderState {
  AVAILABLE = 'AVAILABLE',
  DEPRECATED = 'DEPRECATED',
}

export type Plan = {
  __typename: 'Plan';
  billingPeriod: PlanBillingPeriod;
  code: Scalars['String']['output'];
  /** An HTML snippet about the direct debit */
  directDebit?: Maybe<Scalars['Html']['output']>;
  /**
   * An unsafe HTML friendly description of some of the plan features
   * @deprecated Use the safe_features field instead
   */
  features?: Maybe<HtmlText>;
  /** A boolean telling us this plan isn't used anymore */
  isLegacy: Scalars['Boolean']['output'];
  /** Name of plan that is used for display */
  name: Scalars['String']['output'];
  /**
   * A HTML friendly description of some of the plan features
   * @deprecated use features instead
   */
  planFeatures?: Maybe<HtmlText>;
  /** An integer describing the plan's ordinal position. */
  position: Scalars['Int']['output'];
  price: Money;
  priceMonthly: Money;
  /** A short description of the plan. (subtitle perhaps) */
  shortDescription?: Maybe<Scalars['String']['output']>;
  /** A html friendly description of the support on offer */
  support?: Maybe<Scalars['Html']['output']>;
  taxCode: Scalars['String']['output'];
  /** Plan tier that practice is on */
  tier: PlanNameEnum;
  /** The date of the plan as a string */
  version: Scalars['String']['output'];
};

export enum PlanBillingPeriod {
  /** Billed annually */
  ANNUALLY = 'ANNUALLY',
  /** Billed monthly */
  MONTHLY = 'MONTHLY',
}

/** The connection type for Plan. */
export type PlanConnection = {
  __typename: 'PlanConnection';
  /** A list of edges. */
  edges: Array<PlanEdge>;
  /** A list of nodes. */
  nodes: Array<Plan>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PlanEdge = {
  __typename: 'PlanEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Plan;
};

export enum PlanNameEnum {
  BOOKKEEPER = 'BOOKKEEPER',
  CORE = 'CORE',
  /** Legacy plan */
  JUPITER = 'JUPITER',
  /** Legacy plan */
  MARS = 'MARS',
  /** Legacy plan */
  NEPTUNE = 'NEPTUNE',
  NONE = 'NONE',
  PRO = 'PRO',
  PROFESSIONAL = 'PROFESSIONAL',
  PROPLUS = 'PROPLUS',
  /** Legacy plan */
  SATURN = 'SATURN',
  SCALE = 'SCALE',
  STARTER = 'STARTER',
  TRIAL = 'TRIAL',
}

export enum PlanVersion {
  JUNE_2015 = 'JUNE_2015',
  JUNE_2018 = 'JUNE_2018',
  MAY_2014 = 'MAY_2014',
  NOV_2023 = 'NOV_2023',
}

export type Portion = {
  __typename: 'Portion';
  billingSchedule:
    | ProposalOnceOffBillingSchedule
    | ProposalRecurringBillingSchedule;
  description?: Maybe<Scalars['String']['output']>;
  discount:
    | BillingAmountDiscountRule
    | BillingNoneDiscountRule
    | BillingPercentDiscountRule;
  id: Scalars['ID']['output'];
  invoiceStrategy: ProposalInvoiceStrategy;
  percentage?: Maybe<Scalars['Decimal']['output']>;
  /** the one-based position of this portion in the proposed service */
  position: Scalars['Int']['output'];
  price:
    | ProposalFixedPrice
    | ProposalIncludedPrice
    | ProposalMinimumPrice
    | ProposalPriceRange
    | ProposalUnitPrice;
  proposedService: ProposedService;
};

export type PortionInput = {
  billingSchedule: BillingScheduleInputType;
  id?: InputMaybe<Scalars['ID']['input']>;
  invoiceStrategy: ProposalInvoiceStrategy;
  price: ServicePriceRuleInput;
};

export type Practice = {
  __typename: 'Practice';
  billing: PracticeBilling;
  /** Currency used for billing clients */
  billingCurrency: Currency;
  clientDefaultEmailSettings: Array<EmailSettings>;
  /** List of revenue brackets for cmi questions based on the current practice region */
  cmiRevenueBrackets: Array<RevenueBracket>;
  countryCode: Scalars['CountryCode']['output'];
  createdAt: Scalars['DateTime']['output'];
  creator: User;
  /** Current financial year of the practice. */
  currentFinancialYear: Scalars['Int']['output'];
  customerSuccessMaturityIndex?: Maybe<CustomerSuccessMaturityIndexUnion>;
  defaultBillingGroupedBy: ProposalBillingGroupedBy;
  defaultIntroMessageTemplate?: Maybe<IntroMessageTemplate>;
  defaultNewProposalEmailTemplate?: Maybe<NewProposalEmailTemplate>;
  defaultNextStepsMessageTemplate?: Maybe<NextStepsMessageTemplate>;
  defaultTax: Tax;
  defaultTermsTemplate?: Maybe<TermsTemplate>;
  emailAddress: Scalars['EmailAddress']['output'];
  /** Default settings for Engagements (CPE Proposals) */
  engagementSettings: PracticeEngagementSettings;
  features: FeatureConnection;
  /** The month number of the start of the financial year (Jan = 1). */
  financialYearStart: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  intent: PracticeIntentEnum;
  isBillable: Scalars['Boolean']['output'];
  locale?: Maybe<Scalars['String']['output']>;
  logo?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  /** When the notification for plan upgrade was sent */
  notifiedOfImminentPlanUpgradeOn?: Maybe<Scalars['Date']['output']>;
  paymentDescriptor?: Maybe<Scalars['String']['output']>;
  paymentRegion?: Maybe<Scalars['String']['output']>;
  paymentSettings: PaymentSettings;
  preferredLandingPage?: Maybe<PreferredLandingPage>;
  preferredProposalEditor?: Maybe<PreferredProposalEditor>;
  principal: User;
  referenceNumber: Scalars['ID']['output'];
  /** The referral copy to be displayed for the practice based on region */
  referralCopy?: Maybe<CustomerSuccessReferralCopy>;
  referralMethod?: Maybe<Scalars['String']['output']>;
  signupPhone?: Maybe<Scalars['PhoneNumber']['output']>;
  stripePublishableKey?: Maybe<Scalars['String']['output']>;
  /** Boolean flag to control whether we show or hide the SCA form on Gizmo */
  stripeSca: Scalars['Boolean']['output'];
  subscriptionAccountCode?: Maybe<Scalars['String']['output']>;
  /** Currency used for the practice subscription */
  subscriptionCurrency: Currency;
  taxDisplay: TaxDisplay;
  taxTypeLabel?: Maybe<Scalars['String']['output']>;
  tfaEffectiveFrom?: Maybe<Scalars['Date']['output']>;
  timeZone: TimeZone;
  token?: Maybe<PublicToken>;
  trialEndDate?: Maybe<Scalars['Date']['output']>;
  twoFactorAuthRequired: Scalars['Boolean']['output'];
  updatedAt: Scalars['DateTime']['output'];
  worldRegion: Scalars['String']['output'];
};

export type PracticeFeaturesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeBilling = {
  __typename: 'PracticeBilling';
  /** The last day for an arrear account to pay before account is expired */
  arrearsDueDate?: Maybe<Scalars['Date']['output']>;
  /** flag indicating payment for the account is overdue */
  arrearsStatus?: Maybe<PracticeBillingArrearsStatus>;
  availablePlans: Array<PracticeBillingPlan>;
  billingInfo?: Maybe<PracticeBillingBillingInfo>;
  /** Test coupons for validity */
  couponsTest?: Maybe<Array<PracticeBillingCouponTest>>;
  currentSubscription: PracticeBillingSubscription;
  /** Eligible plans for coupon redemption. */
  eligibleBillingPlans?: Maybe<Array<PracticeBillingEligibleBillingPlan>>;
  invoices: PracticeBillingInvoiceConnection;
  paymentChallenge?: Maybe<PracticeBillingPaymentChallenge>;
  paymentMethods: Array<PracticeBillingPaymentMethod>;
  /** Preview of practice's billing subscription. */
  subscriptionPreview?: Maybe<PracticeBillingSubscription>;
};

export type PracticeBillingCouponsTestArgs = {
  couponCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  plan: PracticeBillingPlanInput;
};

export type PracticeBillingEligibleBillingPlansArgs = {
  couponCode: Scalars['String']['input'];
};

export type PracticeBillingInvoicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeBillingSubscriptionPreviewArgs = {
  couponCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  plan: PracticeBillingPlanInput;
};

export type PracticeBillingAddress = {
  __typename: 'PracticeBillingAddress';
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  lines: Array<Scalars['String']['output']>;
  postcode?: Maybe<Scalars['String']['output']>;
  state?: Maybe<Scalars['String']['output']>;
};

export type PracticeBillingAddressInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  lines?: InputMaybe<Array<Scalars['String']['input']>>;
  postcode?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
};

export enum PracticeBillingArrearsStatus {
  ARREARS = 'ARREARS',
  PAID = 'PAID',
}

export type PracticeBillingBillingInfo = {
  __typename: 'PracticeBillingBillingInfo';
  address?: Maybe<PracticeBillingAddress>;
  email?: Maybe<Scalars['EmailAddress']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['PhoneNumber']['output']>;
};

export type PracticeBillingBillingInfoInput = {
  address?: InputMaybe<PracticeBillingAddressInput>;
  email?: InputMaybe<Scalars['EmailAddress']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['PhoneNumber']['input']>;
};

export type PracticeBillingClientProduct = PracticeBillingProduct & {
  __typename: 'PracticeBillingClientProduct';
  category: PracticeBillingProductCategory;
  description: Scalars['String']['output'];
  limit: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  price: PracticeBillingMoneyPrice;
};

export type PracticeBillingCoupon = {
  __typename: 'PracticeBillingCoupon';
  code: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  /** The discount amount to display to the user */
  displayDiscount: Scalars['String']['output'];
  expiryDate?: Maybe<Scalars['Date']['output']>;
  type: Scalars['String']['output'];
};

export type PracticeBillingCouponTest = {
  __typename: 'PracticeBillingCouponTest';
  code: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  invalidReason?: Maybe<Scalars['String']['output']>;
  isValid: Scalars['Boolean']['output'];
};

/** A billing plan with the coupon code it's eligible for */
export type PracticeBillingEligibleBillingPlan = {
  __typename: 'PracticeBillingEligibleBillingPlan';
  /** Combination of specific tier and frequency ie. '2018-professional-monthly' */
  code?: Maybe<Scalars['String']['output']>;
  couponCode: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  /** The billing frequency of the plan ie. monthly, annually */
  frequency?: Maybe<Scalars['String']['output']>;
  /** Name of plan that is used for display */
  name: Scalars['String']['output'];
};

export type PracticeBillingInvoice = {
  __typename: 'PracticeBillingInvoice';
  amount: Money;
  amountWithTax: Money;
  createdOn: Scalars['Date']['output'];
  id: Scalars['ID']['output'];
  items: Array<PracticeBillingInvoiceItem>;
  pdfUrl: Scalars['URL']['output'];
  reference: Scalars['String']['output'];
  status: PracticeBillingInvoiceStatus;
  taxAmount: Money;
};

/** The connection type for PracticeBillingInvoice. */
export type PracticeBillingInvoiceConnection = {
  __typename: 'PracticeBillingInvoiceConnection';
  /** A list of edges. */
  edges: Array<PracticeBillingInvoiceEdge>;
  /** A list of nodes. */
  nodes: Array<PracticeBillingInvoice>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PracticeBillingInvoiceEdge = {
  __typename: 'PracticeBillingInvoiceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: PracticeBillingInvoice;
};

export type PracticeBillingInvoiceItem = {
  __typename: 'PracticeBillingInvoiceItem';
  amount: Money;
  amountWithTax: Money;
  description: Scalars['String']['output'];
  position: Scalars['Int']['output'];
  quantity?: Maybe<Scalars['Int']['output']>;
  taxAmount: Money;
  unitPrice: Money;
};

export enum PracticeBillingInvoiceStatus {
  PAID = 'PAID',
  UNPAID = 'UNPAID',
}

export type PracticeBillingMoneyPrice = {
  __typename: 'PracticeBillingMoneyPrice';
  discount?: Maybe<Money>;
  exTax: Money;
  original: Money;
};

export type PracticeBillingOtherProduct = PracticeBillingProduct & {
  __typename: 'PracticeBillingOtherProduct';
  category: PracticeBillingProductCategory;
  description: Scalars['String']['output'];
  limit?: Maybe<Scalars['Int']['output']>;
  name: Scalars['String']['output'];
};

export type PracticeBillingPaymentChallenge = {
  __typename: 'PracticeBillingPaymentChallenge';
  app: App;
  id: Scalars['ID']['output'];
  /** Integration specific token to resolve this challenge */
  token: Scalars['String']['output'];
  type: PracticeBillingPaymentChallengeTypeEnum;
};

export enum PracticeBillingPaymentChallengeTypeEnum {
  SECURE_3D_2 = 'SECURE_3D_2',
}

export type PracticeBillingPaymentFeeProduct = PracticeBillingProduct & {
  __typename: 'PracticeBillingPaymentFeeProduct';
  category: PracticeBillingProductCategory;
  description: Scalars['String']['output'];
  name: Scalars['String']['output'];
  percentagePrice: PracticeBillingPercentagePrice;
  price: PracticeBillingMoneyPrice;
};

export type PracticeBillingPaymentMethod = {
  __typename: 'PracticeBillingPaymentMethod';
  cardType: Scalars['String']['output'];
  expiryMonth: Scalars['String']['output'];
  expiryYear: Scalars['String']['output'];
  firstSix?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lastFour?: Maybe<Scalars['String']['output']>;
};

export type PracticeBillingPaymentMethodInput = {
  appName: Scalars['String']['input'];
  token: Scalars['String']['input'];
};

export type PracticeBillingPercentagePrice = {
  __typename: 'PracticeBillingPercentagePrice';
  discount?: Maybe<Percentage>;
  exTax: Percentage;
  original: Percentage;
};

export type PracticeBillingPlan = {
  __typename: 'PracticeBillingPlan';
  /** Combination of specific tier and frequency ie. '2018-professional-monthly' */
  code?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  isCustom: Scalars['Boolean']['output'];
  isLegacy: Scalars['Boolean']['output'];
  /** Name of plan that is used for display */
  name: Scalars['String']['output'];
  products: Array<
    | PracticeBillingClientProduct
    | PracticeBillingOtherProduct
    | PracticeBillingPaymentFeeProduct
    | PracticeBillingPlanProduct
  >;
  /** Plan tier that practice is on */
  tier: PracticeBillingPlanNameEnum;
};

export type PracticeBillingPlanProductsArgs = {
  filter?: InputMaybe<PracticeBillingProductFilter>;
};

export enum PracticeBillingPlanFrequency {
  ANNUALLY = 'ANNUALLY',
  MONTHLY = 'MONTHLY',
}

export type PracticeBillingPlanInput = {
  frequency: PracticeBillingPlanFrequency;
  id: Scalars['ID']['input'];
};

export enum PracticeBillingPlanNameEnum {
  BOOKKEEPER = 'BOOKKEEPER',
  CORE = 'CORE',
  /** Legacy plan */
  JUPITER = 'JUPITER',
  /** Legacy plan */
  MARS = 'MARS',
  /** Legacy plan */
  NEPTUNE = 'NEPTUNE',
  NONE = 'NONE',
  PRO = 'PRO',
  PROFESSIONAL = 'PROFESSIONAL',
  PROPLUS = 'PROPLUS',
  /** Legacy plan */
  SATURN = 'SATURN',
  SCALE = 'SCALE',
  STARTER = 'STARTER',
  TRIAL = 'TRIAL',
}

export type PracticeBillingPlanProduct = PracticeBillingProduct & {
  __typename: 'PracticeBillingPlanProduct';
  category: PracticeBillingProductCategory;
  description: Scalars['String']['output'];
  frequency: PracticeBillingPlanFrequency;
  name: Scalars['String']['output'];
  priceAnnually: PracticeBillingMoneyPrice;
  priceMonthly: PracticeBillingMoneyPrice;
};

export type PracticeBillingProduct = {
  category: PracticeBillingProductCategory;
  description: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export enum PracticeBillingProductCategory {
  CLIENTS = 'CLIENTS',
  FEATURE = 'FEATURE',
  IMPLEMENTATION = 'IMPLEMENTATION',
  PAYMENT = 'PAYMENT',
  SUBSCRIPTION = 'SUBSCRIPTION',
  SUPPORT = 'SUPPORT',
}

export type PracticeBillingProductFilter = {
  category?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type PracticeBillingSubscription = {
  __typename: 'PracticeBillingSubscription';
  accessAllowed: Scalars['Boolean']['output'];
  activeClientCount: Scalars['Int']['output'];
  activeUserCount: Scalars['Int']['output'];
  cancelledDate?: Maybe<Scalars['Date']['output']>;
  coupons: Array<PracticeBillingCoupon>;
  endDate?: Maybe<Scalars['Date']['output']>;
  frequency: PracticeBillingPlanFrequency;
  paymentMethod?: Maybe<PracticeBillingPaymentMethod>;
  pendingPaymentFees: Money;
  plan: PracticeBillingPlan;
  /** prices along with discount for the subscription */
  prices?: Maybe<PracticeBillingSubscriptionPrices>;
  products: Array<
    | PracticeBillingClientProduct
    | PracticeBillingOtherProduct
    | PracticeBillingPaymentFeeProduct
    | PracticeBillingPlanProduct
  >;
  renewDate?: Maybe<Scalars['Date']['output']>;
  startDate: Scalars['Date']['output'];
  status: SubscriptionStatus;
  trial: Scalars['Boolean']['output'];
};

export type PracticeBillingSubscriptionProductsArgs = {
  filter?: InputMaybe<PracticeBillingProductFilter>;
};

export type PracticeBillingSubscriptionPrices = {
  __typename: 'PracticeBillingSubscriptionPrices';
  annualDiscount: Money;
  annualDiscountPrice: Money;
  annualPrice: Money;
  monthlyDiscount: Money;
  monthlyDiscountPrice: Money;
  monthlyPrice: Money;
};

/** Autogenerated input type of PracticeConfirmDetailsFromLedgerSso */
export type PracticeConfirmDetailsFromLedgerSsoInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  practiceDetails: PracticeDetailsFromLedgerSsoInput;
};

/** Autogenerated return type of PracticeConfirmDetailsFromLedgerSso. */
export type PracticeConfirmDetailsFromLedgerSsoPayload = {
  __typename: 'PracticeConfirmDetailsFromLedgerSsoPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice: Practice;
};

/** Autogenerated input type of PracticeConfirmDetails */
export type PracticeConfirmDetailsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  practiceDetails: PracticeDetailsInput;
};

/** Autogenerated return type of PracticeConfirmDetails. */
export type PracticeConfirmDetailsPayload = {
  __typename: 'PracticeConfirmDetailsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice: Practice;
};

/** Input fields for the details of a practice */
export type PracticeDetailsFromLedgerSsoInput = {
  /** The capabilities app name for the ledger used to connect via SSO */
  appName: Scalars['String']['input'];
  /** The country code for the practice */
  countryCode: Scalars['CountryCode']['input'];
  /** The full name of the creator of the practice */
  creatorFullName: Scalars['String']['input'];
  /** How did the creator of the practice hear about Ignition */
  howDidYouHearAboutUs: Scalars['String']['input'];
  /** The name of the practice */
  name: Scalars['String']['input'];
  /** The bracket that the practice's previous year's revenue falls into */
  revenueBracket: MaturityIndexRevenueBracketValueEnum;
  /** Principal phone number for the practice */
  signupPhone: Scalars['PhoneNumber']['input'];
};

/** Input fields for the details of a practice */
export type PracticeDetailsInput = {
  /** The country code for the practice */
  countryCode: Scalars['CountryCode']['input'];
  /** The full name of the creator of the practice */
  creatorFullName: Scalars['String']['input'];
  /** How did the creator of the practice hear about Ignition */
  howDidYouHearAboutUs: Scalars['String']['input'];
  /** The name of the practice */
  name: Scalars['String']['input'];
  /** Principal phone number for the practice */
  signupPhone: Scalars['PhoneNumber']['input'];
};

/** Practice-level default settings for Engagements (CPE Proposals) */
export type PracticeEngagementSettings = {
  __typename: 'PracticeEngagementSettings';
  /** The default end date of a new engagement. */
  defaultEndDate: Scalars['Date']['output'];
  /** The default start date of a new engagement */
  defaultStartDate: Scalars['Date']['output'];
  /** Whether clients will see the proposal end date or service totals. */
  displayTotals: Scalars['Boolean']['output'];
  /** The day of the month services are billed (if billed monthly).  */
  monthlyInvoiceDay: Scalars['Int']['output'];
  /** Whether prorata is enabled for recurring services by default. */
  prorataEnabled: Scalars['Boolean']['output'];
  /**
   * The day of the week services are billed (if billed weekly). Note this is a
   * global setting and not customisable per-engagement.
   */
  weeklyInvoiceDay: Scalars['Int']['output'];
};

export enum PracticeIntentEnum {
  EFFICIENCY = 'EFFICIENCY',
  GROWTH = 'GROWTH',
  PAYMENTS = 'PAYMENTS',
  PROFIT = 'PROFIT',
  UNKNOWN = 'UNKNOWN',
}

/** Autogenerated input type of PracticeRetentionUrl */
export type PracticeRetentionUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of PracticeRetentionUrl. */
export type PracticeRetentionUrlPayload = {
  __typename: 'PracticeRetentionUrlPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  url: Scalars['String']['output'];
};

/** Autogenerated input type of PracticeSetDefaultNewProposalEmailTemplate */
export type PracticeSetDefaultNewProposalEmailTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of new proposal email template */
  templateId: Scalars['ID']['input'];
};

/** Autogenerated return type of PracticeSetDefaultNewProposalEmailTemplate. */
export type PracticeSetDefaultNewProposalEmailTemplatePayload = {
  __typename: 'PracticeSetDefaultNewProposalEmailTemplatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** Autogenerated input type of PracticeSetDefaultTax */
export type PracticeSetDefaultTaxInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of the Tax */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of PracticeSetDefaultTax. */
export type PracticeSetDefaultTaxPayload = {
  __typename: 'PracticeSetDefaultTaxPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** Autogenerated input type of PracticeSetDefaultTermsTemplate */
export type PracticeSetDefaultTermsTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of terms template */
  templateId: Scalars['ID']['input'];
};

/** Autogenerated return type of PracticeSetDefaultTermsTemplate. */
export type PracticeSetDefaultTermsTemplatePayload = {
  __typename: 'PracticeSetDefaultTermsTemplatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** Autogenerated input type of PracticeSetIntent */
export type PracticeSetIntentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  intent: PracticeIntentEnum;
};

/** Autogenerated return type of PracticeSetIntent. */
export type PracticeSetIntentPayload = {
  __typename: 'PracticeSetIntentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice: Practice;
};

/** Autogenerated input type of PracticeSetPreferredLandingPage */
export type PracticeSetPreferredLandingPageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  preferredLandingPage?: InputMaybe<PreferredLandingPage>;
};

/** Autogenerated return type of PracticeSetPreferredLandingPage. */
export type PracticeSetPreferredLandingPagePayload = {
  __typename: 'PracticeSetPreferredLandingPagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** Autogenerated input type of PracticeSetPreferredProposalEditor */
export type PracticeSetPreferredProposalEditorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  preferredProposalEditor?: InputMaybe<PreferredProposalEditor>;
};

/** Autogenerated return type of PracticeSetPreferredProposalEditor. */
export type PracticeSetPreferredProposalEditorPayload = {
  __typename: 'PracticeSetPreferredProposalEditorPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

export type PracticeTemplate = {
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  slug: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for PracticeTemplate. */
export type PracticeTemplateConnection = {
  __typename: 'PracticeTemplateConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PracticeTemplateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<
    Array<
      Maybe<
        | BankAccountFailureEmailTemplate
        | BankAccountVerificationEmailTemplate
        | EmailTemplate
        | EngagementLetterTemplate
        | IntroMessageTemplate
        | NewGroupProposalEmailTemplate
        | NewProposalEmailTemplate
        | NewSubmissionEmailTemplate
        | NextStepsMessageTemplate
        | ProposalAcceptedBrowserTemplate
        | ProposalAcceptedEmailTemplate
        | SystemTemplate
        | TermsTemplate
      >
    >
  >;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PracticeTemplateEdge = {
  __typename: 'PracticeTemplateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<
    | BankAccountFailureEmailTemplate
    | BankAccountVerificationEmailTemplate
    | EmailTemplate
    | EngagementLetterTemplate
    | IntroMessageTemplate
    | NewGroupProposalEmailTemplate
    | NewProposalEmailTemplate
    | NewSubmissionEmailTemplate
    | NextStepsMessageTemplate
    | ProposalAcceptedBrowserTemplate
    | ProposalAcceptedEmailTemplate
    | SystemTemplate
    | TermsTemplate
  >;
};

export enum PreferredLandingPage {
  /** Always use the Dashboard page */
  DASHBOARD = 'DASHBOARD',
}

export enum PreferredProposalEditor {
  /** Always use New Proposals */
  NPE = 'NPE',
}

export type PriceIncreaseInputType = {
  /** float between 0.0 and 100.0, with 10% expressed as 10.0 */
  percentage: PercentageInput;
  /** Round to nearest amount. Typical values: 1, 5, 10 */
  roundToNearest?: InputMaybe<Scalars['Int']['input']>;
};

export type PriceRuleUnitName = {
  __typename: 'PriceRuleUnitName';
  /** Slug of the custom unit price */
  id: Scalars['ID']['output'];
  /** the name of the unit price rule */
  name: Scalars['String']['output'];
};

/** The connection type for PriceRuleUnitName. */
export type PriceRuleUnitNameConnection = {
  __typename: 'PriceRuleUnitNameConnection';
  /** A list of edges. */
  edges: Array<PriceRuleUnitNameEdge>;
  /** A list of nodes. */
  nodes: Array<PriceRuleUnitName>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PriceRuleUnitNameEdge = {
  __typename: 'PriceRuleUnitNameEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: PriceRuleUnitName;
};

export type Proconnect = {
  __typename: 'Proconnect';
  state: ProconnectState;
};

/** Autogenerated input type of ProconnectConnect */
export type ProconnectConnectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ProconnectConnect. */
export type ProconnectConnectPayload = {
  __typename: 'ProconnectConnectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proconnect?: Maybe<Proconnect>;
};

/** Autogenerated input type of ProconnectDisconnect */
export type ProconnectDisconnectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ProconnectDisconnect. */
export type ProconnectDisconnectPayload = {
  __typename: 'ProconnectDisconnectPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proconnect?: Maybe<Proconnect>;
};

export enum ProconnectState {
  AUTHORISED = 'AUTHORISED',
  CONNECTED = 'CONNECTED',
  DISCONNECTED = 'DISCONNECTED',
  ENABLED = 'ENABLED',
  UNAUTHORISED = 'UNAUTHORISED',
  UNAVAILABLE = 'UNAVAILABLE',
}

export type Project = {
  __typename: 'Project';
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  /** Reference number for the project (eg. PROJ-0001) */
  displayReferenceNumber: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  option: ProposalOption;
  position: Scalars['Int']['output'];
  serviceGroups: Array<ServiceGroup>;
  updatedAt: Scalars['DateTime']['output'];
};

export type Proposal = {
  __typename: 'Proposal';
  acceptProposalMessage?: Maybe<Textile>;
  acceptanceEmail?: Maybe<AcceptanceEmail>;
  acceptedAt?: Maybe<Scalars['DateTime']['output']>;
  /** @deprecated Use selectedOption instead */
  acceptedOption?: Maybe<ProposalOption>;
  activities: ActivityLogConnection;
  /** If present, this is an error related to recent activity on the proposal, such as a failed send */
  activityError?: Maybe<Scalars['String']['output']>;
  /** The date/time when activityError last occurred */
  activityErrorOccurredAt?: Maybe<Scalars['DateTime']['output']>;
  billingGroupedBy: ProposalBillingGroupedBy;
  brochure?: Maybe<Brochure>;
  /** Minimum contract window end date */
  calculatedUntil: Scalars['Date']['output'];
  client?: Maybe<Client>;
  contact?: Maybe<Contact>;
  createdAt: Scalars['DateTime']['output'];
  createdFrom?: Maybe<ProposalSource>;
  creator: User;
  creditCardAccepted: Scalars['Boolean']['output'];
  currency: Currency;
  directDebitAccepted: Scalars['Boolean']['output'];
  /** Reference number for the proposal (eg. PROP-0001) (adding again for consistency with ClientType) */
  displayReferenceNumber: Scalars['String']['output'];
  duplicatedFrom?: Maybe<Proposal>;
  effectiveFrom?: Maybe<Scalars['String']['output']>;
  /** Indicates if any of the proposed services on the proposal has smart billing */
  hasSmartBilling: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** Indicates if the proposal imported from a ledger */
  isImportedFromLedger: Scalars['Boolean']['output'];
  /** Indicates if the proposal can be renewed */
  isRenewable: Scalars['Boolean']['output'];
  /** Indicates if the proposal was created via client renewal */
  isRenewal: Scalars['Boolean']['output'];
  /** Indicates if the proposal has been renewed */
  isRenewed: Scalars['Boolean']['output'];
  lockVersion: Scalars['Int']['output'];
  minimumContractLength: Scalars['Int']['output'];
  /**
   * Minimum contract value without tax based on selected option or the cheapest
   * available option (if none have been selected yet), excluding discount
   */
  minimumContractUndiscountedValue: Money;
  /**
   * Minimum contract value tax amount based on selected option or the cheapest
   * available option (if none have been selected yet) excluding discount
   */
  minimumContractUndiscountedValueTaxAmount: Money;
  /**
   * Minimum contract value with tax based on selected option or the cheapest
   * available option (if none have been selected yet) excluding discount
   */
  minimumContractUndiscountedValueWithTax: Money;
  /**
   * Minimum contract value without tax based on selected option or the cheapest
   * available option (if none have been selected yet)
   */
  minimumContractValue: Money;
  /**
   * Contract discount value on minimum amount based on selected option or the
   * cheapest available option (if none have been selected yet)
   */
  minimumContractValueDiscountAmount: Money;
  /**
   * Minimum contract value tax amount based on selected option or the cheapest
   * available option (if none have been selected yet)
   */
  minimumContractValueTaxAmount: Money;
  /** Minimum contract value with tax based on selected option or the cheapest available option (if none have been selected yet) */
  minimumContractValueWithTax: Money;
  name: Scalars['String']['output'];
  nextStepsMessage: Scalars['Html']['output'];
  nextStepsMessagePreview: Scalars['Html']['output'];
  notifications: ProposalsNotifications;
  oneTimeDateDisplay: ProposalOneTimeDateDisplay;
  option?: Maybe<ProposalOption>;
  options: Array<ProposalOption>;
  paymentMethod?: Maybe<PaymentMethod>;
  paymentMethodRequired: Scalars['Boolean']['output'];
  /** The url of the generated PDF for this proposal */
  pdfUrl: Scalars['URL']['output'];
  personalisedMessage: Scalars['Html']['output'];
  personalisedMessagePreview: Scalars['Html']['output'];
  postAcceptanceVideoUrl?: Maybe<Scalars['URL']['output']>;
  preAcceptanceVideoUrl?: Maybe<Scalars['URL']['output']>;
  priceIncreased: Scalars['Boolean']['output'];
  /** Flag that indicates whether the primary signatory needs to sign before the others */
  primaryMustSignFirst: Scalars['Boolean']['output'];
  project?: Maybe<Project>;
  proposalValueDisplay: ProposalValueDisplay;
  proposedService?: Maybe<ProposedService>;
  /** Indicates if the proposal's preview is publicly available */
  publiclyPreviewable: Scalars['Boolean']['output'];
  recipients: Array<ProposalRecipient>;
  recommendedOption?: Maybe<ProposalOption>;
  reviewAssignee?: Maybe<User>;
  reviewState: ProposalReviewState;
  selectedOption?: Maybe<ProposalOption>;
  sender?: Maybe<User>;
  sentAt?: Maybe<Scalars['DateTime']['output']>;
  serviceGroup?: Maybe<ServiceGroup>;
  serviceGroups: Array<ServiceGroup>;
  servicePriceDisplay: ProposalServicePriceDisplay;
  /** Proposal service terms */
  serviceTerms: ProposalServiceTerms;
  /** Signatories for this proposal */
  signatories: Array<ProposalSignatory>;
  startDate?: Maybe<Scalars['Date']['output']>;
  startOn: ProposalStartOn;
  state: ProposalState;
  suggestedWorkflowTemplates: Array<WorkflowTemplateType>;
  tax?: Maybe<Tax>;
  taxMethod: TaxMethod;
  /** @deprecated Use termsMessage instead */
  terms?: Maybe<ProposalTerms>;
  /** Proposal terms message */
  termsMessage: ProposalTermsMessage;
  token: Scalars['String']['output'];
  /** If present, reason why the proposal cannot be renewed. Incurs an extra query, so should only be called when necessary */
  unrenewableReason?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  workflowSettings: WorkflowSettings;
  workflowStrategies: Array<WorkflowStrategy>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

export type ProposalActivitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ActivityLogOrder>;
};

export type ProposalOptionArgs = {
  id: Scalars['ID']['input'];
};

export type ProposalProjectArgs = {
  id: Scalars['ID']['input'];
};

export type ProposalProposedServiceArgs = {
  id: Scalars['ID']['input'];
};

export type ProposalServiceGroupArgs = {
  id: Scalars['ID']['input'];
};

export type ProposalServiceTermsArgs = {
  optionId?: InputMaybe<Scalars['ID']['input']>;
};

export type ProposalSignatoriesArgs = {
  filter?: InputMaybe<SignatoryFilter>;
};

export type ProposalWorkflowSettingsArgs = {
  appName: Scalars['ID']['input'];
};

export type ProposalWorkflowStrategyArgs = {
  id: Scalars['ID']['input'];
};

export type ProposalAcceptedBrowserTemplate = PracticeTemplate & {
  __typename: 'ProposalAcceptedBrowserTemplate';
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  slug: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

/** Autogenerated input type of ProposalAcceptedBrowserTemplateUpdate */
export type ProposalAcceptedBrowserTemplateUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of proposal accepted browser template */
  id: Scalars['ID']['input'];
  template: TemplateInput;
};

/** Autogenerated return type of ProposalAcceptedBrowserTemplateUpdate. */
export type ProposalAcceptedBrowserTemplateUpdatePayload = {
  __typename: 'ProposalAcceptedBrowserTemplateUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<ProposalAcceptedBrowserTemplate>;
  templates?: Maybe<Templates>;
};

export type ProposalAcceptedEmailTemplate = EmailTemplateInterface &
  PracticeTemplate & {
    __typename: 'ProposalAcceptedEmailTemplate';
    content: Scalars['String']['output'];
    contentHtml: Scalars['String']['output'];
    createdAt: Scalars['DateTime']['output'];
    description?: Maybe<Scalars['String']['output']>;
    id: Scalars['ID']['output'];
    name: Scalars['String']['output'];
    slug: Scalars['ID']['output'];
    subject: Scalars['String']['output'];
    updatedAt: Scalars['DateTime']['output'];
  };

/** Autogenerated input type of ProposalAcceptedEmailTemplateUpdate */
export type ProposalAcceptedEmailTemplateUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of proposal accepted email template */
  id: Scalars['ID']['input'];
  template: EmailTemplateInput;
};

/** Autogenerated return type of ProposalAcceptedEmailTemplateUpdate. */
export type ProposalAcceptedEmailTemplateUpdatePayload = {
  __typename: 'ProposalAcceptedEmailTemplateUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<ProposalAcceptedEmailTemplate>;
  templates?: Maybe<Templates>;
};

/** Autogenerated input type of ProposalAddDefaultWorkflow */
export type ProposalAddDefaultWorkflowInput = {
  /** The name of the workflow app to create workflow for. */
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of Proposal */
  id: Scalars['ID']['input'];
  /**
   * Specify which option's projects or services will be used to build workflow
   * defaults. Only applies if the proposal has options enabled.
   */
  optionId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * If true, any existing workflows on this proposal will first be removed before
   * adding new workflows based on the current settings. Defaults to false.
   */
  removeExistingWorkflow?: InputMaybe<Scalars['Boolean']['input']>;
  /** Defines how many workflows will be created. */
  workflowStructure: ProposalWorkflowSettingsWorkflowStructure;
};

/** Autogenerated return type of ProposalAddDefaultWorkflow. */
export type ProposalAddDefaultWorkflowPayload = {
  __typename: 'ProposalAddDefaultWorkflowPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalAddMultipleBillingServiceGroup */
export type ProposalAddMultipleBillingServiceGroupInput = {
  /** the frontend billing mode to store for future display purposes. required if `billing_schedules` is present. */
  billingMode?: InputMaybe<ProposalBillingModeEnum>;
  /**
   * optional schedules to configure future billings. if not specified, a single on
   * acceptance schedule will be assumed as a reasonable default
   */
  billingSchedules?: InputMaybe<Array<BillingScheduleInputType>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** Position for new service groups is automatically assigned. Use ProposalMoveServiceGroup to change position after creation. */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** the slug of the project to add the service group to */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalAddMultipleBillingServiceGroup. */
export type ProposalAddMultipleBillingServiceGroupPayload = {
  __typename: 'ProposalAddMultipleBillingServiceGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  serviceGroup?: Maybe<ServiceGroup>;
};

/** Autogenerated input type of ProposalAddOnAcceptanceServiceGroup */
export type ProposalAddOnAcceptanceServiceGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** Position for new service groups is automatically assigned. Use ProposalMoveServiceGroup to change position after creation. */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** uuid of the project to add the service group to */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalAddOnAcceptanceServiceGroup. */
export type ProposalAddOnAcceptanceServiceGroupPayload = {
  __typename: 'ProposalAddOnAcceptanceServiceGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  serviceGroup?: Maybe<ServiceGroup>;
};

/** Autogenerated input type of ProposalAddOption */
export type ProposalAddOptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of Proposal */
  id: Scalars['ID']['input'];
  /** position to add new option at */
  position: Scalars['Int']['input'];
};

/** Autogenerated return type of ProposalAddOption. */
export type ProposalAddOptionPayload = {
  __typename: 'ProposalAddOptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  option?: Maybe<ProposalOption>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalAddProject */
export type ProposalAddProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** slug of the option to add the project to */
  optionId: Scalars['ID']['input'];
  /** position to add new project at */
  position: Scalars['Int']['input'];
};

/** Autogenerated return type of ProposalAddProject. */
export type ProposalAddProjectPayload = {
  __typename: 'ProposalAddProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalAddProposedService */
export type ProposalAddProposedServiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** position to add new project at */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** uuid of the service groupto add the proposed service to */
  serviceGroupId: Scalars['ID']['input'];
  /** uuid of the service library service to use as a template */
  serviceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalAddProposedService. */
export type ProposalAddProposedServicePayload = {
  __typename: 'ProposalAddProposedServicePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

/** Autogenerated input type of ProposalAddRecipient */
export type ProposalAddRecipientInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** email address */
  email: Scalars['EmailAddress']['input'];
  /** proposal slug */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalAddRecipient. */
export type ProposalAddRecipientPayload = {
  __typename: 'ProposalAddRecipientPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  recipient?: Maybe<ProposalRecipient>;
};

/** Autogenerated input type of ProposalAddRecurringServiceGroup */
export type ProposalAddRecurringServiceGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of the proposal */
  id: Scalars['ID']['input'];
  /** Position for new service groups is automatically assigned. Use ProposalMoveServiceGroup to change position after creation. */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** UUID of the project to add the service group to */
  projectId: Scalars['ID']['input'];
  rule?: InputMaybe<Scalars['RecurrenceRuleInput']['input']>;
};

/** Autogenerated return type of ProposalAddRecurringServiceGroup. */
export type ProposalAddRecurringServiceGroupPayload = {
  __typename: 'ProposalAddRecurringServiceGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  serviceGroup?: Maybe<ServiceGroup>;
};

/** Autogenerated input type of ProposalAddServiceGroup */
export type ProposalAddServiceGroupInput = {
  /** the frontend billing mode to store for future display purposes. required if `billing_schedules` is present. */
  billingMode?: InputMaybe<ProposalBillingModeEnum>;
  /**
   * optional schedules to configure future billings. if not specified, a single on
   * acceptance schedule will be assumed as a reasonable default
   */
  billingSchedules?: InputMaybe<Array<BillingScheduleInputType>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** Position for new service groups is automatically assigned. Use ProposalMoveServiceGroup to change position after creation. */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** the slug of the project to add the service group to */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalAddServiceGroup. */
export type ProposalAddServiceGroupPayload = {
  __typename: 'ProposalAddServiceGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  serviceGroup?: Maybe<ServiceGroup>;
};

export type ProposalBillingGroup = {
  __typename: 'ProposalBillingGroup';
  /** The billing reference will be applied to invoices raised with this billing group. */
  billingReference: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Name of billing group. */
  name: Scalars['String']['output'];
  /** Source of billing group */
  source?: Maybe<ProposalBillingGroupSource>;
  /** The type of this billing group. */
  type: ProposalBillingGroupType;
};

export type ProposalBillingGroupSource = Client | Project | Proposal;

export enum ProposalBillingGroupType {
  /** Billing Group for Client */
  CLIENT = 'CLIENT',
  /** Billing Group for Proposal Project */
  PROJECT = 'PROJECT',
  /** Billing Group for Proposal */
  PROPOSAL = 'PROPOSAL',
}

export enum ProposalBillingGroupedBy {
  /** Services from this proposal may be billed together with services from this client's other proposals. */
  CLIENT = 'CLIENT',
  /**
   * Services from this proposal will be billed separately for each project, and
   * will not be combined with services from other proposals or projects.
   */
  PROJECT = 'PROJECT',
  /**
   * Services from this proposal will be billed separately from this client's other
   * proposals, but services from different projects may be billed together.
   */
  PROPOSAL = 'PROPOSAL',
}

export enum ProposalBillingModeEnum {
  /** Bill with deposit */
  DEPOSIT = 'DEPOSIT',
  /** Bill once */
  ONCE_OFF = 'ONCE_OFF',
  /** Bill recurring */
  RECURRING = 'RECURRING',
}

export type ProposalBillingScheduleInterface = {
  /** Description of the billing cadence e.g. 'every month' */
  cadence?: Maybe<Scalars['String']['output']>;
  /** List of past billing dates that will apply as soon as proposal is accepted or completed */
  catchUpBillingDates: Array<Scalars['Date']['output']>;
  /** Sum of the value of missed billing items that will apply as soon as proposal is accepted or completed */
  catchUpBillingMinimumPrice: Money;
  /** Sum of the tax of value of missed billing items that will apply as soon as proposal is accepted or completed */
  catchUpBillingMinimumPriceTax: Money;
  /** Sum of the value with tax, of missed billing items that will apply as soon as proposal is accepted or completed */
  catchUpBillingMinimumPriceWithTax: Money;
  /** Subtotal of all service price portions on an individual period of this billing schedule */
  catchUpPeriodSubtotal: Money;
  /** Subtotal of all service price portions taxes on an individual period of this billing schedule */
  catchUpPeriodSubtotalTax: Money;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  position: Scalars['Int']['output'];
  proposedServicePortions: Array<Portion>;
  recurrence: ProposalBillingStrategyType;
  serviceGroup: ServiceGroup;
  start:
    | ProposalStartBillingOnAcceptance
    | ProposalStartBillingOnDate
    | ProposalStartBillingOnProposalEndDate
    | ProposalStartBillingOnProposalStartDate;
  subtitle?: Maybe<Scalars['String']['output']>;
  /** Subtotal of fixed service price portions on this billing schedule including discount */
  subtotal: Money;
  /** Total discount on fixed service price portions on this billing schedule */
  subtotalDiscountAmount: Money;
  /** Tax on subtotal of fixed service price portions on this billing schedule including discount */
  subtotalTax: Money;
  /** Subtotal plus tax of fixed service price portions on this billing schedule including discount */
  subtotalWithTax: Money;
  title: Scalars['String']['output'];
  /** Subtotal of fixed service price portions on this billing schedule not including tax */
  undiscountedSubtotal: Money;
  /** Subtotal plus tax of fixed service price portions on this billing schedule not including discount */
  undiscountedSubtotalWithTax: Money;
};

export type ProposalBillingScheduleInterfaceProposedServicePortionsArgs = {
  filter?: InputMaybe<ProposedServiceFilter>;
};

export type ProposalBillingStrategyInterface = {
  /** List of past billing dates that will apply as soon as proposal is accepted or completed */
  catchUpBillingDates: Array<Scalars['Date']['output']>;
  createdAt: Scalars['DateTime']['output'];
  /** @deprecated use serviceGroup.title instead */
  description: Scalars['String']['output'];
  start:
    | ProposalStartBillingOnAcceptance
    | ProposalStartBillingOnDate
    | ProposalStartBillingOnProposalEndDate
    | ProposalStartBillingOnProposalStartDate;
  type: ProposalBillingStrategyType;
  updatedAt: Scalars['DateTime']['output'];
};

export enum ProposalBillingStrategyType {
  ONCE_OFF = 'ONCE_OFF',
  RECURRING = 'RECURRING',
}

/** The connection type for Proposal. */
export type ProposalConnection = {
  __typename: 'ProposalConnection';
  /** A list of edges. */
  edges: Array<ProposalEdge>;
  /** A list of nodes. */
  nodes: Array<Proposal>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ProposalCreateBulk */
export type ProposalCreateBulkInput = {
  /** Slugs of clients to create proposals for */
  clientIds: Array<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name to give the created proposals */
  name: Scalars['String']['input'];
  /** date (ISO Formatted) the proposals start on. Only required when start_on is date */
  startDate?: InputMaybe<Scalars['Date']['input']>;
  /** The start type for the proposals */
  startOn: ProposalStartOn;
  /** Slug of a custom or provided template */
  templateId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalCreateBulk. */
export type ProposalCreateBulkPayload = {
  __typename: 'ProposalCreateBulkPayload';
  asyncJobGroup: AsyncJobGroup;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ProposalCreate */
export type ProposalCreateInput = {
  clientId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ProposalCreate. */
export type ProposalCreatePayload = {
  __typename: 'ProposalCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  userErrors: Array<UserError>;
};

/** Autogenerated input type of ProposalCreateWithDemoClient */
export type ProposalCreateWithDemoClientInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ProposalCreateWithDemoClient. */
export type ProposalCreateWithDemoClientPayload = {
  __typename: 'ProposalCreateWithDemoClientPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  userErrors?: Maybe<Array<UserError>>;
};

/** Autogenerated input type of ProposalCreateWithPlaceholderClient */
export type ProposalCreateWithPlaceholderClientInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Optional template slug */
  templateId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of ProposalCreateWithPlaceholderClient. */
export type ProposalCreateWithPlaceholderClientPayload = {
  __typename: 'ProposalCreateWithPlaceholderClientPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  userErrors: Array<UserError>;
};

export type ProposalCustomTemplate = {
  __typename: 'ProposalCustomTemplate';
  /** creator of template */
  creator: User;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** time template was last updated */
  lastUpdatedAt: Scalars['DateTime']['output'];
  name: Scalars['String']['output'];
  /** Recent proposals created using this template by the practice */
  proposals: ProposalConnection;
  reference: Scalars['ID']['output'];
  /** The template's visibility */
  visibility: TemplateVisibility;
};

export type ProposalCustomTemplateProposalsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ProposalCustomTemplate. */
export type ProposalCustomTemplateConnection = {
  __typename: 'ProposalCustomTemplateConnection';
  /** A list of edges. */
  edges: Array<ProposalCustomTemplateEdge>;
  /** A list of nodes. */
  nodes: Array<ProposalCustomTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ProposalCustomTemplateCreateFromProposal */
export type ProposalCustomTemplateCreateFromProposalInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** description of custom template */
  description: Scalars['String']['input'];
  /** name of custom template */
  name: Scalars['String']['input'];
  /** Slug of Proposal */
  proposalId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalCustomTemplateCreateFromProposal. */
export type ProposalCustomTemplateCreateFromProposalPayload = {
  __typename: 'ProposalCustomTemplateCreateFromProposalPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  customTemplate?: Maybe<ProposalCustomTemplate>;
  proposalCustomTemplates: ProposalCustomTemplateConnection;
};

/** Autogenerated return type of ProposalCustomTemplateCreateFromProposal. */
export type ProposalCustomTemplateCreateFromProposalPayloadProposalCustomTemplatesArgs =
  {
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
  };

/** Autogenerated input type of ProposalCustomTemplateDelete */
export type ProposalCustomTemplateDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of Custom Template */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalCustomTemplateDelete. */
export type ProposalCustomTemplateDeletePayload = {
  __typename: 'ProposalCustomTemplateDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  customTemplates: ProposalCustomTemplateConnection;
};

/** Autogenerated return type of ProposalCustomTemplateDelete. */
export type ProposalCustomTemplateDeletePayloadCustomTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ProposalCustomTemplateEdge = {
  __typename: 'ProposalCustomTemplateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ProposalCustomTemplate;
};

/** Autogenerated input type of ProposalCustomTemplatePreview */
export type ProposalCustomTemplatePreviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of Custom Template */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalCustomTemplatePreview. */
export type ProposalCustomTemplatePreviewPayload = {
  __typename: 'ProposalCustomTemplatePreviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalCustomTemplateReplace */
export type ProposalCustomTemplateReplaceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** description of custom template */
  description: Scalars['String']['input'];
  /** Slug of Custom Template */
  id: Scalars['ID']['input'];
  /** name of custom template */
  name: Scalars['String']['input'];
  /** Slug of Proposal */
  proposalId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalCustomTemplateReplace. */
export type ProposalCustomTemplateReplacePayload = {
  __typename: 'ProposalCustomTemplateReplacePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  customTemplate?: Maybe<ProposalCustomTemplate>;
};

/** Autogenerated input type of ProposalDuplicateProject */
export type ProposalDuplicateProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** slug of the project to duplicate */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalDuplicateProject. */
export type ProposalDuplicateProjectPayload = {
  __typename: 'ProposalDuplicateProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  option?: Maybe<ProposalOption>;
  project?: Maybe<Project>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalDuplicateProposedService */
export type ProposalDuplicateProposedServiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the proposed service to duplicate */
  proposedServiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalDuplicateProposedService. */
export type ProposalDuplicateProposedServicePayload = {
  __typename: 'ProposalDuplicateProposedServicePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
  serviceGroup?: Maybe<ServiceGroup>;
};

/** Autogenerated input type of ProposalDuplicateServiceGroup */
export type ProposalDuplicateServiceGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the service group to duplicate */
  serviceGroupId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalDuplicateServiceGroup. */
export type ProposalDuplicateServiceGroupPayload = {
  __typename: 'ProposalDuplicateServiceGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
  proposal?: Maybe<Proposal>;
  serviceGroup?: Maybe<ServiceGroup>;
};

/** An edge in a connection. */
export type ProposalEdge = {
  __typename: 'ProposalEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Proposal;
};

export type ProposalFilter = {
  clientIdEq?: InputMaybe<Scalars['ID']['input']>;
  stateIn?: InputMaybe<Array<ProposalState>>;
  stateNotIn?: InputMaybe<Array<ProposalState>>;
};

export type ProposalFixedPrice = ProposalPriceInterface & {
  __typename: 'ProposalFixedPrice';
  /** Amount excluding discount, excluding tax */
  amount: Money;
  /** Amount including tax, excluding discount */
  amountWithTax: Money;
  currency: Currency;
  /** Price display without tax */
  display: Scalars['String']['output'];
  /** Total Price display with discount, without tax */
  displayTotalAmount: Scalars['String']['output'];
  /** Total amount including discount and tax in human readable form */
  displayTotalAmountWithTax: Scalars['String']['output'];
  /** The total discount, in human readable form */
  displayTotalDiscountAmount: Scalars['String']['output'];
  /** The total amount, excluding discount and tax in human readable form */
  displayTotalUndiscountedAmount: Scalars['String']['output'];
  /** Price display with tax */
  displayWithTax: Scalars['String']['output'];
  invoiceStrategy: ProposalInvoiceStrategy;
  /** @deprecated Use quantity next to price, not in the price */
  quantity: Scalars['Decimal']['output'];
  /** The tax amount, excluding quantity */
  taxDisplay?: Maybe<Scalars['String']['output']>;
  /** Fixed price amount multiplied by the quantity */
  total: Money;
  /** Total amount including discount, excluding tax */
  totalAmount: Money;
  /** Total amount including discount and tax */
  totalAmountWithTax: Money;
  /** Total discount */
  totalDiscountAmount: Money;
  /** Total amount excluding discount and tax */
  totalUndiscountedAmount: Money;
  /** Total amount including tax, excluding discount */
  totalUndiscountedAmountWithTax: Money;
  type: ProposalPriceType;
};

export type ProposalIncludedPrice = ProposalPriceInterface & {
  __typename: 'ProposalIncludedPrice';
  currency: Currency;
  /** Price display without tax */
  display: Scalars['String']['output'];
  /** Total amount including discount, excluding tax in human readable form */
  displayTotalAmount: Scalars['String']['output'];
  /** The total discount, in human readable form */
  displayTotalDiscountAmount: Scalars['String']['output'];
  /** The total amount, excluding discount and tax in human readable form */
  displayTotalUndiscountedAmount: Scalars['String']['output'];
  /** Price display with tax */
  displayWithTax: Scalars['String']['output'];
  /** @deprecated Use quantity next to price, not in the price */
  quantity: Scalars['Decimal']['output'];
  /** The tax amount, excluding quantity */
  taxDisplay?: Maybe<Scalars['String']['output']>;
  type: ProposalPriceType;
};

/**
 * Preview increasing service prices of a proposal.
 *           Also returns warnings to be shown to user before increase is applied, e.g.
 *           rounding causing a service price to decrease.
 */
export type ProposalIncreaseServicePricesPreview = {
  __typename: 'ProposalIncreaseServicePricesPreview';
  optionPriceIncreases: Array<ProposalIncreaseServicePricesPreviewOption>;
  percentage: Percentage;
  proposalId: Scalars['ID']['output'];
  roundToNearest?: Maybe<Scalars['Int']['output']>;
};

/** Preview of a price increase for an option */
export type ProposalIncreaseServicePricesPreviewOption = {
  __typename: 'ProposalIncreaseServicePricesPreviewOption';
  minimumContractValue: Money;
  minimumContractValueDelta: Money;
  minimumContractValueDeltaPercentage: Scalars['Float']['output'];
  /** @deprecated use the minimumContractValue fields instead */
  minimumValue: Scalars['Float']['output'];
  /** @deprecated use the minimumContractValue fields instead */
  minimumValueDelta: Scalars['Float']['output'];
  /** @deprecated use the minimumContractValue fields instead */
  minimumValueDeltaPercentage: Scalars['Float']['output'];
  option: ProposalOption;
  warnings: Array<ProposalProposalIncreaseServicePricesWarning>;
};

export enum ProposalInvoiceStrategy {
  AUTOMATIC = 'AUTOMATIC',
  MANUAL = 'MANUAL',
}

export type ProposalMinimumPrice = ProposalPriceInterface & {
  __typename: 'ProposalMinimumPrice';
  /** Amount excluding tax */
  amount: Money;
  /** Amount including tax */
  amountWithTax: Money;
  currency: Currency;
  /** Price display without tax */
  display: Scalars['String']['output'];
  /** Total amount including discount, excluding tax in human readable form */
  displayTotalAmount: Scalars['String']['output'];
  /** The total discount, in human readable form */
  displayTotalDiscountAmount: Scalars['String']['output'];
  /** The total amount, excluding discount and tax in human readable form */
  displayTotalUndiscountedAmount: Scalars['String']['output'];
  /** Price display with tax */
  displayWithTax: Scalars['String']['output'];
  /** @deprecated Use quantity next to price, not in the price */
  quantity: Scalars['Decimal']['output'];
  /** The tax amount, excluding quantity */
  taxDisplay?: Maybe<Scalars['String']['output']>;
  /** Total amount including discount, excluding tax */
  totalAmount: Money;
  /** Total minimum including discount and tax */
  totalAmountWithTax: Money;
  /** Total discount */
  totalDiscountAmount: Money;
  /** Total amount excluding discount and tax */
  totalUndiscountedAmount: Money;
  type: ProposalPriceType;
};

/** Autogenerated input type of ProposalMoveOption */
export type ProposalMoveOptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** slug of the option to move */
  optionId: Scalars['ID']['input'];
  position: Scalars['Int']['input'];
};

/** Autogenerated return type of ProposalMoveOption. */
export type ProposalMoveOptionPayload = {
  __typename: 'ProposalMoveOptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  option?: Maybe<ProposalOption>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalMoveProject */
export type ProposalMoveProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  position: Scalars['Int']['input'];
  /** slug of the project to move */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalMoveProject. */
export type ProposalMoveProjectPayload = {
  __typename: 'ProposalMoveProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  option?: Maybe<ProposalOption>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalMoveProposedService */
export type ProposalMoveProposedServiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  position: Scalars['Int']['input'];
  /** uuid of the proposed service to move */
  proposedServiceId: Scalars['ID']['input'];
  /** uuid of the service group to move proposed service to */
  serviceGroupId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalMoveProposedService. */
export type ProposalMoveProposedServicePayload = {
  __typename: 'ProposalMoveProposedServicePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  serviceGroup?: Maybe<ServiceGroup>;
};

/** Autogenerated input type of ProposalMoveServiceGroup */
export type ProposalMoveServiceGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** Optionally specify a new position. */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** slug of the project to move the service group to */
  projectId: Scalars['ID']['input'];
  /** slug of the service group to move */
  serviceGroupId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalMoveServiceGroup. */
export type ProposalMoveServiceGroupPayload = {
  __typename: 'ProposalMoveServiceGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalMoveToAwaitingAcceptance */
export type ProposalMoveToAwaitingAcceptanceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** send proposal to client or not */
  sendToClient?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of ProposalMoveToAwaitingAcceptance. */
export type ProposalMoveToAwaitingAcceptancePayload = {
  __typename: 'ProposalMoveToAwaitingAcceptancePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

export type ProposalOnceOffBillingSchedule =
  ProposalBillingScheduleInterface & {
    __typename: 'ProposalOnceOffBillingSchedule';
    /** Description of the billing cadence e.g. 'every month' */
    cadence?: Maybe<Scalars['String']['output']>;
    /** List of past billing dates that will apply as soon as proposal is accepted or completed */
    catchUpBillingDates: Array<Scalars['Date']['output']>;
    /** Sum of the value of missed billing items that will apply as soon as proposal is accepted or completed */
    catchUpBillingMinimumPrice: Money;
    /** Sum of the tax of value of missed billing items that will apply as soon as proposal is accepted or completed */
    catchUpBillingMinimumPriceTax: Money;
    /** Sum of the value with tax, of missed billing items that will apply as soon as proposal is accepted or completed */
    catchUpBillingMinimumPriceWithTax: Money;
    /** Subtotal of all service price portions on an individual period of this billing schedule */
    catchUpPeriodSubtotal: Money;
    /** Subtotal of all service price portions taxes on an individual period of this billing schedule */
    catchUpPeriodSubtotalTax: Money;
    id: Scalars['ID']['output'];
    name?: Maybe<Scalars['String']['output']>;
    position: Scalars['Int']['output'];
    proposedServicePortions: Array<Portion>;
    recurrence: ProposalBillingStrategyType;
    serviceGroup: ServiceGroup;
    start:
      | ProposalStartBillingOnAcceptance
      | ProposalStartBillingOnDate
      | ProposalStartBillingOnProposalEndDate
      | ProposalStartBillingOnProposalStartDate;
    subtitle?: Maybe<Scalars['String']['output']>;
    /** Subtotal of fixed service price portions on this billing schedule including discount */
    subtotal: Money;
    /** Total discount on fixed service price portions on this billing schedule */
    subtotalDiscountAmount: Money;
    /** Tax on subtotal of fixed service price portions on this billing schedule including discount */
    subtotalTax: Money;
    /** Subtotal plus tax of fixed service price portions on this billing schedule including discount */
    subtotalWithTax: Money;
    title: Scalars['String']['output'];
    /** Subtotal of fixed service price portions on this billing schedule not including tax */
    undiscountedSubtotal: Money;
    /** Subtotal plus tax of fixed service price portions on this billing schedule not including discount */
    undiscountedSubtotalWithTax: Money;
  };

export type ProposalOnceOffBillingScheduleProposedServicePortionsArgs = {
  filter?: InputMaybe<ProposedServiceFilter>;
};

export type ProposalOnceOffBillingStrategy =
  ProposalBillingStrategyInterface & {
    __typename: 'ProposalOnceOffBillingStrategy';
    /** List of past billing dates that will apply as soon as proposal is accepted or completed */
    catchUpBillingDates: Array<Scalars['Date']['output']>;
    createdAt: Scalars['DateTime']['output'];
    /** @deprecated use serviceGroup.title instead */
    description: Scalars['String']['output'];
    start:
      | ProposalStartBillingOnAcceptance
      | ProposalStartBillingOnDate
      | ProposalStartBillingOnProposalEndDate
      | ProposalStartBillingOnProposalStartDate;
    type: ProposalBillingStrategyType;
    updatedAt: Scalars['DateTime']['output'];
  };

export enum ProposalOneTimeDateDisplay {
  HIDE = 'HIDE',
  SHOW = 'SHOW',
}

export type ProposalOption = {
  __typename: 'ProposalOption';
  createdAt: Scalars['DateTime']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isRecommended: Scalars['Boolean']['output'];
  /**
   * Minimum contract value without tax based on selected option or the cheapest
   * available option (if none have been selected yet), excluding discount
   */
  minimumContractUndiscountedValue: Money;
  /**
   * Minimum contract value tax amount based on selected option or the cheapest
   * available option (if none have been selected yet) excluding discount
   */
  minimumContractUndiscountedValueTaxAmount: Money;
  /**
   * Minimum contract value with tax based on selected option or the cheapest
   * available option (if none have been selected yet) excluding discount
   */
  minimumContractUndiscountedValueWithTax: Money;
  minimumContractValue: Money;
  /**
   * Contract discount value on minimum amount based on selected option or the
   * cheapest available option (if none have been selected yet)
   */
  minimumContractValueDiscountAmount: Money;
  minimumContractValueTaxAmount: Money;
  minimumContractValueWithTax: Money;
  name: Scalars['String']['output'];
  position: Scalars['Int']['output'];
  projects: Array<Project>;
  proposal: Proposal;
  serviceTerms?: Maybe<Textile>;
  updatedAt: Scalars['DateTime']['output'];
};

/** Autogenerated input type of ProposalOptionSetDescription */
export type ProposalOptionSetDescriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  /** Slug of Proposal */
  id: Scalars['ID']['input'];
  /** Slug of the option to move */
  optionId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalOptionSetDescription. */
export type ProposalOptionSetDescriptionPayload = {
  __typename: 'ProposalOptionSetDescriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  option?: Maybe<ProposalOption>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalOptionSetName */
export type ProposalOptionSetNameInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of Proposal */
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  /** Slug of the option to move */
  optionId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalOptionSetName. */
export type ProposalOptionSetNamePayload = {
  __typename: 'ProposalOptionSetNamePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  option?: Maybe<ProposalOption>;
  proposal?: Maybe<Proposal>;
};

export type ProposalPriceInterface = {
  currency: Currency;
  /** Price display without tax */
  display: Scalars['String']['output'];
  /** Total amount including discount, excluding tax in human readable form */
  displayTotalAmount: Scalars['String']['output'];
  /** The total discount, in human readable form */
  displayTotalDiscountAmount: Scalars['String']['output'];
  /** The total amount, excluding discount and tax in human readable form */
  displayTotalUndiscountedAmount: Scalars['String']['output'];
  /** Price display with tax */
  displayWithTax: Scalars['String']['output'];
  /** @deprecated Use quantity next to price, not in the price */
  quantity: Scalars['Decimal']['output'];
  /** The tax amount, excluding quantity */
  taxDisplay?: Maybe<Scalars['String']['output']>;
  type: ProposalPriceType;
};

export type ProposalPriceRange = ProposalPriceInterface & {
  __typename: 'ProposalPriceRange';
  currency: Currency;
  /** Price display without tax */
  display: Scalars['String']['output'];
  /** Total amount including discount, excluding tax in human readable form */
  displayTotalAmount: Scalars['String']['output'];
  /** The total discount, in human readable form */
  displayTotalDiscountAmount: Scalars['String']['output'];
  /** The total amount, excluding discount and tax in human readable form */
  displayTotalUndiscountedAmount: Scalars['String']['output'];
  /** Price display with tax */
  displayWithTax: Scalars['String']['output'];
  max: Money;
  min: Money;
  /** @deprecated Use quantity next to price, not in the price */
  quantity: Scalars['Decimal']['output'];
  /** The tax amount, excluding quantity */
  taxDisplay?: Maybe<Scalars['String']['output']>;
  type: ProposalPriceType;
};

export enum ProposalPriceType {
  FIXED = 'FIXED',
  HOURLY = 'HOURLY',
  INCLUDED = 'INCLUDED',
  MINIMUM = 'MINIMUM',
  RANGE = 'RANGE',
  UNIT = 'UNIT',
}

export enum ProposalProposalIncreaseServicePricesWarning {
  ABOVE_THRESHOLD_EFFECTIVE_PERCENTAGE_INCREASE = 'ABOVE_THRESHOLD_EFFECTIVE_PERCENTAGE_INCREASE',
  CONTAINS_NEGATIVE_INCREASE = 'CONTAINS_NEGATIVE_INCREASE',
}

export type ProposalProposedServiceDescription = {
  __typename: 'ProposalProposedServiceDescription';
  /** The type of content being rendered */
  contentType: UserContentType;
  html?: Maybe<Scalars['Html']['output']>;
  /** Available placeholders for terms messages */
  placeholders: Array<Placeholder>;
  /** Preview HTML */
  previewHtml: Scalars['String']['output'];
};

export type ProposalProposedServiceDescriptionPreviewHtmlArgs = {
  content?: InputMaybe<Scalars['String']['input']>;
};

export type ProposalProvidedTemplate = {
  __typename: 'ProposalProvidedTemplate';
  /** The organization or group the author belongs to */
  authorEntity?: Maybe<Scalars['String']['output']>;
  /** The logo of the author entity */
  authorLogoUrl?: Maybe<Scalars['String']['output']>;
  /** The name of author of the template */
  authorName?: Maybe<Scalars['String']['output']>;
  /** Ignition team member who created the template */
  creator: AdminUser;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** time template was last updated */
  lastUpdatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Description of provided templates with formatting */
  longDescription?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  /** Recent proposals created using this template by the practice */
  proposals: ProposalConnection;
  sourceLogoUrl: Scalars['URL']['output'];
  sourceName: Scalars['String']['output'];
  /** The template's visibility */
  visibility: TemplateVisibility;
};

export type ProposalProvidedTemplateProposalsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ProposalProvidedTemplate. */
export type ProposalProvidedTemplateConnection = {
  __typename: 'ProposalProvidedTemplateConnection';
  /** A list of edges. */
  edges: Array<ProposalProvidedTemplateEdge>;
  /** A list of nodes. */
  nodes: Array<ProposalProvidedTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProposalProvidedTemplateEdge = {
  __typename: 'ProposalProvidedTemplateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ProposalProvidedTemplate;
};

export type ProposalRecipient = {
  __typename: 'ProposalRecipient';
  acceptUrl: Scalars['URL']['output'];
  acceptUrlShort: Scalars['ShortURL']['output'];
  /** @deprecated Recipients are not linked to contacts since Signatories were introduced (multi-sig) */
  contact?: Maybe<Contact>;
  email?: Maybe<Scalars['EmailAddress']['output']>;
  id: Scalars['ID']['output'];
};

export type ProposalRecurringBillingSchedule =
  ProposalBillingScheduleInterface & {
    __typename: 'ProposalRecurringBillingSchedule';
    /** Description of the billing cadence e.g. 'every month' */
    cadence?: Maybe<Scalars['String']['output']>;
    /** List of past billing dates that will apply as soon as proposal is accepted or completed */
    catchUpBillingDates: Array<Scalars['Date']['output']>;
    /** Sum of the value of missed billing items that will apply as soon as proposal is accepted or completed */
    catchUpBillingMinimumPrice: Money;
    /** Sum of the tax of value of missed billing items that will apply as soon as proposal is accepted or completed */
    catchUpBillingMinimumPriceTax: Money;
    /** Sum of the value with tax, of missed billing items that will apply as soon as proposal is accepted or completed */
    catchUpBillingMinimumPriceWithTax: Money;
    /** Subtotal of all service price portions on an individual period of this billing schedule */
    catchUpPeriodSubtotal: Money;
    /** Subtotal of all service price portions taxes on an individual period of this billing schedule */
    catchUpPeriodSubtotalTax: Money;
    id: Scalars['ID']['output'];
    name?: Maybe<Scalars['String']['output']>;
    position: Scalars['Int']['output'];
    proposedServicePortions: Array<Portion>;
    recurrence: ProposalBillingStrategyType;
    rule: RecurrenceRule;
    serviceGroup: ServiceGroup;
    start:
      | ProposalStartBillingOnAcceptance
      | ProposalStartBillingOnDate
      | ProposalStartBillingOnProposalEndDate
      | ProposalStartBillingOnProposalStartDate;
    subtitle?: Maybe<Scalars['String']['output']>;
    /** Subtotal of fixed service price portions on this billing schedule including discount */
    subtotal: Money;
    /** Total discount on fixed service price portions on this billing schedule */
    subtotalDiscountAmount: Money;
    /** Tax on subtotal of fixed service price portions on this billing schedule including discount */
    subtotalTax: Money;
    /** Subtotal plus tax of fixed service price portions on this billing schedule including discount */
    subtotalWithTax: Money;
    title: Scalars['String']['output'];
    /** Subtotal of fixed service price portions on this billing schedule not including tax */
    undiscountedSubtotal: Money;
    /** Subtotal plus tax of fixed service price portions on this billing schedule not including discount */
    undiscountedSubtotalWithTax: Money;
  };

export type ProposalRecurringBillingScheduleProposedServicePortionsArgs = {
  filter?: InputMaybe<ProposedServiceFilter>;
};

export type ProposalRecurringBillingStrategy =
  ProposalBillingStrategyInterface & {
    __typename: 'ProposalRecurringBillingStrategy';
    /** List of past billing dates that will apply as soon as proposal is accepted or completed */
    catchUpBillingDates: Array<Scalars['Date']['output']>;
    createdAt: Scalars['DateTime']['output'];
    /** @deprecated use serviceGroup.title instead */
    description: Scalars['String']['output'];
    rule: RecurrenceRule;
    start:
      | ProposalStartBillingOnAcceptance
      | ProposalStartBillingOnDate
      | ProposalStartBillingOnProposalEndDate
      | ProposalStartBillingOnProposalStartDate;
    type: ProposalBillingStrategyType;
    updatedAt: Scalars['DateTime']['output'];
  };

/** Autogenerated input type of ProposalRefreshProposedServiceSmartQuantity */
export type ProposalRefreshProposedServiceSmartQuantityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the proposed service */
  proposedServiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalRefreshProposedServiceSmartQuantity. */
export type ProposalRefreshProposedServiceSmartQuantityPayload = {
  __typename: 'ProposalRefreshProposedServiceSmartQuantityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

/** Autogenerated input type of ProposalRemoveOption */
export type ProposalRemoveOptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the option to remove */
  optionId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalRemoveOption. */
export type ProposalRemoveOptionPayload = {
  __typename: 'ProposalRemoveOptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalRemoveProject */
export type ProposalRemoveProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** slug of the project to remove */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalRemoveProject. */
export type ProposalRemoveProjectPayload = {
  __typename: 'ProposalRemoveProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  option?: Maybe<ProposalOption>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalRemoveProposedService */
export type ProposalRemoveProposedServiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the proposed service to remove */
  proposedServiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalRemoveProposedService. */
export type ProposalRemoveProposedServicePayload = {
  __typename: 'ProposalRemoveProposedServicePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  serviceGroup?: Maybe<ServiceGroup>;
};

/** Autogenerated input type of ProposalRemoveRecipient */
export type ProposalRemoveRecipientInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** proposal slug */
  id: Scalars['ID']['input'];
  /** recipient slug */
  recipientId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalRemoveRecipient. */
export type ProposalRemoveRecipientPayload = {
  __typename: 'ProposalRemoveRecipientPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  recipient?: Maybe<ProposalRecipient>;
};

/** Autogenerated input type of ProposalRemoveServiceGroup */
export type ProposalRemoveServiceGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the service group to remove */
  serviceGroupId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalRemoveServiceGroup. */
export type ProposalRemoveServiceGroupPayload = {
  __typename: 'ProposalRemoveServiceGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalResetOption */
export type ProposalResetOptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** slug of the option to reset */
  optionId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalResetOption. */
export type ProposalResetOptionPayload = {
  __typename: 'ProposalResetOptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  option?: Maybe<ProposalOption>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalResetProject */
export type ProposalResetProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** slug of the project to reset */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalResetProject. */
export type ProposalResetProjectPayload = {
  __typename: 'ProposalResetProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
  proposal?: Maybe<Proposal>;
};

export type ProposalResult = {
  __typename: 'ProposalResult';
  acceptedBy?: Maybe<Scalars['String']['output']>;
  acceptedOn?: Maybe<Scalars['Date']['output']>;
  activeServiceCount: Scalars['Int']['output'];
  client: ClientResult;
  clientSlug: Scalars['String']['output'];
  completedOn?: Maybe<Scalars['Date']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdOn: Scalars['Date']['output'];
  creator: Scalars['String']['output'];
  currency: Scalars['String']['output'];
  effectiveStartDate?: Maybe<Scalars['Date']['output']>;
  emailOpenedByClientOn?: Maybe<Scalars['Date']['output']>;
  emailTemplate?: Maybe<Scalars['String']['output']>;
  expiryDate?: Maybe<Scalars['Date']['output']>;
  hasEverBeenAwaitingAcceptance: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  indefiniteBilling: Scalars['Boolean']['output'];
  isImportedFromLedger: Scalars['Boolean']['output'];
  isRenewable: Scalars['Boolean']['output'];
  isRenewed: Scalars['Boolean']['output'];
  lostBy?: Maybe<Scalars['String']['output']>;
  lostOn?: Maybe<Scalars['Date']['output']>;
  minimumTerm: Scalars['Int']['output'];
  /** The proposal minimum contract value */
  minimumValue: Money;
  /** The minimum value to be taken by automatic billings */
  minimumValueAuto: Money;
  /** @deprecated Use the Money typed minimumValueAuto field instead */
  minimumValueAutoCents: Scalars['BigInt']['output'];
  /** @deprecated Use the Money typed minimumValue field instead */
  minimumValueCents: Scalars['BigInt']['output'];
  /** The minimum value to be taken by manual billings */
  minimumValueManual: Money;
  /** @deprecated Use the Money typed minimumValueManual field instead */
  minimumValueManualCents: Scalars['BigInt']['output'];
  mostRecentActivityCause?: Maybe<Scalars['String']['output']>;
  /** If present, the most recent activity had an error */
  mostRecentActivityError?: Maybe<Scalars['String']['output']>;
  mostRecentActivityOn?: Maybe<Scalars['Date']['output']>;
  name: Scalars['String']['output'];
  optionsCount: Scalars['Int']['output'];
  paymentRequired: Scalars['Boolean']['output'];
  paymentType: Scalars['String']['output'];
  paymentsEnabled: Scalars['Boolean']['output'];
  proposal: Proposal;
  referenceNumber?: Maybe<Scalars['String']['output']>;
  remindersSentCount: Scalars['Int']['output'];
  renewal: Scalars['Boolean']['output'];
  reviewAssignee?: Maybe<Scalars['String']['output']>;
  reviewAssigneeSlug?: Maybe<Scalars['String']['output']>;
  reviewState?: Maybe<ProposalReviewState>;
  sentBy?: Maybe<Scalars['String']['output']>;
  sentCount: Scalars['Int']['output'];
  sentOn?: Maybe<Scalars['String']['output']>;
  serviceNames: Scalars['String']['output'];
  signatoriesCount: Scalars['Int']['output'];
  signedOnBehalf: Scalars['Boolean']['output'];
  signedOnBehalfBy?: Maybe<Scalars['String']['output']>;
  status: ProposalState;
  termsTemplate?: Maybe<Scalars['String']['output']>;
  text: Scalars['String']['output'];
  unrenewableReason?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  viewedByClient: Scalars['Boolean']['output'];
  viewedByClientOn?: Maybe<Scalars['Date']['output']>;
};

/** Autogenerated input type of ProposalReviewApprove */
export type ProposalReviewApproveInput = {
  assigneeId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ProposalReviewApprove. */
export type ProposalReviewApprovePayload = {
  __typename: 'ProposalReviewApprovePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal: Proposal;
};

/** Autogenerated input type of ProposalReviewRequestChange */
export type ProposalReviewRequestChangeInput = {
  assigneeId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ProposalReviewRequestChange. */
export type ProposalReviewRequestChangePayload = {
  __typename: 'ProposalReviewRequestChangePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal: Proposal;
};

/** Autogenerated input type of ProposalReviewRequestReview */
export type ProposalReviewRequestReviewInput = {
  assigneeId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ProposalReviewRequestReview. */
export type ProposalReviewRequestReviewPayload = {
  __typename: 'ProposalReviewRequestReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal: Proposal;
};

export enum ProposalReviewState {
  APPROVED = 'APPROVED',
  CHANGE_REQUESTED = 'CHANGE_REQUESTED',
  NOT_IN_REVIEW = 'NOT_IN_REVIEW',
  REVIEW_REQUESTED = 'REVIEW_REQUESTED',
}

/** Autogenerated input type of ProposalSave */
export type ProposalSaveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSave. */
export type ProposalSavePayload = {
  __typename: 'ProposalSavePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSendToClient */
export type ProposalSendToClientInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSendToClient. */
export type ProposalSendToClientPayload = {
  __typename: 'ProposalSendToClientPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSendToSignatory */
export type ProposalSendToSignatoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** slug of the signatory */
  signatoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSendToSignatory. */
export type ProposalSendToSignatoryPayload = {
  __typename: 'ProposalSendToSignatoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  signatory?: Maybe<ProposalSignatory>;
};

export enum ProposalServicePriceDisplay {
  HIDE = 'HIDE',
  SHOW = 'SHOW',
}

export type ProposalServiceTerms = {
  __typename: 'ProposalServiceTerms';
  /** The type of content being rendered */
  contentType: UserContentType;
  html?: Maybe<Scalars['Html']['output']>;
  /** Available placeholders for terms messages */
  placeholders: Array<Placeholder>;
  /** Preview HTML */
  previewHtml: Scalars['String']['output'];
  /** The unrendered template */
  template?: Maybe<TermsTemplate>;
};

export type ProposalServiceTermsPreviewHtmlArgs = {
  content?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of ProposalSetBillingGroupedBy */
export type ProposalSetBillingGroupedByInput = {
  billingGroupedBy: ProposalBillingGroupedBy;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of the proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetBillingGroupedBy. */
export type ProposalSetBillingGroupedByPayload = {
  __typename: 'ProposalSetBillingGroupedByPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetBrochure */
export type ProposalSetBrochureInput = {
  /** Brochure slug */
  brochureId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of Proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetBrochure. */
export type ProposalSetBrochurePayload = {
  __typename: 'ProposalSetBrochurePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetClient */
export type ProposalSetClientInput = {
  /** ID of client */
  clientId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of Proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetClient. */
export type ProposalSetClientPayload = {
  __typename: 'ProposalSetClientPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  /** Expect validation errors such as 'lock version mismatch' */
  userErrors?: Maybe<Array<UserError>>;
};

/** Autogenerated input type of ProposalSetEmailTemplate */
export type ProposalSetEmailTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the email template */
  templateId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetEmailTemplate. */
export type ProposalSetEmailTemplatePayload = {
  __typename: 'ProposalSetEmailTemplatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetMinimumContractLength */
export type ProposalSetMinimumContractLengthInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** minimum length of the proposed contract in months */
  months: Scalars['Int']['input'];
};

/** Autogenerated return type of ProposalSetMinimumContractLength. */
export type ProposalSetMinimumContractLengthPayload = {
  __typename: 'ProposalSetMinimumContractLengthPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetName */
export type ProposalSetNameInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of Proposal */
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

/** Autogenerated return type of ProposalSetName. */
export type ProposalSetNamePayload = {
  __typename: 'ProposalSetNamePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  /** Expect validation errors such as 'lock version mismatch' or 'name too long (255 chars max)' */
  userErrors?: Maybe<Array<UserError>>;
};

/** Autogenerated input type of ProposalSetNextStepsMessage */
export type ProposalSetNextStepsMessageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  htmlMessage?: InputMaybe<Scalars['Html']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  message?: InputMaybe<Scalars['RichText']['input']>;
};

/** Autogenerated return type of ProposalSetNextStepsMessage. */
export type ProposalSetNextStepsMessagePayload = {
  __typename: 'ProposalSetNextStepsMessagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetOneTimeDateDisplay */
export type ProposalSetOneTimeDateDisplayInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** how one time date proposals should be displayed */
  oneTimeDateDisplay: ProposalOneTimeDateDisplay;
};

/** Autogenerated return type of ProposalSetOneTimeDateDisplay. */
export type ProposalSetOneTimeDateDisplayPayload = {
  __typename: 'ProposalSetOneTimeDateDisplayPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetPaymentSettings */
export type ProposalSetPaymentSettingsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  creditCardAccepted: Scalars['Boolean']['input'];
  directDebitAccepted: Scalars['Boolean']['input'];
  /** Slug of Proposal */
  id: Scalars['ID']['input'];
  paymentMethodRequired: Scalars['Boolean']['input'];
};

/** Autogenerated return type of ProposalSetPaymentSettings. */
export type ProposalSetPaymentSettingsPayload = {
  __typename: 'ProposalSetPaymentSettingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetPersonalisedMessage */
export type ProposalSetPersonalisedMessageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  htmlMessage?: InputMaybe<Scalars['Html']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  message?: InputMaybe<Scalars['RichText']['input']>;
};

/** Autogenerated return type of ProposalSetPersonalisedMessage. */
export type ProposalSetPersonalisedMessagePayload = {
  __typename: 'ProposalSetPersonalisedMessagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetPostAcceptanceVideo */
export type ProposalSetPostAcceptanceVideoInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  videoUrl: Scalars['String']['input'];
};

/** Autogenerated return type of ProposalSetPostAcceptanceVideo. */
export type ProposalSetPostAcceptanceVideoPayload = {
  __typename: 'ProposalSetPostAcceptanceVideoPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetPracticeAsSender */
export type ProposalSetPracticeAsSenderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetPracticeAsSender. */
export type ProposalSetPracticeAsSenderPayload = {
  __typename: 'ProposalSetPracticeAsSenderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetPreAcceptanceVideo */
export type ProposalSetPreAcceptanceVideoInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  videoUrl: Scalars['String']['input'];
};

/** Autogenerated return type of ProposalSetPreAcceptanceVideo. */
export type ProposalSetPreAcceptanceVideoPayload = {
  __typename: 'ProposalSetPreAcceptanceVideoPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetProjectDescription */
export type ProposalSetProjectDescriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the project to set the description of */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetProjectDescription. */
export type ProposalSetProjectDescriptionPayload = {
  __typename: 'ProposalSetProjectDescriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetProjectName */
export type ProposalSetProjectNameInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  /** uuid of the project to set the graphql_name of */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetProjectName. */
export type ProposalSetProjectNamePayload = {
  __typename: 'ProposalSetProjectNamePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetProposalValueDisplay */
export type ProposalSetProposalValueDisplayInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  valueDisplay: ProposalValueDisplay;
};

/** Autogenerated return type of ProposalSetProposalValueDisplay. */
export type ProposalSetProposalValueDisplayPayload = {
  __typename: 'ProposalSetProposalValueDisplayPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetProposedServiceAccount */
export type ProposalSetProposedServiceAccountInput = {
  /** uuid/slug of the account to set */
  accountId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the proposed service to set account for */
  proposedServiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetProposedServiceAccount. */
export type ProposalSetProposedServiceAccountPayload = {
  __typename: 'ProposalSetProposedServiceAccountPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

/** Autogenerated input type of ProposalSetProposedServiceDescription */
export type ProposalSetProposedServiceDescriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['Html']['input'];
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the proposed service */
  proposedServiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetProposedServiceDescription. */
export type ProposalSetProposedServiceDescriptionPayload = {
  __typename: 'ProposalSetProposedServiceDescriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

/** Autogenerated input type of ProposalSetProposedServiceFixedPrice */
export type ProposalSetProposedServiceFixedPriceInput = {
  amount: MoneyInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  discount?: InputMaybe<DiscountRuleInput>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  invoiceStrategy: ProposalInvoiceStrategy;
  /** uuid of the proposed service */
  proposedServiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetProposedServiceFixedPrice. */
export type ProposalSetProposedServiceFixedPricePayload = {
  __typename: 'ProposalSetProposedServiceFixedPricePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

/** Autogenerated input type of ProposalSetProposedServiceIncludedPrice */
export type ProposalSetProposedServiceIncludedPriceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the proposed service */
  proposedServiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetProposedServiceIncludedPrice. */
export type ProposalSetProposedServiceIncludedPricePayload = {
  __typename: 'ProposalSetProposedServiceIncludedPricePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

/** Autogenerated input type of ProposalSetProposedServiceMinimumPrice */
export type ProposalSetProposedServiceMinimumPriceInput = {
  amount: MoneyInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  discount?: InputMaybe<DiscountRuleInput>;
  /** proposal slug */
  id: Scalars['ID']['input'];
  /** proposed service slug */
  proposedServiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetProposedServiceMinimumPrice. */
export type ProposalSetProposedServiceMinimumPricePayload = {
  __typename: 'ProposalSetProposedServiceMinimumPricePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

/** Autogenerated input type of ProposalSetProposedServicePortionInvoiceStrategy */
export type ProposalSetProposedServicePortionInvoiceStrategyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  invoiceStrategy: ProposalInvoiceStrategy;
  /** slug of the portion */
  portionId: Scalars['ID']['input'];
  /** slug of the proposed service */
  proposedServiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetProposedServicePortionInvoiceStrategy. */
export type ProposalSetProposedServicePortionInvoiceStrategyPayload = {
  __typename: 'ProposalSetProposedServicePortionInvoiceStrategyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  portion?: Maybe<Portion>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetProposedServicePortionPrice */
export type ProposalSetProposedServicePortionPriceInput = {
  amount: MoneyInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** slug of the portion */
  portionId: Scalars['ID']['input'];
  /** slug of the proposed service */
  proposedServiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetProposedServicePortionPrice. */
export type ProposalSetProposedServicePortionPricePayload = {
  __typename: 'ProposalSetProposedServicePortionPricePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  portion?: Maybe<Portion>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

/** Autogenerated input type of ProposalSetProposedServicePriceRange */
export type ProposalSetProposedServicePriceRangeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  discount?: InputMaybe<DiscountRuleInput>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  max: MoneyInput;
  min: MoneyInput;
  /** uuid of the proposed service */
  proposedServiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetProposedServicePriceRange. */
export type ProposalSetProposedServicePriceRangePayload = {
  __typename: 'ProposalSetProposedServicePriceRangePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

/** Autogenerated input type of ProposalSetProposedServiceQuantityRule */
export type ProposalSetProposedServiceQuantityRuleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the proposed service */
  proposedServiceId: Scalars['ID']['input'];
  /** Quantity rule */
  quantityRule: QuantityRuleInput;
};

/** Autogenerated return type of ProposalSetProposedServiceQuantityRule. */
export type ProposalSetProposedServiceQuantityRulePayload = {
  __typename: 'ProposalSetProposedServiceQuantityRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

/** Autogenerated input type of ProposalSetProposedServiceTaxExempt */
export type ProposalSetProposedServiceTaxExemptInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the proposed service */
  proposedServiceId: Scalars['ID']['input'];
  /** tax exempt flag */
  taxExempt: Scalars['Boolean']['input'];
};

/** Autogenerated return type of ProposalSetProposedServiceTaxExempt. */
export type ProposalSetProposedServiceTaxExemptPayload = {
  __typename: 'ProposalSetProposedServiceTaxExemptPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

/** Autogenerated input type of ProposalSetProposedServiceTax */
export type ProposalSetProposedServiceTaxInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the proposed service */
  proposedServiceId: Scalars['ID']['input'];
  /** uuid of the tax type */
  taxId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetProposedServiceTax. */
export type ProposalSetProposedServiceTaxPayload = {
  __typename: 'ProposalSetProposedServiceTaxPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

/** Autogenerated input type of ProposalSetProposedServiceUnitPrice */
export type ProposalSetProposedServiceUnitPriceInput = {
  amount: MoneyInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  invoiceStrategy?: InputMaybe<ProposalInvoiceStrategy>;
  /** uuid of the proposed service */
  proposedServiceId: Scalars['ID']['input'];
  unitName: Scalars['String']['input'];
};

/** Autogenerated return type of ProposalSetProposedServiceUnitPrice. */
export type ProposalSetProposedServiceUnitPricePayload = {
  __typename: 'ProposalSetProposedServiceUnitPricePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

/** Autogenerated input type of ProposalSetRecommendedOption */
export type ProposalSetRecommendedOptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of Proposal */
  id: Scalars['ID']['input'];
  /** Slug of the recommending option */
  optionId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetRecommendedOption. */
export type ProposalSetRecommendedOptionPayload = {
  __typename: 'ProposalSetRecommendedOptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetServiceGroupBillingSchedules */
export type ProposalSetServiceGroupBillingSchedulesInput = {
  /** the frontend billing mode to store for future display purposes */
  billingMode: ProposalBillingModeEnum;
  billingSchedules: Array<BillingScheduleInputType>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the service group to set billing rules for */
  serviceGroupId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetServiceGroupBillingSchedules. */
export type ProposalSetServiceGroupBillingSchedulesPayload = {
  __typename: 'ProposalSetServiceGroupBillingSchedulesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  serviceGroup?: Maybe<ServiceGroup>;
};

/** Autogenerated input type of ProposalSetServicePriceDisplay */
export type ProposalSetServicePriceDisplayInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** how service prices should be displayed */
  priceDisplay: ProposalServicePriceDisplay;
};

/** Autogenerated return type of ProposalSetServicePriceDisplay. */
export type ProposalSetServicePriceDisplayPayload = {
  __typename: 'ProposalSetServicePriceDisplayPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetSignatories */
export type ProposalSetSignatoriesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** proposal id */
  id: Scalars['ID']['input'];
  /** id of contact to set as the primary signatory */
  primarySignatoryContactId: Scalars['ID']['input'];
  /** id of contacts to set as secondary signatories */
  secondarySignatoryContactIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of ProposalSetSignatories. */
export type ProposalSetSignatoriesPayload = {
  __typename: 'ProposalSetSignatoriesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetTax */
export type ProposalSetTaxInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of Proposal */
  id: Scalars['ID']['input'];
  /** UUID of the tax */
  taxId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetTax. */
export type ProposalSetTaxPayload = {
  __typename: 'ProposalSetTaxPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  /** Expect validation errors such as 'lock version mismatch' */
  userErrors?: Maybe<Array<UserError>>;
};

/** Autogenerated input type of ProposalSetTermsTemplate */
export type ProposalSetTermsTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the terms template */
  templateId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetTermsTemplate. */
export type ProposalSetTermsTemplatePayload = {
  __typename: 'ProposalSetTermsTemplatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalSetUserAsSender */
export type ProposalSetUserAsSenderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** uuid of the sender user */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalSetUserAsSender. */
export type ProposalSetUserAsSenderPayload = {
  __typename: 'ProposalSetUserAsSenderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

export type ProposalSignatory = {
  __typename: 'ProposalSignatory';
  contact: Contact;
  id: Scalars['ID']['output'];
  /** Portal proposal url */
  proposalUrl: Scalars['URL']['output'];
  /** Portal proposal short url */
  proposalUrlShort: Scalars['ShortURL']['output'];
  role: SignatoryRoleEnum;
  signature?: Maybe<ProposalSignature>;
  state: SignatoryStateEnum;
};

export type ProposalSignature = {
  __typename: 'ProposalSignature';
  id: Scalars['ID']['output'];
  ipAddress: Scalars['IpAddress']['output'];
  location?: Maybe<SignatureLocation>;
  reason?: Maybe<Scalars['String']['output']>;
  /** Datetime the signatory (or user) signed the proposal */
  signedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user who has signed on behalf of a signatory */
  signedOnBehalfBy?: Maybe<User>;
  text: Scalars['String']['output'];
  userAgent: Scalars['String']['output'];
};

/** Source a proposal is created from */
export type ProposalSource =
  | Proposal
  | ProposalCustomTemplate
  | ProposalProvidedTemplate
  | QuickbooksIntegrationRecurringTransaction
  | XeroIntegrationRepeatingInvoice;

export type ProposalStartBillingInterface = {
  delay: Duration;
  type: ProposalStartBillingType;
};

export type ProposalStartBillingOnAcceptance = ProposalStartBillingInterface & {
  __typename: 'ProposalStartBillingOnAcceptance';
  delay: Duration;
  type: ProposalStartBillingType;
};

export type ProposalStartBillingOnDate = ProposalStartBillingInterface & {
  __typename: 'ProposalStartBillingOnDate';
  date: Scalars['Date']['output'];
  delay: Duration;
  type: ProposalStartBillingType;
};

export type ProposalStartBillingOnProposalEndDate =
  ProposalStartBillingInterface & {
    __typename: 'ProposalStartBillingOnProposalEndDate';
    delay: Duration;
    type: ProposalStartBillingType;
  };

export type ProposalStartBillingOnProposalStartDate =
  ProposalStartBillingInterface & {
    __typename: 'ProposalStartBillingOnProposalStartDate';
    delay: Duration;
    type: ProposalStartBillingType;
  };

export enum ProposalStartBillingType {
  /** billing occurs based on proposal acceptance plus optional delay */
  ON_ACCEPTANCE = 'ON_ACCEPTANCE',
  /** billing occurs on a specific date */
  ON_DATE = 'ON_DATE',
  /** billing occurs based on proposal completion date plus optional delay */
  ON_PROPOSAL_END_DATE = 'ON_PROPOSAL_END_DATE',
  /** billing occurs based on proposal start date plus optional delay */
  ON_PROPOSAL_START_DATE = 'ON_PROPOSAL_START_DATE',
}

export enum ProposalStartOn {
  ACCEPTANCE = 'ACCEPTANCE',
  DATE = 'DATE',
}

/** Autogenerated input type of ProposalStartOnAcceptance */
export type ProposalStartOnAcceptanceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalStartOnAcceptance. */
export type ProposalStartOnAcceptancePayload = {
  __typename: 'ProposalStartOnAcceptancePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalStartOnDate */
export type ProposalStartOnDateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** date (ISO Formatted) the proposed contract starts on */
  date: Scalars['Date']['input'];
  /** slug of the proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalStartOnDate. */
export type ProposalStartOnDatePayload = {
  __typename: 'ProposalStartOnDatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

export enum ProposalState {
  ACCEPTED = 'ACCEPTED',
  ARCHIVED = 'ARCHIVED',
  AWAITING_ACCEPTANCE = 'AWAITING_ACCEPTANCE',
  COMPLETED = 'COMPLETED',
  DRAFT = 'DRAFT',
  LOST = 'LOST',
  NEW = 'NEW',
}

/** Autogenerated input type of ProposalTemplateUse */
export type ProposalTemplateUseInput = {
  /** ID of Client */
  clientId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of template */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalTemplateUse. */
export type ProposalTemplateUsePayload = {
  __typename: 'ProposalTemplateUsePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

export type ProposalTerms = {
  __typename: 'ProposalTerms';
  /** @deprecated Use the safeHtml type instead. */
  html?: Maybe<Scalars['String']['output']>;
  safeHtml?: Maybe<Scalars['Html']['output']>;
  template?: Maybe<TermsTemplate>;
};

export type ProposalTermsMessage = {
  __typename: 'ProposalTermsMessage';
  /** The type of content being rendered */
  contentType: UserContentType;
  /**
   * The template rendered in HTML
   * @deprecated Use the safeHtml field instead.
   */
  html?: Maybe<HtmlText>;
  /** Available placeholders for terms messages */
  placeholders: Array<Placeholder>;
  /** Preview HTML */
  previewHtml: Scalars['String']['output'];
  safeHtml?: Maybe<Scalars['Html']['output']>;
  /** The unrendered template */
  template?: Maybe<TermsTemplate>;
};

export type ProposalTermsMessagePreviewHtmlArgs = {
  content?: InputMaybe<Scalars['String']['input']>;
};

export type ProposalUnitPrice = ProposalPriceInterface & {
  __typename: 'ProposalUnitPrice';
  /** Amount excluding tax */
  amount: Money;
  /** Amount including tax */
  amountWithTax: Money;
  currency: Currency;
  /** Price display without tax */
  display: Scalars['String']['output'];
  /** Total Price display including discount, without tax */
  displayTotalAmount: Scalars['String']['output'];
  /** Total amount including discount and tax in human readable form */
  displayTotalAmountWithTax: Scalars['String']['output'];
  /** The total discount, in human readable form */
  displayTotalDiscountAmount: Scalars['String']['output'];
  /** The total amount, excluding discount and tax in human readable form */
  displayTotalUndiscountedAmount: Scalars['String']['output'];
  /** Price display with tax */
  displayWithTax: Scalars['String']['output'];
  invoiceStrategy: ProposalInvoiceStrategy;
  name: Scalars['String']['output'];
  /** @deprecated Use quantity next to price, not in the price */
  quantity: Scalars['Decimal']['output'];
  /** The tax amount, excluding quantity */
  taxDisplay?: Maybe<Scalars['String']['output']>;
  /** Total amount including discount, excluding tax */
  totalAmount: Money;
  /** Total amount including discount and tax */
  totalAmountWithTax: Money;
  /** Total discount */
  totalDiscountAmount: Money;
  /** Total amount excluding discount and tax */
  totalUndiscountedAmount: Money;
  /** Total amount including tax, excluding discount */
  totalUndiscountedAmountWithTax: Money;
  type: ProposalPriceType;
};

/** Autogenerated input type of ProposalUnsetBrochure */
export type ProposalUnsetBrochureInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of Proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalUnsetBrochure. */
export type ProposalUnsetBrochurePayload = {
  __typename: 'ProposalUnsetBrochurePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalUnsetRecommendedOption */
export type ProposalUnsetRecommendedOptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of Proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalUnsetRecommendedOption. */
export type ProposalUnsetRecommendedOptionPayload = {
  __typename: 'ProposalUnsetRecommendedOptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalUpdateProposedService */
export type ProposalUpdateProposedServiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of the proposal. */
  id: Scalars['ID']['input'];
  /** Slug of the proposed service to update. */
  proposedServiceId: Scalars['ID']['input'];
  /** Service input. */
  service: ProposedServiceInput;
};

/** Autogenerated return type of ProposalUpdateProposedService. */
export type ProposalUpdateProposedServicePayload = {
  __typename: 'ProposalUpdateProposedServicePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  proposedService?: Maybe<ProposedService>;
};

export enum ProposalValueDisplay {
  HIDE = 'HIDE',
  SHOW = 'SHOW',
}

export enum ProposalWorkflowSettingsDeployStrategy {
  AUTOMATIC = 'AUTOMATIC',
  MANUAL = 'MANUAL',
}

export enum ProposalWorkflowSettingsWorkflowStructure {
  /** No workflow will be created. */
  NONE = 'NONE',
  /** One workflow will be created for each project. */
  PER_PROJECT = 'PER_PROJECT',
  /** One workflow will be created. */
  PER_PROPOSAL = 'PER_PROPOSAL',
}

export enum ProposalWorkflowStrategyRecurrenceType {
  ONCE_OFF = 'ONCE_OFF',
  RECURRING = 'RECURRING',
}

export enum ProposalWorkflowStrategyStartType {
  ACCEPTANCE = 'ACCEPTANCE',
  DATE = 'DATE',
  START_DATE = 'START_DATE',
}

/** Autogenerated input type of ProposalsBulkCreateFromRecurringTransactions */
export type ProposalsBulkCreateFromRecurringTransactionsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slugs of the recurring transactions to convert */
  ids: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of ProposalsBulkCreateFromRecurringTransactions. */
export type ProposalsBulkCreateFromRecurringTransactionsPayload = {
  __typename: 'ProposalsBulkCreateFromRecurringTransactionsPayload';
  asyncJobGroup: AsyncJobGroup;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ProposalsBulkCreateFromRepeatingInvoices */
export type ProposalsBulkCreateFromRepeatingInvoicesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slugs of the repeating invoices to convert */
  ids: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of ProposalsBulkCreateFromRepeatingInvoices. */
export type ProposalsBulkCreateFromRepeatingInvoicesPayload = {
  __typename: 'ProposalsBulkCreateFromRepeatingInvoicesPayload';
  asyncJobGroup: AsyncJobGroup;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export type ProposalsNotificationSample = {
  __typename: 'ProposalsNotificationSample';
  /** Sample notification body */
  body: Scalars['String']['output'];
  /** Sample notification subject */
  subject: Scalars['String']['output'];
};

export type ProposalsNotifications = {
  __typename: 'ProposalsNotifications';
  /**
   * Sample of email sent to secondary signatories announcing that they will soon be asked for their signature
   * @deprecated use announcementToSecondarySignatoryEmailPreview and the EmailPreviewType instead of NotificationSampleType
   */
  announcementToSecondarySignatoryEmail: ProposalsNotificationSample;
  /** Sample of email sent to secondary signatories announcing that they will soon be asked for their signature */
  announcementToSecondarySignatoryEmailPreview: EmailPreview;
  /**
   * Sample of email sent to signatories when their signature is needed
   * @deprecated use awaitingSignatureToSignatoryEmailPreview and the EmailPreviewType instead of NotificationSampleType
   */
  awaitingSignatureToSignatoryEmail: ProposalsNotificationSample;
  /** Sample of email sent to signatories when their signature is needed */
  awaitingSignatureToSignatoryEmailPreview: EmailPreview;
};

export type ProposedService = {
  __typename: 'ProposedService';
  /** @deprecated Use ledgerItems instead */
  account?: Maybe<Account>;
  /**
   * Checks price and quantity combinations to see if the billing mode can change
   * @deprecated Use canChangeInvoiceStrategy instead
   */
  canChangeBillingMode: Scalars['Boolean']['output'];
  /** Checks price and quantity combinations to see if the billing mode can change */
  canChangeInvoiceStrategy: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  description: Textile;
  descriptionContent: ProposalProposedServiceDescription;
  discount:
    | BillingAmountDiscountRule
    | BillingNoneDiscountRule
    | BillingPercentDiscountRule;
  id: Scalars['ID']['output'];
  /** Indicates if the proposed service was created via client renewal */
  isRenewal: Scalars['Boolean']['output'];
  /** Ledger Items. Currently only supports Xero account */
  ledgerItems?: Maybe<Array<LedgerItem>>;
  name: Scalars['String']['output'];
  /** Proposed service's billing schedule portions */
  portions: Array<Portion>;
  position: Scalars['Int']['output'];
  price:
    | ProposalFixedPrice
    | ProposalIncludedPrice
    | ProposalMinimumPrice
    | ProposalPriceRange
    | ProposalUnitPrice;
  /** Quantity Object containing amounts and rules */
  quantity?: Maybe<
    BillingEstimateQuantityRule | BillingSmartBillingQuantityRule
  >;
  /** The agreed service that is about to be replaced */
  replacesAgreedService?: Maybe<AgreedService>;
  service: Service;
  serviceGroup: ServiceGroup;
  tax: Tax;
  taxExempt: Scalars['Boolean']['output'];
  terms?: Maybe<Textile>;
  updatedAt: Scalars['DateTime']['output'];
};

export type ProposedServiceFilter = {
  priceTypeIn?: InputMaybe<Array<ProposalPriceType>>;
};

/** ProposedService input type for updating a proposed service */
export type ProposedServiceInput = {
  /** ProposedService description */
  description: Scalars['String']['input'];
  /** ProposedService discount rule */
  discountRule?: InputMaybe<DiscountRuleInput>;
  /** Ledger Item, currently only support Xero Account */
  ledgerItem?: InputMaybe<LedgerItemInput>;
  /** ProposedService name */
  name: Scalars['String']['input'];
  /** ProposedService price rule */
  priceRule: ServicePriceRuleInput;
  /** ProposedService quantity rule */
  quantityRule?: InputMaybe<ServiceQuantityRuleInput>;
  /** UUID of tax */
  taxId: Scalars['ID']['input'];
  /** ProposedService terms */
  terms?: InputMaybe<Scalars['String']['input']>;
};

export type ProvidedTemplateFilter = {
  /** Name of the template */
  nameCont?: InputMaybe<Scalars['String']['input']>;
};

export type PublicToken = {
  __typename: 'PublicToken';
  createdAt: Scalars['Date']['output'];
  token: Scalars['String']['output'];
};

/** Input type for quantity rule. */
export type QuantityRuleInput = {
  /** Estimate quantity rule */
  estimate?: InputMaybe<EstimateQuantityRuleInput>;
  /** SmartBilling quantity rule */
  smartBilling?: InputMaybe<SmartBillingQuantityRuleInput>;
};

/** The query root of this schema */
export type Query = {
  __typename: 'Query';
  /** Find an Account by UUID */
  account: Account;
  accountSearch: AccountConnection;
  accounts: AccountConnection;
  acknowledgement?: Maybe<Acknowledgement>;
  acknowledgements: Array<Acknowledgement>;
  /** Agreed Service */
  agreedService?: Maybe<AgreedService>;
  agreedServiceCreatePreview?: Maybe<AgreedServiceCreatePreview>;
  agreedServiceUpdatePreview?: Maybe<AgreedServiceUpdatePreview>;
  /** Current user's ai text generation session */
  aiTextGenerationSession?: Maybe<Session>;
  app?: Maybe<App>;
  apps: AppConnection;
  asyncJobGroup?: Maybe<AsyncJobGroup>;
  brandingTheme: BrandingTheme;
  /** Find a Client */
  client: Client;
  /** Client group */
  clientGroup?: Maybe<ClientGroup>;
  /** List client groups */
  clientGroups?: Maybe<Array<ClientGroup>>;
  clientTagList: Array<Scalars['String']['output']>;
  clientWorkflowStrategy: ClientWorkflowStrategy;
  clients: ClientConnection;
  codeVersion: Scalars['String']['output'];
  collectionsNotificationSettings: CollectionsNotificationSettings;
  /** Find a Contact by UUID */
  contact?: Maybe<Contact>;
  currentPractice: Practice;
  currentUser: User;
  /** search custom templates with filter and paginate results */
  customTemplatesSearch?: Maybe<SearchQuery>;
  customUnitPriceNames: PriceRuleUnitNameConnection;
  dashboard: Dashboard;
  defaultUnitPriceNames: Array<Scalars['String']['output']>;
  detectDuplicateClients: Array<DuplicateClientRecord>;
  /** Find an Engagement (CPE Proposal) by ID */
  engagement: Engagement;
  /** Calculate the billing periods for an Engagement based on the provided attributes. */
  engagementBillingsPreview?: Maybe<EngagementBillings>;
  engagementLetters: CustomerSuccessEngagementLetterConnection;
  engagements: EngagementConnection;
  environment: Environment;
  exports?: Maybe<Export>;
  feature?: Maybe<Feature>;
  featureFlag: FeatureFlag;
  /** Client Billing Invoice */
  invoice?: Maybe<ClientBillingInvoice>;
  ipm: Ipm;
  karbon: Karbon;
  /** Convert enabled oembed url to embeded html */
  oembedVideoLookup?: Maybe<OembedVideo>;
  /** Minimum password strength score */
  passwordStrengthMinimumScore: Scalars['Int']['output'];
  /** Checks the strength score of the given password */
  passwordStrengthScore: Scalars['Int']['output'];
  /** Strong password strength score */
  passwordStrengthStrongScore: Scalars['Int']['output'];
  paymentGateways: PaymentGatewayConnectionType;
  /** Information about the current practice's payments */
  payments: Payments;
  paymentsDisbursal: Disbursal;
  paymentsDisbursals: DisbursalConnection;
  paymentsNotificationsRecipientGroup: PaymentsNotificationsRecipientGroup;
  paymentsPayments: PaymentConnection;
  paymentsRefund: PaymentsRefund;
  plans: PlanConnection;
  /** @deprecated Use queries under `templates` instead */
  practiceTemplate?: Maybe<
    | BankAccountFailureEmailTemplate
    | BankAccountVerificationEmailTemplate
    | EmailTemplate
    | EngagementLetterTemplate
    | IntroMessageTemplate
    | NewGroupProposalEmailTemplate
    | NewProposalEmailTemplate
    | NewSubmissionEmailTemplate
    | NextStepsMessageTemplate
    | ProposalAcceptedBrowserTemplate
    | ProposalAcceptedEmailTemplate
    | SystemTemplate
    | TermsTemplate
  >;
  /** @deprecated Use queries under `templates` instead */
  practiceTemplates?: Maybe<PracticeTemplateConnection>;
  proconnect: Proconnect;
  proposal: Proposal;
  proposalCustomTemplate?: Maybe<ProposalCustomTemplate>;
  proposalCustomTemplates: ProposalCustomTemplateConnection;
  proposalIncreaseServicePricesPreview?: Maybe<ProposalIncreaseServicePricesPreview>;
  proposalProvidedTemplate?: Maybe<ProposalProvidedTemplate>;
  proposalProvidedTemplates: ProposalProvidedTemplateConnection;
  /** Proposal terms message */
  proposalTermsTemplate: ProposalTermsMessage;
  proposals: ProposalConnection;
  /** provided templates with filter and paginate results */
  providedTemplatesSearch?: Maybe<SearchQuery>;
  quickbooks: Quickbooks;
  search: Search;
  /** Find a Service by UUID, ID or Slug */
  service: Service;
  /** List service groups */
  serviceGroups?: Maybe<Array<ServiceGroupType>>;
  /** List of the Service Origins available for this practice */
  serviceOrigins?: Maybe<Array<ServiceOriginType>>;
  services: ServiceConnection;
  servicesSearch?: Maybe<SearchQuery>;
  /** List of the available Smart Billing dynamic quantity options e.g. making billing quantity dynamic based on headcount. */
  smartBillingQuantityOptions: SmartBillingQuantityOptionConnection;
  /** Preview of a subscription. */
  subscriptionPreview?: Maybe<SubscriptionPreview>;
  tax: Tax;
  taxes: TaxConnection;
  templates: Templates;
  upcomingBusinessDays: Array<Scalars['Date']['output']>;
  /** Find a User by ID */
  user: User;
  /** Excluding support users */
  users: UserConnection;
  xero?: Maybe<Xero>;
  xpm?: Maybe<Xpm>;
};

/** The query root of this schema */
export type QueryAccountArgs = {
  uuid: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryAccountSearchArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query: AccountQuery;
};

/** The query root of this schema */
export type QueryAccountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryAcknowledgementArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryAcknowledgementsArgs = {
  filter?: InputMaybe<AcknowledgeFilter>;
};

/** The query root of this schema */
export type QueryAgreedServiceArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryAgreedServiceCreatePreviewArgs = {
  agreedServiceInput: AgreedServiceInput;
  clientId: Scalars['ID']['input'];
  notification?: InputMaybe<NotificationInput>;
  paymentMethodId?: InputMaybe<Scalars['ID']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
};

/** The query root of this schema */
export type QueryAgreedServiceUpdatePreviewArgs = {
  agreedServiceInput: AgreedServiceInput;
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryAiTextGenerationSessionArgs = {
  sessionId: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryAppArgs = {
  name: Scalars['String']['input'];
};

/** The query root of this schema */
export type QueryAppsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AppFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryAsyncJobGroupArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryClientArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryClientGroupArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryClientWorkflowStrategyArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryClientsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ClientFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryContactArgs = {
  uuid: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryCustomTemplatesSearchArgs = {
  filter?: InputMaybe<CustomTemplateFilter>;
  pagination?: InputMaybe<PaginationInput>;
};

/** The query root of this schema */
export type QueryCustomUnitPriceNamesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryDetectDuplicateClientsArgs = {
  appName: Scalars['String']['input'];
  searchFilters?: InputMaybe<AppClientFilterInputType>;
  selectAll?: InputMaybe<Scalars['Boolean']['input']>;
  selectedAppClientIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** The query root of this schema */
export type QueryEngagementArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

/** The query root of this schema */
export type QueryEngagementBillingsPreviewArgs = {
  acceptedOn?: InputMaybe<Scalars['Date']['input']>;
  billingPeriod: EngagementBillingPeriod;
  endsOn: Scalars['Date']['input'];
  monthlyInvoiceDay?: InputMaybe<Scalars['Int']['input']>;
  startsOn: Scalars['Date']['input'];
};

/** The query root of this schema */
export type QueryEngagementLettersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryEngagementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryExportsArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryFeatureArgs = {
  id: Scalars['String']['input'];
};

/** The query root of this schema */
export type QueryFeatureFlagArgs = {
  id: Scalars['String']['input'];
};

/** The query root of this schema */
export type QueryInvoiceArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryOembedVideoLookupArgs = {
  url: Scalars['URL']['input'];
};

/** The query root of this schema */
export type QueryPasswordStrengthScoreArgs = {
  password: Scalars['String']['input'];
};

/** The query root of this schema */
export type QueryPaymentGatewaysArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryPaymentsDisbursalArgs = {
  id: Scalars['String']['input'];
};

/** The query root of this schema */
export type QueryPaymentsDisbursalsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<DisbursalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryPaymentsPaymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PaymentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryPaymentsRefundArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryPlansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  planVersion?: InputMaybe<PlanVersion>;
};

/** The query root of this schema */
export type QueryPracticeTemplateArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryPracticeTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<TemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryProposalArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryProposalCustomTemplateArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryProposalCustomTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<CustomTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryProposalIncreaseServicePricesPreviewArgs = {
  id: Scalars['ID']['input'];
  priceIncreaseInput: PriceIncreaseInputType;
};

/** The query root of this schema */
export type QueryProposalProvidedTemplateArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryProposalProvidedTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ProvidedTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryProposalsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ProposalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryProvidedTemplatesSearchArgs = {
  filter?: InputMaybe<ProvidedTemplateFilter>;
  pagination?: InputMaybe<PaginationInput>;
};

/** The query root of this schema */
export type QueryServiceArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryServicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ServiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryServicesSearchArgs = {
  asyncJobGroupId?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ServiceFilter>;
  pagination?: InputMaybe<PaginationInput>;
  sort?: InputMaybe<SearchQuerySortInput>;
};

/** The query root of this schema */
export type QuerySmartBillingQuantityOptionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QuerySubscriptionPreviewArgs = {
  couponCode?: InputMaybe<Scalars['String']['input']>;
  planCode: Scalars['String']['input'];
};

/** The query root of this schema */
export type QueryTaxArgs = {
  id: Scalars['ID']['input'];
};

/** The query root of this schema */
export type QueryTaxesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<TaxFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The query root of this schema */
export type QueryUpcomingBusinessDaysArgs = {
  count: Scalars['Int']['input'];
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** The query root of this schema */
export type QueryUserArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  uuid?: InputMaybe<Scalars['ID']['input']>;
};

/** The query root of this schema */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of QuickbooksDisconnect */
export type QuickbooksDisconnectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of QuickbooksDisconnect. */
export type QuickbooksDisconnectPayload = {
  __typename: 'QuickbooksDisconnectPayload';
  app: App;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  quickbooks?: Maybe<Quickbooks>;
};

/** Autogenerated input type of QuickbooksEnable */
export type QuickbooksEnableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of QuickbooksEnable. */
export type QuickbooksEnablePayload = {
  __typename: 'QuickbooksEnablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  quickbooks?: Maybe<Quickbooks>;
};

export type QuickbooksIntegrationLine = {
  __typename: 'QuickbooksIntegrationLine';
  /** Line amount */
  amount: Money;
  /** Description of the line */
  description?: Maybe<Scalars['String']['output']>;
  /** Internal slug of the recuring transaction line */
  id: Scalars['ID']['output'];
  /** Name of associated item (if present) */
  itemName?: Maybe<Scalars['String']['output']>;
  /** Line number */
  lineNum: Scalars['Int']['output'];
  /** Quantity */
  quantity?: Maybe<Scalars['String']['output']>;
  /** Unit price */
  unitPrice: Money;
};

export type QuickbooksIntegrationRecurringTransaction = {
  __typename: 'QuickbooksIntegrationRecurringTransaction';
  /** List of jobs associated with the recurring transaction */
  asyncJobs?: Maybe<Array<AsyncJob>>;
  /** Name of the Customer associated with the recurring transaction */
  customerName?: Maybe<Scalars['String']['output']>;
  /** When do we finish invoicing (optional) */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** External URL for recurring transaction */
  externalUrl?: Maybe<Scalars['String']['output']>;
  /** Internal slug of the recurring transaction */
  id: Scalars['ID']['output'];
  /** Interval type */
  intervalType?: Maybe<RecurringTransactionIntervalTypeEnum>;
  /** List of Quickbooks Recurring Transaction Lines */
  lines?: Maybe<Array<QuickbooksIntegrationLine>>;
  /** When do we finish invoicing (optional) */
  nextDate?: Maybe<Scalars['Date']['output']>;
  /** External Quickbooks ID of the recurring transaction */
  quickbooksId: Scalars['String']['output'];
  /** Automated, Reminded or Unscheduled */
  recurType?: Maybe<Scalars['String']['output']>;
  /** Name of the Recurring Transaction */
  recurringTemplateName?: Maybe<Scalars['String']['output']>;
  /** Total amount */
  totalAmount: Money;
  /** Type of Recurring Transaction */
  type: RecurringTransactionTypeEnum;
};

export type QuickbooksItem = {
  __typename: 'QuickbooksItem';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

/** The connection type for QuickbooksItem. */
export type QuickbooksItemConnection = {
  __typename: 'QuickbooksItemConnection';
  /** A list of edges. */
  edges: Array<QuickbooksItemEdge>;
  /** A list of nodes. */
  nodes: Array<QuickbooksItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type QuickbooksItemEdge = {
  __typename: 'QuickbooksItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: QuickbooksItem;
};

export type QuickbooksSettings = {
  __typename: 'QuickbooksSettings';
  confirmed: Scalars['Boolean']['output'];
  createInvoices: Scalars['Boolean']['output'];
  defaultItem?: Maybe<QuickbooksItem>;
  defaultTerms: Scalars['Int']['output'];
  invoicesShowServiceDescription: Scalars['Boolean']['output'];
  recurringTerms: Scalars['Int']['output'];
  syncClientName: Scalars['Boolean']['output'];
};

export type QuickbooksSettingsInput = {
  createInvoices: Scalars['Boolean']['input'];
  defaultItemId: Scalars['ID']['input'];
  defaultTerms: Scalars['Int']['input'];
  invoicesShowServiceDescription: Scalars['Boolean']['input'];
  recurringTerms: Scalars['Int']['input'];
  syncClientName: Scalars['Boolean']['input'];
};

/** Autogenerated input type of QuickbooksSettingsUpdate */
export type QuickbooksSettingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  settings?: InputMaybe<QuickbooksSettingsInput>;
};

/** Autogenerated return type of QuickbooksSettingsUpdate. */
export type QuickbooksSettingsUpdatePayload = {
  __typename: 'QuickbooksSettingsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  quickbooks?: Maybe<Quickbooks>;
};

export enum QuickbooksState {
  AUTHORISED = 'AUTHORISED',
  CONNECTED = 'CONNECTED',
  DISCONNECTED = 'DISCONNECTED',
  ENABLED = 'ENABLED',
  UNAUTHORISED = 'UNAUTHORISED',
  UNAVAILABLE = 'UNAVAILABLE',
}

export type QuickbooksTaxCode = {
  __typename: 'QuickbooksTaxCode';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  salesTaxPercentage: Percentage;
  /** @deprecated Use sales_tax_percentage */
  salesTaxRate: Scalars['Decimal']['output'];
};

export type QuickbooksTaxCodeMapping = {
  __typename: 'QuickbooksTaxCodeMapping';
  id: Scalars['ID']['output'];
  referenceNumber: Scalars['ID']['output'];
  /** Ignition tax type */
  tax: Tax;
  /** QuickBooks integration tax code */
  taxCode?: Maybe<QuickbooksTaxCode>;
};

/** The connection type for QuickbooksTaxCodeMapping. */
export type QuickbooksTaxCodeMappingConnectionType = {
  __typename: 'QuickbooksTaxCodeMappingConnectionType';
  areAllMapped: Scalars['Boolean']['output'];
  /** A list of edges. */
  edges: Array<TaxCodeMappingEdge>;
  /** A list of nodes. */
  nodes: Array<QuickbooksTaxCodeMapping>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of QuickbooksTaxCodeMappingCreate */
export type QuickbooksTaxCodeMappingCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ignitionapp tax uuid */
  ignitionappTaxId: Scalars['ID']['input'];
  /** tax code uuid */
  taxCodeId: Scalars['ID']['input'];
};

/** Autogenerated return type of QuickbooksTaxCodeMappingCreate. */
export type QuickbooksTaxCodeMappingCreatePayload = {
  __typename: 'QuickbooksTaxCodeMappingCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  quickbooks?: Maybe<Quickbooks>;
};

export type QuickbooksTaxCodeMappingInput = {
  /** UUID of PI Tax */
  ignitionappTaxId: Scalars['ID']['input'];
  /** UUID of Tax Code */
  taxCodeId: Scalars['ID']['input'];
};

/** Autogenerated input type of QuickbooksTaxCodeMappingsUpdate */
export type QuickbooksTaxCodeMappingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  mappings: Array<QuickbooksTaxCodeMappingInput>;
};

/** Autogenerated return type of QuickbooksTaxCodeMappingsUpdate. */
export type QuickbooksTaxCodeMappingsUpdatePayload = {
  __typename: 'QuickbooksTaxCodeMappingsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  quickbooks?: Maybe<Quickbooks>;
};

/** Input type for range price rule. */
export type RangePriceRuleInput = {
  /** Maximum price amount */
  max: MoneyInput;
  /** Minimum price amount */
  min: MoneyInput;
};

export type Recipient = {
  __typename: 'Recipient';
  emailAddress: Scalars['EmailAddress']['output'];
};

export type RecurrenceRule = {
  __typename: 'RecurrenceRule';
  /** returns the frequency count, eg. 12, or nil for continuous schedules */
  count?: Maybe<Scalars['Int']['output']>;
  /** returns the equivalent YEARLY, MONTHLY, WEEKLY, or DAILY value */
  frequency: FrequencyTypeEnum;
  /** representation of the recurrence rule in ical rule encoded format */
  ical: Scalars['String']['output'];
};

export enum RecurringTransactionIntervalTypeEnum {
  DAILY = 'DAILY',
  MONTHLY = 'MONTHLY',
  WEEKLY = 'WEEKLY',
  YEARLY = 'YEARLY',
}

export enum RecurringTransactionTypeEnum {
  BILL = 'BILL',
  CREDIT_MEMO = 'CREDIT_MEMO',
  DEPOSIT = 'DEPOSIT',
  ESTIMATE = 'ESTIMATE',
  INVOICE = 'INVOICE',
  JOURNAL_ENTRY = 'JOURNAL_ENTRY',
  PURCHASE = 'PURCHASE',
  PURCHASE_ORDER = 'PURCHASE_ORDER',
  REFUND_RECEIPT = 'REFUND_RECEIPT',
  SALES_RECEIPT = 'SALES_RECEIPT',
  TRANSFER = 'TRANSFER',
  VENDOR_CREDIT = 'VENDOR_CREDIT',
}

/** Referral made by a user */
export type Referral = {
  __typename: 'Referral';
  /** email of person being referred */
  email: Scalars['String']['output'];
  /** id of referral */
  id: Scalars['ID']['output'];
  /** total rewards earned by referral */
  rewards: Array<Reward>;
};

/** The connection type for Referral. */
export type ReferralConnection = {
  __typename: 'ReferralConnection';
  /** A list of edges. */
  edges: Array<ReferralEdge>;
  newCount: Scalars['Int']['output'];
  /** A list of nodes. */
  nodes: Array<Referral>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  successfulCount: Scalars['Int']['output'];
  totalRewards: ReferralTotalRewards;
};

export type ReferralDetails = {
  __typename: 'ReferralDetails';
  /** amount of reward */
  amount: Money;
  /** email of person being referred */
  email: Scalars['String']['output'];
  /** id of referral */
  id: Scalars['ID']['output'];
  /** status of referral */
  status: ReferralStatus;
};

/** An edge in a connection. */
export type ReferralEdge = {
  __typename: 'ReferralEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Referral;
};

export enum ReferralStatus {
  /** rewards approved but not yet paid out */
  APPROVED = 'APPROVED',
  /** rewards rejected */
  DECLINED = 'DECLINED',
  /** Rewarding is in a brief pause so the company can investigate before approving or declining */
  HOLD = 'HOLD',
  /** rewards is paid and available for collection */
  PAID = 'PAID',
  /** rewards waiting for review */
  PENDING = 'PENDING',
  /** referree signed up and trialing the product */
  TRIAL = 'TRIAL',
}

/** Total rewards earned on a referral */
export type ReferralTotalRewards = {
  __typename: 'ReferralTotalRewards';
  /** rewards approved to be paid */
  available: Money;
  /** rewards paid */
  earned: Money;
};

/** An uploaded image which may be dynamically resized. */
export type ResizeableImage = {
  __typename: 'ResizeableImage';
  /** The filename of the uploaded image. */
  filename: Scalars['String']['output'];
  /** The mimetype of the uploaded, if available. */
  mimetype?: Maybe<Scalars['String']['output']>;
  /** The size of the uploaded image in bytes, if available. */
  size: Scalars['Int']['output'];
  /** The public URL of the uploaded image. */
  url: Scalars['URL']['output'];
};

/** An uploaded image which may be dynamically resized. */
export type ResizeableImageUrlArgs = {
  fit?: InputMaybe<ResizeableImageFit>;
  height?: InputMaybe<Scalars['Int']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

export enum ResizeableImageFit {
  /**
   * Preserve the aspect ratio, resize the image to be as large as possible while
   * ensuring its dimensions are less than or equal to both those specified.
   */
  CLIP = 'CLIP',
  /** Preserve the aspect ratio, ensure the image covers both provided dimensions by clipping/cropping to fit. */
  CROP = 'CROP',
  /** Ignore the aspect ratio of the provided image and stretch to both provided dimensions. */
  MAX = 'MAX',
  /** Do not enlarge if the dimensions of the provided image are already less than the specified width or height. */
  SCALE = 'SCALE',
}

/** The connection type for SearchResult. */
export type ResultConnection = {
  __typename: 'ResultConnection';
  /** A list of edges. */
  edges: Array<ResultEdge>;
  ids: Array<Scalars['ID']['output']>;
  /** A list of nodes. */
  nodes: Array<SearchResult>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ResultEdge = {
  __typename: 'ResultEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: SearchResult;
};

export type RevenueBracket = {
  __typename: 'RevenueBracket';
  label: Scalars['String']['output'];
  value: MaturityIndexRevenueBracketValueEnum;
};

/** reward for an action on the referral flow */
export type Reward = {
  __typename: 'Reward';
  /** amount of reward */
  amount: Money;
  /** email of referee who earned the reward */
  email: Scalars['String']['output'];
  /** id of reward */
  id: Scalars['ID']['output'];
  /** status of reward */
  status: RewardStatus;
};

/** The connection type for Reward. */
export type RewardConnection = {
  __typename: 'RewardConnection';
  /** A list of edges. */
  edges: Array<RewardEdge>;
  /** A list of nodes. */
  nodes: Array<Reward>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RewardEdge = {
  __typename: 'RewardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Reward;
};

export enum RewardStatus {
  /** rewards approved but not yet paid out */
  APPROVED = 'APPROVED',
  /** rewards rejected */
  DECLINED = 'DECLINED',
  /** rewards paid out */
  PAID = 'PAID',
  /** rewards waiting to be approved or declined */
  PENDING = 'PENDING',
}

export type Schedule = {
  __typename: 'Schedule';
  /** The dates included in this schedule. For CONTINUOUS schedules, only dates from the the first 24 months are returned. */
  dates: Array<Scalars['Date']['output']>;
  /** The human-readable description of the schedule. */
  description?: Maybe<Scalars['String']['output']>;
  /** The date from which the schedule stops recurring. Will be NULL for CONTINUOUS schedules. */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** The ical representation of the schedule in RFC5545 format. */
  ical: Scalars['String']['output'];
  /**
   * The human-readable description for how often this schedule recurs. Examples: -
   * "1 month" - "2 quarters" - "2 months and 2 days"
   */
  recurrenceDescription: Scalars['String']['output'];
  /** The date from which the schedule starts recurring. */
  startDate: Scalars['Date']['output'];
  /** The schedule type. */
  type: ScheduleTypeEnum;
};

export type ScheduleItem = {
  __typename: 'ScheduleItem';
  billOn: Scalars['Date']['output'];
  billingName?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use billOn instead */
  date: Scalars['Date']['output'];
  id: Scalars['ID']['output'];
  invoiceStrategy?: Maybe<ProposalInvoiceStrategy>;
  isBilled: Scalars['Boolean']['output'];
  price: Money;
};

export enum ScheduleTypeEnum {
  CONTINUOUS = 'CONTINUOUS',
  NON_RECURRING = 'NON_RECURRING',
  RECURRING = 'RECURRING',
}

export type Search = {
  __typename: 'Search';
  attributeValues: Array<Scalars['String']['output']>;
  pagedQuery: SearchQuery;
  /** @deprecated use pagedResults */
  searchQuery: Array<SearchResult>;
};

export type SearchAttributeValuesArgs = {
  attribute: Scalars['String']['input'];
  contains?: InputMaybe<Scalars['String']['input']>;
  type: SearchType;
};

export type SearchPagedQueryArgs = {
  booleanFilters?: InputMaybe<Array<SearchQueryBooleanFilterInput>>;
  dateFilters?: InputMaybe<Array<SearchQueryDateFilterInput>>;
  numberFilters?: InputMaybe<Array<SearchQueryNumberFilterInput>>;
  pagination?: InputMaybe<PaginationInput>;
  relativeDateFilters?: InputMaybe<Array<SearchQueryRelativeDateFilterInput>>;
  sort?: InputMaybe<SearchQuerySortInput>;
  textFilters?: InputMaybe<Array<SearchQueryTextFilterInput>>;
  type: SearchType;
};

export type SearchSearchQueryArgs = {
  booleanFilters?: InputMaybe<Array<SearchQueryBooleanFilterInput>>;
  dateFilters?: InputMaybe<Array<SearchQueryDateFilterInput>>;
  numberFilters?: InputMaybe<Array<SearchQueryNumberFilterInput>>;
  pagination?: InputMaybe<PaginationInput>;
  sort?: InputMaybe<SearchQuerySortInput>;
  textFilters?: InputMaybe<Array<SearchQueryTextFilterInput>>;
  type: SearchType;
};

export enum SearchBooleanFilterCondition {
  EQUALS = 'EQUALS',
}

export enum SearchDateFilterCondition {
  AFTER = 'AFTER',
  BEFORE = 'BEFORE',
  BETWEEN = 'BETWEEN',
  EQUALS = 'EQUALS',
  HAS_NO_VALUE = 'HAS_NO_VALUE',
  HAS_VALUE = 'HAS_VALUE',
}

/** Autogenerated input type of SearchExportCsv */
export type SearchExportCsvInput = {
  booleanFilters?: InputMaybe<Array<SearchQueryBooleanFilterInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dateFilters?: InputMaybe<Array<SearchQueryDateFilterInput>>;
  numberFilters?: InputMaybe<Array<SearchQueryNumberFilterInput>>;
  relativeDateFilters?: InputMaybe<Array<SearchQueryRelativeDateFilterInput>>;
  sort?: InputMaybe<SearchQuerySortInput>;
  textFilters?: InputMaybe<Array<SearchQueryTextFilterInput>>;
  type: SearchType;
};

/** Autogenerated return type of SearchExportCsv. */
export type SearchExportCsvPayload = {
  __typename: 'SearchExportCsvPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export enum SearchNumberFilterCondition {
  AFTER = 'AFTER',
  BEFORE = 'BEFORE',
  BETWEEN = 'BETWEEN',
  EQUALS = 'EQUALS',
}

export type SearchQuery = {
  __typename: 'SearchQuery';
  results: ResultConnection;
  totalCount: Scalars['Int']['output'];
  totalValue?: Maybe<Money>;
};

export type SearchQueryResultsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type SearchQueryBooleanFilterInput = {
  attribute: Scalars['String']['input'];
  condition: SearchBooleanFilterCondition;
  relation?: InputMaybe<SearchType>;
  values: Array<Scalars['Boolean']['input']>;
};

export type SearchQueryDateFilterInput = {
  attribute: Scalars['String']['input'];
  condition: SearchDateFilterCondition;
  relation?: InputMaybe<SearchType>;
  values: Array<Scalars['Date']['input']>;
};

export type SearchQueryNumberFilterInput = {
  attribute: Scalars['String']['input'];
  condition: SearchNumberFilterCondition;
  relation?: InputMaybe<SearchType>;
  values: Array<Scalars['Decimal']['input']>;
};

export type SearchQueryRelativeDateFilterInput = {
  attribute: Scalars['String']['input'];
  condition: SearchRelativeDateFilterCondition;
  relation?: InputMaybe<SearchType>;
  values: Array<DurationInput>;
};

export type SearchQuerySortInput = {
  attribute: Scalars['String']['input'];
  direction: SearchSortDirection;
  relation?: InputMaybe<SearchType>;
};

export type SearchQueryTextFilterInput = {
  attribute: Scalars['String']['input'];
  condition: SearchTextFilterCondition;
  relation?: InputMaybe<SearchType>;
  values: Array<Scalars['String']['input']>;
};

export enum SearchRelativeDateFilterCondition {
  NEXT = 'NEXT',
  PREVIOUS = 'PREVIOUS',
}

export type SearchResult =
  | AppClientResult
  | BillingItemResult
  | ClientResult
  | IgnitionAppServiceType
  | ProposalCustomTemplate
  | ProposalProvidedTemplate
  | ProposalResult
  | QuickbooksIntegrationRecurringTransaction
  | Service
  | XeroIntegrationRepeatingInvoice;

export enum SearchSortDirection {
  /** asc */
  ASC = 'ASC',
  /** desc */
  DESC = 'DESC',
}

export enum SearchTextFilterCondition {
  ANY_OF = 'ANY_OF',
  CONTAINS = 'CONTAINS',
  EQUALS = 'EQUALS',
  HAS_NO_VALUE = 'HAS_NO_VALUE',
}

export enum SearchType {
  APP_CLIENT = 'APP_CLIENT',
  ASYNC_JOB = 'ASYNC_JOB',
  ASYNC_JOB_GROUP = 'ASYNC_JOB_GROUP',
  BILLING_ITEM = 'BILLING_ITEM',
  CLIENT = 'CLIENT',
  CLIENT_BULK_ACTION = 'CLIENT_BULK_ACTION',
  PROPOSAL = 'PROPOSAL',
  PROPOSAL_BULK_ACTION = 'PROPOSAL_BULK_ACTION',
}

export type SelectedTrackingOptionInput = {
  /** The ID of the Xero tracking category */
  categoryId: Scalars['ID']['input'];
  /** The ID of the selected option for this category */
  optionId: Scalars['ID']['input'];
};

/** Autogenerated input type of SendDemoProposal */
export type SendDemoProposalInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['EmailAddress']['input'];
};

/** Autogenerated return type of SendDemoProposal. */
export type SendDemoProposalPayload = {
  __typename: 'SendDemoProposalPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of SendPaymentMethodRequestToClients */
export type SendPaymentMethodRequestToClientsInput = {
  /** A list of client ids */
  clientIds: Array<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Allowed payment methods in the client portal request */
  creditCardAccepted: Scalars['Boolean']['input'];
  /** Allowed payment methods in the client portal request */
  directDebitAccepted: Scalars['Boolean']['input'];
  /** Message text included in the notification to the client */
  messageText: Scalars['String']['input'];
  /** Use this payment method for future billing items */
  useMethodInFuture: Scalars['Boolean']['input'];
};

/** Autogenerated return type of SendPaymentMethodRequestToClients. */
export type SendPaymentMethodRequestToClientsPayload = {
  __typename: 'SendPaymentMethodRequestToClientsPayload';
  /** Async Job Group for the notifications sending in the background */
  asyncJobGroup?: Maybe<AsyncJobGroup>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  paymentMethodRequestGroup: PaymentMethodRequestGroup;
};

/** Autogenerated input type of SendTestProposal */
export type SendTestProposalInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['EmailAddress']['input'];
  /** slug of the proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of SendTestProposal. */
export type SendTestProposalPayload = {
  __typename: 'SendTestProposalPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

export type Service = {
  __typename: 'Service';
  account?: Maybe<Account>;
  billingLabel: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  defaultBillingType: DefaultBillingType;
  /** A description of the Service */
  description: Scalars['String']['output'];
  /** A description of the Service in Rendered Textile HTML without div wrapper */
  descriptionHtml: Scalars['String']['output'];
  /** A description of the Service in Textile */
  descriptionTextile: Scalars['String']['output'];
  /** checks to see if the description is blank (true = blank) */
  hasBlankDescription: Scalars['Boolean']['output'];
  /** @deprecated Use unitPrice instead */
  hourlyPrice?: Maybe<Money>;
  id: Scalars['ID']['output'];
  invoiceStrategy?: Maybe<ServiceInvoiceStrategy>;
  ledgerItems: Array<LedgerItem>;
  maxPrice?: Maybe<Money>;
  minPrice?: Maybe<Money>;
  /** The name of the Service */
  name: Scalars['String']['output'];
  priceForDisplay?: Maybe<Scalars['String']['output']>;
  priceRule:
    | BillingFixedPriceRule
    | BillingIncludedPriceRule
    | BillingMinimumPriceRule
    | BillingRangePriceRule
    | BillingUnitPriceRule;
  priceType?: Maybe<ServicePriceType>;
  /** Publically available (legacy CPE field) */
  publicallyAvailable: Scalars['Boolean']['output'];
  referenceNumber: Scalars['ID']['output'];
  /** Sequence position (legacy CPE field) */
  sequence?: Maybe<Scalars['Int']['output']>;
  /** Service group (legacy CPE field) */
  serviceGroup?: Maybe<ServiceGroupType>;
  /** Short description of the service (legacy CPE field) */
  shortDescription?: Maybe<Scalars['String']['output']>;
  /** The slug of the Service */
  slug: Scalars['ID']['output'];
  standardPrice?: Maybe<Money>;
  tax: Tax;
  /** (QBO US) Tax exempt (legacy CPE field) */
  taxExempt: Scalars['Boolean']['output'];
  terms?: Maybe<Scalars['String']['output']>;
  termsHtml?: Maybe<Scalars['String']['output']>;
  token?: Maybe<Scalars['String']['output']>;
  /** Unit name for service's price */
  unitName?: Maybe<Scalars['String']['output']>;
  unitPrice?: Maybe<Money>;
  updatedAt: Scalars['DateTime']['output'];
  /** Weekly price (legacy CPE field) */
  weeklyPrice?: Maybe<Money>;
  workflowTemplates: WorkflowTemplateTypeConnection;
};

export type ServiceWorkflowTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ServiceAddWorkflowTemplateMappings */
export type ServiceAddWorkflowTemplateMappingsInput = {
  /** The name of the App the templates belong to */
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The uuid of the Service to map */
  id: Scalars['ID']['input'];
  /** The Workflow Templates Ids to map to */
  workflowTemplateIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of ServiceAddWorkflowTemplateMappings. */
export type ServiceAddWorkflowTemplateMappingsPayload = {
  __typename: 'ServiceAddWorkflowTemplateMappingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  service?: Maybe<Service>;
};

/** The connection type for Service. */
export type ServiceConnection = {
  __typename: 'ServiceConnection';
  /** A list of edges. */
  edges: Array<ServiceEdge>;
  /** A list of nodes. */
  nodes: Array<Service>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ServiceCreate */
export type ServiceCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  service: ServiceInput;
};

/** Autogenerated return type of ServiceCreate. */
export type ServiceCreatePayload = {
  __typename: 'ServiceCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  service?: Maybe<Service>;
};

/** Autogenerated input type of ServiceDelete */
export type ServiceDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  idsIn: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of ServiceDelete. */
export type ServiceDeletePayload = {
  __typename: 'ServiceDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  services: ServiceConnection;
};

/** Autogenerated return type of ServiceDelete. */
export type ServiceDeletePayloadServicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ServiceDeleteWorkflowTemplateMappings */
export type ServiceDeleteWorkflowTemplateMappingsInput = {
  /** The name of the App the templates belong to */
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The uuid of the Service to map */
  id: Scalars['ID']['input'];
  /** The Workflow Templates Ids to remove from the mappings */
  workflowTemplateIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of ServiceDeleteWorkflowTemplateMappings. */
export type ServiceDeleteWorkflowTemplateMappingsPayload = {
  __typename: 'ServiceDeleteWorkflowTemplateMappingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  service?: Maybe<Service>;
};

export enum ServiceDescriptionEnhancementType {
  ELABORATE = 'ELABORATE',
  SHORTEN = 'SHORTEN',
  SIMPLIFY = 'SIMPLIFY',
}

/** An edge in a connection. */
export type ServiceEdge = {
  __typename: 'ServiceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Service;
};

export type ServiceFilter = {
  /** Returns records where description/engagement_text is blank if true */
  descriptionBlank?: InputMaybe<Scalars['Boolean']['input']>;
  /** Returns records where description/engagement_text is present if true */
  descriptionPresent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Returns only records where the ids are present in this list */
  idsIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Filter by name */
  nameCont?: InputMaybe<Scalars['String']['input']>;
  /** Service origin reference filter e.g. csv, xero, quickbooks */
  serviceOriginReferenceEq?: InputMaybe<Scalars['String']['input']>;
  /** Service origin type filter. e.g. app, csv, provided_template */
  serviceOriginTypeEq?: InputMaybe<Scalars['String']['input']>;
};

export type ServiceGroup = {
  __typename: 'ServiceGroup';
  /** the frontend-specific billing mode set by the frontend for display purposes */
  billingMode: ProposalBillingModeEnum;
  billingSchedules: Array<
    ProposalOnceOffBillingSchedule | ProposalRecurringBillingSchedule
  >;
  /** @deprecated Use billing_schedules instead */
  billingStrategy:
    | ProposalOnceOffBillingStrategy
    | ProposalRecurringBillingStrategy;
  /** @deprecated Use billingSchedules { cadence } */
  cadence?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  position: Scalars['Int']['output'];
  project: Project;
  proposedServices: Array<ProposedService>;
  subtitle?: Maybe<Scalars['String']['output']>;
  /** subtotal of all fixed price proposed services including discount */
  subtotal: Money;
  /** Formatted value of the service group subtotal including discount, always without tax, eg. From $50 */
  subtotalDescription: Scalars['String']['output'];
  /** total discount amount on all fixed, minimum and range price proposed services */
  subtotalDiscountAmount: Money;
  /** subtotal tax of all fixed price proposed services including discount */
  subtotalTax: Money;
  /** Formatted value of the service group tax on the subtotal including discount, eg. From $5 */
  subtotalTaxDescription: Scalars['String']['output'];
  /** subtotal and subtotal tax of all fixed price proposed services including discount */
  subtotalWithTax: Money;
  /** Formatted value of the service group subtotal and subtotal tax including discount, eg. From $55 */
  subtotalWithTaxDescription: Scalars['String']['output'];
  title: Scalars['String']['output'];
  /** subtotal of all fixed price proposed services in service group not including discount */
  undiscountedSubtotal: Money;
  /** Formatted value of the service group subtotal not including discount, always without tax, eg. From $50 */
  undiscountedSubtotalDescription: Scalars['String']['output'];
  /** subtotal tax of all fixed price proposed services in service group not including discount */
  undiscountedSubtotalTax: Money;
  /** subtotal and subtotal tax of all fixed price proposed services in service group not including discount */
  undiscountedSubtotalWithTax: Money;
  updatedAt: Scalars['DateTime']['output'];
};

export type ServiceGroupProposedServicesArgs = {
  filter?: InputMaybe<ProposedServiceFilter>;
};

/** Autogenerated input type of ServiceGroupCreate */
export type ServiceGroupCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  isDefault?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  sequence?: InputMaybe<Scalars['Int']['input']>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ServiceGroupCreate. */
export type ServiceGroupCreatePayload = {
  __typename: 'ServiceGroupCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  serviceGroup: ServiceGroupType;
};

/** services provided */
export type ServiceGroupType = {
  __typename: 'ServiceGroupType';
  id: Scalars['ID']['output'];
  isDefault: Scalars['Boolean']['output'];
  /**
   * Database ID for legacy CPE processing
   * @deprecated Use id for standard slug-based identification
   */
  legacyId: Scalars['ID']['output'];
  /** service name */
  name: Scalars['String']['output'];
  sequence?: Maybe<Scalars['Int']['output']>;
  /** description of service */
  shortDescription?: Maybe<Scalars['String']['output']>;
};

/** Service Import */
export type ServiceImport = {
  __typename: 'ServiceImport';
  attachmentFileName: Scalars['String']['output'];
  attachmentFileSize: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  practice: Practice;
  user: User;
};

/** Autogenerated input type of ServiceImport */
export type ServiceImportInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ServiceImport. */
export type ServiceImportPayload = {
  __typename: 'ServiceImportPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  import: ServiceImport;
};

/** Service input type for creating a service */
export type ServiceInput = {
  /** Default billing type (legacy CPE field) */
  defaultBillingType?: InputMaybe<DefaultBillingType>;
  /** Service description */
  description: Scalars['String']['input'];
  /** Billing mode */
  invoiceStrategy?: InputMaybe<ServiceInvoiceStrategy>;
  /** Ledger Items (Xero account or QuickBooks service item) */
  ledgerItems?: InputMaybe<Array<ServiceLedgerItemInput>>;
  /** Maximum price (legacy CPE field) */
  maxPrice?: InputMaybe<MoneyInput>;
  /** Minimum price (legacy CPE field) */
  minPrice?: InputMaybe<MoneyInput>;
  /** Service name */
  name: Scalars['String']['input'];
  /** Service price rule */
  priceRule: ServicePriceRuleInput;
  /** Price type (legacy CPE field) */
  priceType?: InputMaybe<ServicePriceType>;
  /** Publically available (legacy CPE field) */
  publicallyAvailable?: InputMaybe<Scalars['Boolean']['input']>;
  /** Service quantity rule */
  quantityRule?: InputMaybe<ServiceQuantityRuleInput>;
  /** Sequence position (legacy CPE field) */
  sequence?: InputMaybe<Scalars['Int']['input']>;
  /** Service group ID (legacy CPE field) */
  serviceGroupId?: InputMaybe<Scalars['ID']['input']>;
  /** Short description of the service (legacy CPE field) */
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  /** Standard price (legacy CPE field) */
  standardPrice?: InputMaybe<MoneyInput>;
  /** (QBO US) Tax exempt (legacy CPE field) */
  taxExempt?: InputMaybe<Scalars['Boolean']['input']>;
  /** UUID of tax */
  taxId: Scalars['ID']['input'];
  /** Service terms */
  terms?: InputMaybe<Scalars['String']['input']>;
  /** Unit name (legacy CPE field) */
  unitName?: InputMaybe<Scalars['String']['input']>;
  /** Unit price (legacy CPE field) */
  unitPrice?: InputMaybe<MoneyInput>;
  /** Weekly price (legacy CPE field) */
  weeklyPrice?: InputMaybe<MoneyInput>;
  /** Workflow Template Items */
  workflowTemplateMappings?: InputMaybe<Array<WorkflowTemplateMappingsInput>>;
};

export enum ServiceInvoiceStrategy {
  AUTOMATIC = 'AUTOMATIC',
  MANUAL = 'MANUAL',
}

/** Input type for Service Ledger Item. */
export type ServiceLedgerItemInput = {
  /** Ledger app (Xero or QuickBooks) */
  appName: Scalars['String']['input'];
  /** Slug of ledger item. */
  ledgerItemId: Scalars['ID']['input'];
};

/** A service origin reflects how a service was created */
export type ServiceOriginType = {
  __typename: 'ServiceOriginType';
  id: Scalars['ID']['output'];
  /** The name of the Service Origin */
  name: Scalars['String']['output'];
  /** The reference of the Service Origin (e.g. xero, quickbooks, csv) */
  reference: Scalars['String']['output'];
  /** The type of the Service Origin (e.g. app or csv) */
  type: Scalars['String']['output'];
};

/** Price rule input type for creating service. Just one input field is allowed */
export type ServicePriceRuleInput = {
  /** Fixed rate price */
  fixed?: InputMaybe<FixedPriceRuleInput>;
  /** Price included */
  included?: InputMaybe<IncludedPriceRuleInput>;
  /** Minimum price only */
  minimum?: InputMaybe<MinimumPriceRuleInput>;
  /** Price range */
  range?: InputMaybe<RangePriceRuleInput>;
  /** Unit price  */
  unit?: InputMaybe<UnitPriceRuleInput>;
};

export enum ServicePriceType {
  HOURLY = 'HOURLY',
  RANGE = 'RANGE',
  STANDARD = 'STANDARD',
}

/** Quantity rule input type for creating service. Just one input field is allowed */
export type ServiceQuantityRuleInput = {
  /** Estimate quantity */
  estimate?: InputMaybe<EstimateQuantityRuleInput>;
  /** Smart billing quantity rule */
  smartBilling?: InputMaybe<SmartBillingQuantityRuleInput>;
};

export enum ServiceRevenueExport {
  DASHBOARD_SERVICE_REVENUE = 'DASHBOARD_SERVICE_REVENUE',
  DASHBOARD_SERVICE_REVENUE_BY_CLIENT = 'DASHBOARD_SERVICE_REVENUE_BY_CLIENT',
}

/** Autogenerated input type of ServiceRevenueExport */
export type ServiceRevenueExportInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ISO formatted date */
  endDate: Scalars['Date']['input'];
  exportType: ServiceRevenueExport;
  /** ISO formatted date */
  startDate: Scalars['Date']['input'];
};

/** Autogenerated return type of ServiceRevenueExport. */
export type ServiceRevenueExportPayload = {
  __typename: 'ServiceRevenueExportPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  userErrors?: Maybe<Array<UserError>>;
};

/** Autogenerated input type of ServiceSetWorkflowTemplateMappings */
export type ServiceSetWorkflowTemplateMappingsInput = {
  /** The name of the App the templates belong to */
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The uuid of the Service to map */
  id: Scalars['ID']['input'];
  /** The Workflow Templates to map to */
  workflowTemplateIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of ServiceSetWorkflowTemplateMappings. */
export type ServiceSetWorkflowTemplateMappingsPayload = {
  __typename: 'ServiceSetWorkflowTemplateMappingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  service?: Maybe<Service>;
};

/** Autogenerated input type of ServiceTokenGenerate */
export type ServiceTokenGenerateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID for service */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ServiceTokenGenerate. */
export type ServiceTokenGeneratePayload = {
  __typename: 'ServiceTokenGeneratePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  service: Service;
};

/** Autogenerated input type of ServiceTokenRevoke */
export type ServiceTokenRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID for service */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ServiceTokenRevoke. */
export type ServiceTokenRevokePayload = {
  __typename: 'ServiceTokenRevokePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  service: Service;
};

/** Autogenerated input type of ServiceUpdate */
export type ServiceUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of the service */
  id: Scalars['ID']['input'];
  service: ServiceInput;
};

/** Autogenerated return type of ServiceUpdate. */
export type ServiceUpdatePayload = {
  __typename: 'ServiceUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  service?: Maybe<Service>;
};

/** Autogenerated input type of ServicesBulkCreate */
export type ServicesBulkCreateInput = {
  /** name of the app (e.g. "xero" or "quickbooks") */
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** list of AppService ids */
  ids: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of ServicesBulkCreate. */
export type ServicesBulkCreatePayload = {
  __typename: 'ServicesBulkCreatePayload';
  asyncJobGroup?: Maybe<AsyncJobGroup>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export type Session = {
  __typename: 'Session';
  id: Scalars['ID']['output'];
  /** Latest generated text result */
  text?: Maybe<Scalars['String']['output']>;
};

/** Settings input type for updating the dashboard. */
export type SettingsInput = {
  /** Beginning month of the monthly budgets.  Defaults to practice's financial year start. */
  budgetStart?: InputMaybe<DateInput>;
  /** Budgets for each month starting with the budget start month. Dollar amounts assumed to be in the practice's currency. */
  monthlyBudgets: Array<Scalars['Int']['input']>;
  /** Number of available staff for the practice. */
  staffCount: Scalars['Int']['input'];
};

export type SignatoryFilter = {
  role?: InputMaybe<SignatoryRoleEnum>;
};

export enum SignatoryRoleEnum {
  PRIMARY = 'PRIMARY',
  SECONDARY = 'SECONDARY',
}

export enum SignatoryStateEnum {
  SIGNED = 'SIGNED',
  SIGNED_ON_BEHALF = 'SIGNED_ON_BEHALF',
  UNSIGNED = 'UNSIGNED',
}

export type SignatureLocation = {
  __typename: 'SignatureLocation';
  cityName: Scalars['String']['output'];
  latitude: Scalars['Float']['output'];
  longitude: Scalars['Float']['output'];
};

export type SmartBillingQuantityOption = {
  __typename: 'SmartBillingQuantityOption';
  /** source of the dynamic option e.g. gusto_company_headcount */
  source: Scalars['String']['output'];
};

/** The connection type for SmartBillingQuantityOption. */
export type SmartBillingQuantityOptionConnection = {
  __typename: 'SmartBillingQuantityOptionConnection';
  /** A list of edges. */
  edges: Array<SmartBillingQuantityOptionEdge>;
  /** A list of nodes. */
  nodes: Array<SmartBillingQuantityOption>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SmartBillingQuantityOptionEdge = {
  __typename: 'SmartBillingQuantityOptionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: SmartBillingQuantityOption;
};

/** Input type for SmartBilling quantity rule. */
export type SmartBillingQuantityRuleInput = {
  /** Source of the rule to apply. e.g. gusto_company_headcount */
  source: Scalars['String']['input'];
};

export enum StaffCount {
  /** with a team of 11-20 staff */
  ELEVEN_TO_TWENTY = 'ELEVEN_TO_TWENTY',
  /** with a team of 50+ staff */
  FIFTY_PLUS = 'FIFTY_PLUS',
  /** with a team of 4-5 staff */
  FOUR_TO_FIVE = 'FOUR_TO_FIVE',
  /** with a team of 1-3 staff */
  ONE_TO_THREE = 'ONE_TO_THREE',
  /** with a team of 6-10 staff */
  SIX_TO_TEN = 'SIX_TO_TEN',
  /** as a sole trader */
  SOLE = 'SOLE',
  /** with a team of 21-50 staff */
  TWENTY_ONE_TO_FIFTY = 'TWENTY_ONE_TO_FIFTY',
}

export type Subscription = {
  __typename: 'Subscription';
  /** Fires when an AI Text Generation Session receives a response with generated text */
  aiTextGenerationSessionTextGenerated: AiTextGenerationSessionTextGeneratedPayload;
  /** Fires when a ledger app sync reveals there are proposals available for import */
  capabilitiesProposalImportProposalsAvailable: CapabilitiesProposalImportProposalsAvailablePayload;
  /** Count of unseen notifications has changed */
  notificationsUnseenCountChanged: UnseenCountChangedPayload;
  paymentCollected: PaymentCollectedPayload;
  paymentDisbursed: PaymentDisbursedPayload;
  paymentStarted: PaymentStartedPayload;
  proposalAccepted: ProposalAcceptedPayload;
  /** QuickBooks app has been connected */
  quickbooksAppConnected: ConnectedPayload;
  /** Fires when we cannot stop the remote recurring transaction */
  quickbooksRecurringTransactionStopRemoteFailed: QuickbooksRecurringTransactionStopRemoteFailedPayload;
  /** Fires when we cannot stop the remote repeating invoice */
  xeroRepeatingInvoiceStopRemoteFailed: XeroRepeatingInvoiceStopRemoteFailedPayload;
};

export type SubscriptionAiTextGenerationSessionTextGeneratedArgs = {
  sessionId: Scalars['ID']['input'];
};

export type SubscriptionCoupon = {
  __typename: 'SubscriptionCoupon';
  /** Coupon code */
  code: Scalars['String']['output'];
  /** Coupon discount rate */
  discountPercentage?: Maybe<Percentage>;
  /** Coupon discount type */
  type: CouponDiscountType;
};

export type SubscriptionPreview = {
  __typename: 'SubscriptionPreview';
  /** Length of time between billing cycles. */
  billingPeriod: PlanBillingPeriod;
  /** Carried forward amount. */
  carriedForward?: Maybe<Money>;
  /** Subscription's coupon. */
  coupon?: Maybe<SubscriptionCoupon>;
  /** Flag to indicate if coupon is applied. */
  couponApplied: Scalars['Boolean']['output'];
  /** Remaining credit of the subscription. */
  creditRemaining?: Maybe<Money>;
  /** Amount of discount. */
  discountAmount?: Maybe<Money>;
  /** Price with discount. */
  discountedPrice?: Maybe<Money>;
  /** Price without any discount. */
  standardPrice: Money;
};

export enum SubscriptionStatus {
  EXPIRED = 'EXPIRED',
  SUBSCRIBED = 'SUBSCRIBED',
  TRIAL = 'TRIAL',
}

/** Autogenerated input type of SurchargeDisable */
export type SurchargeDisableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of SurchargeDisable. */
export type SurchargeDisablePayload = {
  __typename: 'SurchargeDisablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  paymentSettings: PaymentSettings;
};

/** Autogenerated input type of SurchargeEnable */
export type SurchargeEnableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether surcharges are restricted to only the 'credit_card' surcharge category */
  isSurchargeCreditCardsOnly: Scalars['Boolean']['input'];
  /** Rate at which applicable cards are surcharged */
  surchargeRate: PercentageInput;
};

/** Autogenerated return type of SurchargeEnable. */
export type SurchargeEnablePayload = {
  __typename: 'SurchargeEnablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  paymentSettings: PaymentSettings;
};

export type SystemTemplate = PracticeTemplate & {
  __typename: 'SystemTemplate';
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  slug: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type Tax = {
  __typename: 'Tax';
  appTaxes: AppTaxConnection;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  rate: Scalars['Decimal']['output'];
  referenceNumber: Scalars['ID']['output'];
};

export type TaxAppTaxesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AppTaxFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type TaxCodeMappingEdge = {
  __typename: 'TaxCodeMappingEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: QuickbooksTaxCodeMapping;
};

/** The connection type for Tax. */
export type TaxConnection = {
  __typename: 'TaxConnection';
  /** A list of edges. */
  edges: Array<TaxEdge>;
  /** A list of nodes. */
  nodes: Array<Tax>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of TaxCreate */
export type TaxCreateInput = {
  /** A list of Capability AppTaxes which will be automatically mapped to the new Tax. */
  appTaxes?: InputMaybe<Array<AppTaxInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Tax name */
  name: Scalars['String']['input'];
  /** Tax rate */
  rate: Scalars['Decimal']['input'];
};

/** Autogenerated return type of TaxCreate. */
export type TaxCreatePayload = {
  __typename: 'TaxCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  tax?: Maybe<Tax>;
  taxes: TaxConnection;
};

/** Autogenerated return type of TaxCreate. */
export type TaxCreatePayloadTaxesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export enum TaxDisplay {
  /** Amounts displayed exclude tax */
  EXCLUDING_TAX = 'EXCLUDING_TAX',
  /** Amounts displayed include tax */
  INCLUDING_TAX = 'INCLUDING_TAX',
  /** No tax information is displayed */
  NO_TAX_DISPLAY = 'NO_TAX_DISPLAY',
}

/** An edge in a connection. */
export type TaxEdge = {
  __typename: 'TaxEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Tax;
};

export type TaxFilter = {
  mappedIn?: InputMaybe<TaxMappingsLedger>;
};

export enum TaxMappingsLedger {
  QUICKBOOKS = 'QUICKBOOKS',
  XERO = 'XERO',
}

export enum TaxMethod {
  /** Tax is set on the proposal */
  PROPOSAL = 'PROPOSAL',
  /** Tax is set per service */
  SERVICES = 'SERVICES',
}

export type TaxRate = {
  __typename: 'TaxRate';
  /** @deprecated Use tax_rate_percentage */
  displayTaxRate?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  taxRatePercentage?: Maybe<Percentage>;
  taxType: Scalars['String']['output'];
};

export type TaxRateMapping = {
  __typename: 'TaxRateMapping';
  id: Scalars['ID']['output'];
  /** Ignition tax type */
  tax: Tax;
  /** Xero integration tax rate */
  taxRate?: Maybe<TaxRate>;
};

/** An edge in a connection. */
export type TaxRateMappingEdge = {
  __typename: 'TaxRateMappingEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: TaxRateMapping;
};

/** Autogenerated input type of TaxSetAppMappings */
export type TaxSetAppMappingsInput = {
  /** The App name we're mapping to. */
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The list of taxes and the AppTax to map to. */
  taxMappings: Array<AppTaxMappingInput>;
};

/** Autogenerated return type of TaxSetAppMappings. */
export type TaxSetAppMappingsPayload = {
  __typename: 'TaxSetAppMappingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  taxes: Array<Tax>;
};

export type TemplateFilter = {
  nameCont?: InputMaybe<Scalars['String']['input']>;
  systemNameEq?: InputMaybe<TemplateSystem>;
  templateTypeEq?: InputMaybe<TemplateType>;
};

export type TemplateInput = {
  content: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

export enum TemplateSystem {
  ACCEPT_ENGAGEMENT_MESSAGE = 'ACCEPT_ENGAGEMENT_MESSAGE',
  ADVISE_CLIENT_OF_ACCEPTANCE = 'ADVISE_CLIENT_OF_ACCEPTANCE',
  ADVISE_CLIENT_OF_BANK_ACCOUNT_FAILURE = 'ADVISE_CLIENT_OF_BANK_ACCOUNT_FAILURE',
  ADVISE_CLIENT_OF_BANK_VERIFICATION_REQUIRED = 'ADVISE_CLIENT_OF_BANK_VERIFICATION_REQUIRED',
  ADVISE_CLIENT_OF_NEW_GROUP_PROPOSAL = 'ADVISE_CLIENT_OF_NEW_GROUP_PROPOSAL',
  ADVISE_CLIENT_OF_NEW_PROPOSAL = 'ADVISE_CLIENT_OF_NEW_PROPOSAL',
  ADVISE_CLIENT_OF_SUBMISSION = 'ADVISE_CLIENT_OF_SUBMISSION',
  ENGAGEMENT_TEMPLATE = 'ENGAGEMENT_TEMPLATE',
  INTRO_MESSAGE_TEMPLATE = 'INTRO_MESSAGE_TEMPLATE',
}

export enum TemplateType {
  EMAIL = 'EMAIL',
  ENGAGEMENT = 'ENGAGEMENT',
  SYSTEM = 'SYSTEM',
}

export enum TemplateVisibility {
  PRIVATE = 'PRIVATE',
  PUBLIC = 'PUBLIC',
}

export type Templates = {
  __typename: 'Templates';
  /** Email template for explaining that something went wrong when adding or updating the clients bank account */
  bankAccountFailureEmailTemplate?: Maybe<BankAccountFailureEmailTemplate>;
  /** Email template for explaining bank account verification when the client accepts a proposal */
  bankAccountVerificationEmailTemplate?: Maybe<BankAccountVerificationEmailTemplate>;
  /** Intro message template */
  introMessageTemplate: IntroMessageTemplate;
  /** Intro message templates */
  introMessageTemplates: IntroMessageTemplateConnection;
  /** Email template for advising client of new group proposal */
  newGroupProposalEmailTemplate?: Maybe<NewGroupProposalEmailTemplate>;
  /** Email template for advising client of new proposal */
  newProposalEmailTemplate: NewProposalEmailTemplate;
  /** Email templates for advising client of new proposal */
  newProposalEmailTemplates: NewProposalEmailTemplateConnection;
  /** Email template for advising client of submission */
  newSubmissionEmailTemplate?: Maybe<NewSubmissionEmailTemplate>;
  /** Next steps message template */
  nextStepsMessageTemplate: NextStepsMessageTemplate;
  nextStepsMessageTemplates: NextStepsMessageTemplateConnection;
  proposalAcceptedBrowserTemplate?: Maybe<ProposalAcceptedBrowserTemplate>;
  /** Email template for advising client of proposal acceptance */
  proposalAcceptedEmailTemplate?: Maybe<ProposalAcceptedEmailTemplate>;
  /** Engagement template */
  termsTemplate: TermsTemplate;
  /** Engagement templates */
  termsTemplates: TermsTemplateConnection;
};

export type TemplatesIntroMessageTemplateArgs = {
  id: Scalars['ID']['input'];
};

export type TemplatesIntroMessageTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type TemplatesNewProposalEmailTemplateArgs = {
  id: Scalars['ID']['input'];
};

export type TemplatesNewProposalEmailTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type TemplatesNextStepsMessageTemplateArgs = {
  id: Scalars['ID']['input'];
};

export type TemplatesNextStepsMessageTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type TemplatesTermsTemplateArgs = {
  id: Scalars['ID']['input'];
};

export type TemplatesTermsTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type TermsTemplate = PracticeTemplate & {
  __typename: 'TermsTemplate';
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  isDefault: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  slug: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for TermsTemplate. */
export type TermsTemplateConnection = {
  __typename: 'TermsTemplateConnection';
  /** A list of edges. */
  edges: Array<TermsTemplateEdge>;
  /** A list of nodes. */
  nodes: Array<TermsTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of TermsTemplateCreate */
export type TermsTemplateCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  template: TemplateInput;
};

/** Autogenerated return type of TermsTemplateCreate. */
export type TermsTemplateCreatePayload = {
  __typename: 'TermsTemplateCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<TermsTemplate>;
  templates?: Maybe<Templates>;
};

/** Autogenerated input type of TermsTemplateDelete */
export type TermsTemplateDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of terms template */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of TermsTemplateDelete. */
export type TermsTemplateDeletePayload = {
  __typename: 'TermsTemplateDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  templates?: Maybe<Templates>;
};

/** An edge in a connection. */
export type TermsTemplateEdge = {
  __typename: 'TermsTemplateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: TermsTemplate;
};

/** Autogenerated input type of TermsTemplateUpdate */
export type TermsTemplateUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of terms template */
  id: Scalars['ID']['input'];
  template: TemplateInput;
};

/** Autogenerated return type of TermsTemplateUpdate. */
export type TermsTemplateUpdatePayload = {
  __typename: 'TermsTemplateUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  template?: Maybe<TermsTemplate>;
  templates?: Maybe<Templates>;
};

export type Textile = {
  __typename: 'Textile';
  /**
   * unsafe html for displaying on the web page
   * @deprecated Use the safeHtml field instead.
   */
  html: Scalars['String']['output'];
  /** sanitised html for displaying on the web page */
  safeHtml: Scalars['Html']['output'];
  /** the raw textile for editing in a text area */
  textile: Scalars['String']['output'];
};

/** A representation of a time zone. */
export type TimeZone = {
  __typename: 'TimeZone';
  /** The standard ICANN tz database code (e.g. 'America/New_York') */
  code: Scalars['String']['output'];
  /** The friendly (Rails compatible) time zone name (e.g. 'Eastern Time (US & Canada)') */
  name: Scalars['String']['output'];
  /** Formatted UTC offset. */
  utcOffset: Scalars['String']['output'];
  /** The UTC offset in seconds. */
  utcOffsetInSeconds: Scalars['Int']['output'];
};

export enum TwoFactorAuthMethod {
  AUTH_APP = 'AUTH_APP',
  SMS = 'SMS',
}

/** The reason and explanation for why an app is unavailable. */
export type UnavailableReason = {
  __typename: 'UnavailableReason';
  /** The message to display for this unavailability reason. */
  message: Scalars['String']['output'];
  /** The reason enum why this app is unavailable. */
  type: AppUnavailableReason;
};

/** Input type for unit price rule. */
export type UnitPriceRuleInput = {
  /** Price amount */
  amount: MoneyInput;
  /** Unit name */
  unitName: Scalars['String']['input'];
};

/** Autogenerated return type of UnseenCountChanged. */
export type UnseenCountChangedPayload = {
  __typename: 'UnseenCountChangedPayload';
  unseenCount: Scalars['Int']['output'];
};

export type UpdateContactInput = {
  /** The Email Address of the Contact */
  email?: InputMaybe<Scalars['EmailAddress']['input']>;
  /** The UUID of the Contact */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of UploadAvatar */
export type UploadAvatarInput = {
  avatar: ImageInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UploadAvatar. */
export type UploadAvatarPayload = {
  __typename: 'UploadAvatarPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

export type User = {
  __typename: 'User';
  appUsers: AppUserConnection;
  avatarUrl?: Maybe<Scalars['URL']['output']>;
  createdAt: Scalars['DateTime']['output'];
  /** Time stamp address of the user's current/ most recent sign in */
  currentSignInAt?: Maybe<Scalars['DateTime']['output']>;
  /** IP address of the user's current/ most recent sign in */
  currentSignInIp?: Maybe<Scalars['IpAddress']['output']>;
  emailAddress: Scalars['EmailAddress']['output'];
  firstName: Scalars['String']['output'];
  fullName: Scalars['String']['output'];
  hasBillingPermission: Scalars['Boolean']['output'];
  hasSignedIn: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** If the user is imported, this is the imported id */
  importedId?: Maybe<Scalars['ID']['output']>;
  invitationAcceptedAt?: Maybe<Scalars['DateTime']['output']>;
  invitationSentAt?: Maybe<Scalars['DateTime']['output']>;
  isActive: Scalars['Boolean']['output'];
  isPrincipal: Scalars['Boolean']['output'];
  /** whether user logs in through sso or not */
  isSsoUser: Scalars['Boolean']['output'];
  /** Whether or not we send a weekly report */
  isSubscribedToWeeklySummary: Scalars['Boolean']['output'];
  jobTitle?: Maybe<Scalars['String']['output']>;
  lastName: Scalars['String']['output'];
  /** Time stamp of the user's previous sign in */
  lastSignInAt?: Maybe<Scalars['DateTime']['output']>;
  /** IP address of the user's previous sign in */
  lastSignInIp?: Maybe<Scalars['IpAddress']['output']>;
  notifications: NotificationsConnection;
  notificationsSettings: NotificationsSettingsSettings;
  referenceNumber: Scalars['ID']['output'];
  referralDetails: Array<ReferralDetails>;
  referralRewards?: Maybe<RewardConnection>;
  /** a referral URL that the user can share with others to participate in the referrals scheme */
  referralUrl?: Maybe<Scalars['URL']['output']>;
  referrals?: Maybe<ReferralConnection>;
  role?: Maybe<Scalars['String']['output']>;
  roles: Array<Scalars['String']['output']>;
  signInCount: Scalars['Int']['output'];
  twoFactorAuthEnabled: Scalars['Boolean']['output'];
  twoFactorAuthMethod?: Maybe<TwoFactorAuthMethod>;
  twoFactorAuthMobile?: Maybe<Scalars['PhoneNumber']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  /** @deprecated Use id instead */
  uuid: Scalars['ID']['output'];
  watchSettings: UserWatchSettings;
};

export type UserAppUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AppUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type UserNotificationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotificationsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type UserReferralRewardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type UserReferralsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** UserConfigAttributes contains details about an App's settings & presentation on the apps page. */
export type UserConfigurable = {
  __typename: 'UserConfigurable';
  /**
   * The name of the connected App account to be displayed on the app tile when connected
   * @deprecated Use connectedAccount { name }
   */
  accountName?: Maybe<Scalars['String']['output']>;
  /** The list of accounts the app is authorised to connect to. */
  authorisedAccounts: Array<UserConfigurableAccount>;
  /** Whether a user can connect this App from an app tile */
  connectable: Scalars['Boolean']['output'];
  /** Information about the currently connected account (if any). */
  connectedAccount?: Maybe<UserConfigurableAccount>;
  /** A description of the App that is displayed on its tile when not connected */
  connectionText: Scalars['String']['output'];
  /** A URL which the user will be redirected to in order to start connecting this App */
  connectionUrl: Scalars['URL']['output'];
  /** Whether a user can enable this App from an app tile */
  enablable: Scalars['Boolean']['output'];
  /** The last time this App was successfully synced */
  lastSynced?: Maybe<Scalars['DateTime']['output']>;
  state: UserConfigurableState;
  /** The reason why this app is unavailable. */
  unavailableReason?: Maybe<UnavailableReason>;
};

export type UserConfigurableAccount = {
  __typename: 'UserConfigurableAccount';
  id: Scalars['ID']['output'];
  industry: Industry;
  name: Scalars['String']['output'];
  phoneNumber?: Maybe<Scalars['PhoneNumber']['output']>;
  regionId?: Maybe<Scalars['CountryCode']['output']>;
};

export enum UserConfigurableState {
  /** App is authorised but not yet connected to an account. */
  AUTHORISED = 'AUTHORISED',
  /** App is connected to an account but not yet enabled. */
  CONNECTED = 'CONNECTED',
  /** App is in the process of connecting to an account. */
  CONNECTING = 'CONNECTING',
  /** App is not connected. */
  DISCONNECTED = 'DISCONNECTED',
  /** App is enabled */
  ENABLED = 'ENABLED',
  /** App is connected but authorisation has failed. */
  UNAUTHORISED = 'UNAUTHORISED',
  /** App is unavailable, see unavailable reason for more details. */
  UNAVAILABLE = 'UNAVAILABLE',
}

/** The connection type for User. */
export type UserConnection = {
  __typename: 'UserConnection';
  /** A list of edges. */
  edges: Array<UserEdge>;
  /** A list of nodes. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of UserCreate */
export type UserCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Automatically send an email invitation to the user? */
  sendInvitation?: InputMaybe<Scalars['Boolean']['input']>;
  /** The User input fields */
  userInput: UserInputType;
};

/** Autogenerated return type of UserCreate. */
export type UserCreatePayload = {
  __typename: 'UserCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user: User;
};

/** Autogenerated input type of UserDelete */
export type UserDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the User to delete */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UserDelete. */
export type UserDeletePayload = {
  __typename: 'UserDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user: User;
};

/** An edge in a connection. */
export type UserEdge = {
  __typename: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: User;
};

export type UserError = DisplayableError & {
  __typename: 'UserError';
  /** Path to the input field which caused the error */
  field?: Maybe<Array<Scalars['String']['output']>>;
  /** The error message */
  message: Scalars['String']['output'];
};

/** Input fields for a user */
export type UserInputType = {
  /** The user's email address */
  emailAddress: Scalars['EmailAddress']['input'];
  /** The user's full name */
  fullName: Scalars['String']['input'];
  /** Can this user bill or not? */
  hasBillingPermission: Scalars['Boolean']['input'];
  /** User's XPM/WFM ID */
  importedId?: InputMaybe<Scalars['ID']['input']>;
  /** Is the user being subscribed to the weekly summary email */
  isSubscribedToWeeklySummary: Scalars['Boolean']['input'];
  /** User's job title */
  jobTitle?: InputMaybe<Scalars['String']['input']>;
  /** ACCOUNTANT or PRACTICEADMIN */
  role: UserRoleEnum;
};

/** Autogenerated input type of UserInviteAll */
export type UserInviteAllInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The invitations */
  invitations: Array<InvitationInputType>;
};

/** Autogenerated return type of UserInviteAll. */
export type UserInviteAllPayload = {
  __typename: 'UserInviteAllPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** List of invitation results by this mutation */
  invitations: Array<InvitationType>;
};

/** Autogenerated input type of UserInvite */
export type UserInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the User to invite */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UserInvite. */
export type UserInvitePayload = {
  __typename: 'UserInvitePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UserLogout */
export type UserLogoutInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UserLogout. */
export type UserLogoutPayload = {
  __typename: 'UserLogoutPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UserPasswordUpdate */
export type UserPasswordUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  oldPassword: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

/** Autogenerated return type of UserPasswordUpdate. */
export type UserPasswordUpdatePayload = {
  __typename: 'UserPasswordUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UserRegisterReferralUrl */
export type UserRegisterReferralUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UserRegisterReferralUrl. */
export type UserRegisterReferralUrlPayload = {
  __typename: 'UserRegisterReferralUrlPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  currentUser: User;
};

/** Autogenerated input type of UserResetTwoFactorAuth */
export type UserResetTwoFactorAuthInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the User to reset */
  id: Scalars['ID']['input'];
  /** The OTP of the current User */
  otp: Scalars['String']['input'];
};

/** Autogenerated return type of UserResetTwoFactorAuth. */
export type UserResetTwoFactorAuthPayload = {
  __typename: 'UserResetTwoFactorAuthPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

export enum UserRoleEnum {
  ACCOUNTANT = 'ACCOUNTANT',
  PRACTICEADMIN = 'PRACTICEADMIN',
}

/** Autogenerated input type of UserSendReferralInviteEmail */
export type UserSendReferralInviteEmailInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The invitee's email address */
  recipientEmail: Scalars['EmailAddress']['input'];
};

/** Autogenerated return type of UserSendReferralInviteEmail. */
export type UserSendReferralInviteEmailPayload = {
  __typename: 'UserSendReferralInviteEmailPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  currentUser: User;
};

/** Autogenerated input type of UserSendTwoFactorAuthSmsCode */
export type UserSendTwoFactorAuthSmsCodeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UserSendTwoFactorAuthSmsCode. */
export type UserSendTwoFactorAuthSmsCodePayload = {
  __typename: 'UserSendTwoFactorAuthSmsCodePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UserSetAppMapping */
export type UserSetAppMappingInput = {
  /** The AppUsers to map to */
  appUsers: Array<AppUserInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the User to map */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UserSetAppMapping. */
export type UserSetAppMappingPayload = {
  __typename: 'UserSetAppMappingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UserUpdate */
export type UserUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the User to update */
  id: Scalars['ID']['input'];
  /** The User input fields */
  userInput: UserInputType;
};

/** Autogenerated return type of UserUpdate. */
export type UserUpdatePayload = {
  __typename: 'UserUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user: User;
};

/** Autogenerated input type of UserUpdateWeeklySummaryEmail */
export type UserUpdateWeeklySummaryEmailInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Enables the weekly summary email flag in user profile */
  enabled: Scalars['Boolean']['input'];
};

/** Autogenerated return type of UserUpdateWeeklySummaryEmail. */
export type UserUpdateWeeklySummaryEmailPayload = {
  __typename: 'UserUpdateWeeklySummaryEmailPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  currentUser: User;
};

export type UserWatchSettings = {
  __typename: 'UserWatchSettings';
  defaults: Array<WatchableEventsEnum>;
};

export enum WatchableEventsEnum {
  ACCEPTANCE = 'ACCEPTANCE',
  ACCEPT_PAGE_VIEW = 'ACCEPT_PAGE_VIEW',
  ACH_SOURCE_VERIFICATION_EMAIL_SENT = 'ACH_SOURCE_VERIFICATION_EMAIL_SENT',
  ACH_SOURCE_VERIFIED = 'ACH_SOURCE_VERIFIED',
  BACS_DEBIT_SOURCE_DEBIT_INITIATED_EMAIL_SENT = 'BACS_DEBIT_SOURCE_DEBIT_INITIATED_EMAIL_SENT',
  BACS_DEBIT_SOURCE_MANDATE_CONFIRMED = 'BACS_DEBIT_SOURCE_MANDATE_CONFIRMED',
  BACS_DEBIT_SOURCE_MANDATE_CONFIRMED_EMAIL_SENT = 'BACS_DEBIT_SOURCE_MANDATE_CONFIRMED_EMAIL_SENT',
  BACS_DEBIT_SOURCE_MANDATE_FAILED = 'BACS_DEBIT_SOURCE_MANDATE_FAILED',
  BULK_PRICE_CHANGED = 'BULK_PRICE_CHANGED',
  COMMENT = 'COMMENT',
  COMPLETION = 'COMPLETION',
  CONTINUOUS_BILLING_DISABLED = 'CONTINUOUS_BILLING_DISABLED',
  CONTINUOUS_BILLING_ENABLED = 'CONTINUOUS_BILLING_ENABLED',
  CONTRACT_AWAITING_ACCEPTANCE_CLIENT_NOTIFICATION_REMINDER_SENT = 'CONTRACT_AWAITING_ACCEPTANCE_CLIENT_NOTIFICATION_REMINDER_SENT',
  CONTRACT_AWAITING_ACCEPTANCE_CLIENT_NOTIFICATION_SENT = 'CONTRACT_AWAITING_ACCEPTANCE_CLIENT_NOTIFICATION_SENT',
  CREATION = 'CREATION',
  CREDIT_CARD_EXPIRING = 'CREDIT_CARD_EXPIRING',
  DELETION = 'DELETION',
  EDIT_SERVICE_OFFERING = 'EDIT_SERVICE_OFFERING',
  EMAIL_BOUNCE = 'EMAIL_BOUNCE',
  EMAIL_OPEN = 'EMAIL_OPEN',
  EMAIL_SEND = 'EMAIL_SEND',
  ENGAGEMENT_LETTER_CREATED = 'ENGAGEMENT_LETTER_CREATED',
  GROUP_EMAIL_SEND = 'GROUP_EMAIL_SEND',
  INVOICE_DEPLOY = 'INVOICE_DEPLOY',
  INVOICE_ERROR = 'INVOICE_ERROR',
  INVOICE_NOTIFICATION_SENT = 'INVOICE_NOTIFICATION_SENT',
  INVOICE_ON_COMPLETION = 'INVOICE_ON_COMPLETION',
  INVOICE_RECONCILED = 'INVOICE_RECONCILED',
  INVOICE_RECONCILIATION_FAILURE = 'INVOICE_RECONCILIATION_FAILURE',
  INVOICE_REDEPLOYED = 'INVOICE_REDEPLOYED',
  JOB_DEPLOY = 'JOB_DEPLOY',
  MARK_AS_ACTIVE = 'MARK_AS_ACTIVE',
  MARK_AS_LOST = 'MARK_AS_LOST',
  MOVE_TO_DRAFT = 'MOVE_TO_DRAFT',
  MOVE_TO_SENT = 'MOVE_TO_SENT',
  PAYMENT_AUTHENTICATION_REQUIRED = 'PAYMENT_AUTHENTICATION_REQUIRED',
  PAYMENT_COLLECTED_NOTIFICATION_SENT = 'PAYMENT_COLLECTED_NOTIFICATION_SENT',
  PAYMENT_COLLECTION = 'PAYMENT_COLLECTION',
  PAYMENT_DISABLED = 'PAYMENT_DISABLED',
  PAYMENT_DISBURSAL = 'PAYMENT_DISBURSAL',
  PAYMENT_ENABLED = 'PAYMENT_ENABLED',
  PAYMENT_METHOD_CHANGED = 'PAYMENT_METHOD_CHANGED',
  PAYMENT_METHOD_REMOVED = 'PAYMENT_METHOD_REMOVED',
  PAYMENT_PENDING_VERIFICATION = 'PAYMENT_PENDING_VERIFICATION',
  PAYMENT_REJECTION = 'PAYMENT_REJECTION',
  PAYMENT_RETRIED_BY_CLIENT = 'PAYMENT_RETRIED_BY_CLIENT',
  PROPOSAL_BULK_SEND = 'PROPOSAL_BULK_SEND',
  QUEUE = 'QUEUE',
  REVOCATION = 'REVOCATION',
  ROLL_OVER = 'ROLL_OVER',
}

export type WorkTemplateMappingInput = {
  serviceId: Scalars['ID']['input'];
  workTemplateId: Scalars['ID']['input'];
};

export type WorkflowCategoryType = {
  __typename: 'WorkflowCategoryType';
  app: App;
  externalId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

/** The connection type for WorkflowCategoryType. */
export type WorkflowCategoryTypeConnection = {
  __typename: 'WorkflowCategoryTypeConnection';
  /** A list of edges. */
  edges: Array<WorkflowCategoryTypeEdge>;
  /** A list of nodes. */
  nodes: Array<WorkflowCategoryType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type WorkflowCategoryTypeEdge = {
  __typename: 'WorkflowCategoryTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: WorkflowCategoryType;
};

export type WorkflowSettings = {
  __typename: 'WorkflowSettings';
  appName?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  deployStrategy?: Maybe<ProposalWorkflowSettingsDeployStrategy>;
  id: Scalars['ID']['output'];
  lockVersion: Scalars['Int']['output'];
  updatedAt: Scalars['DateTime']['output'];
  workflowStructure?: Maybe<ProposalWorkflowSettingsWorkflowStructure>;
};

export type WorkflowStrategy = {
  __typename: 'WorkflowStrategy';
  appName: Scalars['String']['output'];
  /**
   * The billing group assigned to this workflow.
   *
   * When invoices are issued with this billing group, the credits will be applied
   * to this workflow strategy.
   */
  billingGroup?: Maybe<ProposalBillingGroup>;
  billingReference?: Maybe<Scalars['String']['output']>;
  budget?: Maybe<Money>;
  categories: Array<WorkflowCategoryType>;
  createdAt: Scalars['DateTime']['output'];
  delay?: Maybe<Duration>;
  description?: Maybe<Scalars['String']['output']>;
  duration?: Maybe<Duration>;
  id: Scalars['ID']['output'];
  lockVersion: Scalars['Int']['output'];
  manager?: Maybe<User>;
  name?: Maybe<Scalars['String']['output']>;
  partner?: Maybe<User>;
  recurrenceRule?: Maybe<RecurrenceRule>;
  recurrenceType?: Maybe<ProposalWorkflowStrategyRecurrenceType>;
  staff: Array<User>;
  startDate?: Maybe<Scalars['Date']['output']>;
  startType?: Maybe<ProposalWorkflowStrategyStartType>;
  templates: Array<WorkflowTemplateType>;
  updatedAt: Scalars['DateTime']['output'];
};

/** Input type for Capabilities Workflow Template Mappings. */
export type WorkflowTemplateMappingsInput = {
  /** Workflow Template App */
  appName: Scalars['String']['input'];
  /** Workflow Templates Ids. */
  workflowTemplateIds: Array<Scalars['ID']['input']>;
};

export type WorkflowTemplateType = {
  __typename: 'WorkflowTemplateType';
  app: App;
  externalId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

/** The connection type for WorkflowTemplateType. */
export type WorkflowTemplateTypeConnection = {
  __typename: 'WorkflowTemplateTypeConnection';
  /** A list of edges. */
  edges: Array<WorkflowTemplateTypeEdge>;
  /** A list of nodes. */
  nodes: Array<WorkflowTemplateType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type WorkflowTemplateTypeEdge = {
  __typename: 'WorkflowTemplateTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: WorkflowTemplateType;
};

export type Xpm = {
  __typename: 'XPM';
  id: Scalars['ID']['output'];
  lastSynced?: Maybe<Scalars['DateTime']['output']>;
  referenceNumber: Scalars['ID']['output'];
  state: XpmState;
};

export enum XpmState {
  AUTHORISED = 'AUTHORISED',
  CONNECTED = 'CONNECTED',
  DISCONNECTED = 'DISCONNECTED',
  UNAUTHORISED = 'UNAUTHORISED',
}

export type Xero = {
  __typename: 'Xero';
  /** Branding theme when payment is collected by Ignition */
  defaultBrandingTheme?: Maybe<XeroBrandingTheme>;
  defaultInvoiceState?: Maybe<Scalars['String']['output']>;
  defaultSalesAccount?: Maybe<Account>;
  defaultTerms?: Maybe<Scalars['Int']['output']>;
  /** Automatically create invoices in Xero */
  deployInvoices: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** Branding theme when payment is arranged manually */
  recurringBrandingTheme?: Maybe<XeroBrandingTheme>;
  recurringTerms?: Maybe<Scalars['Int']['output']>;
  /** Xero Repeating Invoices search results */
  repeatingInvoicesSearch?: Maybe<SearchQuery>;
  /** @deprecated Use apps() query and its userConfiguration.state instead. */
  state: XeroState;
  syncClientName: Scalars['Boolean']['output'];
  taxRateMappings: XeroTaxRateMappingConnectionType;
  taxRates: Array<TaxRate>;
  trackingCategories: Array<XeroTrackingCategory>;
};

export type XeroRepeatingInvoicesSearchArgs = {
  asyncJobGroupId?: InputMaybe<Scalars['ID']['input']>;
  filterWithConversionErrors?: InputMaybe<Scalars['Boolean']['input']>;
  includeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  pagination?: InputMaybe<PaginationInput>;
  sort?: InputMaybe<SearchQuerySortInput>;
};

export type XeroTaxRateMappingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type XeroBrandingTheme = {
  __typename: 'XeroBrandingTheme';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  /** @deprecated Use id instead */
  uuid: Scalars['ID']['output'];
};

export type XeroIntegrationLineItem = {
  __typename: 'XeroIntegrationLineItem';
  /** Whether or not the repeating invoice line item was deleted. */
  deleted?: Maybe<Scalars['Boolean']['output']>;
  /** Description of the line item */
  description: Scalars['String']['output'];
  /** Discount amount */
  discountAmount: Money;
  /** Discount rate */
  discountRate?: Maybe<Scalars['Float']['output']>;
  /** Internal slug of the repeating invoice line item */
  id: Scalars['ID']['output'];
  /** Item code */
  itemCode?: Maybe<Scalars['String']['output']>;
  /** Name of associated item (if present) */
  itemName?: Maybe<Scalars['String']['output']>;
  /** Line amount */
  lineAmount: Money;
  /** Quantity */
  quantity?: Maybe<Scalars['Float']['output']>;
  /** Tax amount */
  taxAmount: Money;
  /** Tax Type */
  taxType?: Maybe<Scalars['String']['output']>;
  /** Unit amount */
  unitAmount: Money;
};

export type XeroIntegrationRepeatingInvoice = {
  __typename: 'XeroIntegrationRepeatingInvoice';
  /** List of jobs associated with the repeating invoice */
  asyncJobs?: Maybe<Array<AsyncJob>>;
  /** Name of the Contact associated with the repeating invoice */
  contactName?: Maybe<Scalars['String']['output']>;
  /** Whether or not the repeating invoice was deleted. */
  deleted?: Maybe<Scalars['Boolean']['output']>;
  /** When do we finish invoicing (optional) */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** External URL for repeating invoice */
  externalUrl?: Maybe<Scalars['String']['output']>;
  /** Internal slug of the repeating invoice */
  id: Scalars['ID']['output'];
  /** List of Xero Repeating Invoice Line Items */
  lineItems?: Maybe<Array<XeroIntegrationLineItem>>;
  /** When is the next invoice being generated */
  nextScheduledDate: Scalars['Date']['output'];
  /** Weekly or monthly frequency */
  period: Scalars['Int']['output'];
  /** Total cost */
  total: Money;
  /** WEEKLY or MONTHLY */
  unit: Scalars['String']['output'];
  /** Customer added string to refer to the repeating invoice */
  xeroReference?: Maybe<Scalars['String']['output']>;
  /** External Xero ID of the repeating invoice */
  xeroRepeatingInvoiceId: Scalars['String']['output'];
};

export enum XeroState {
  ACTIVE = 'ACTIVE',
  DISCONNECTED = 'DISCONNECTED',
  INACTIVE = 'INACTIVE',
  UNAVAILABLE = 'UNAVAILABLE',
}

/** The connection type for TaxRateMapping. */
export type XeroTaxRateMappingConnectionType = {
  __typename: 'XeroTaxRateMappingConnectionType';
  areAllMapped: Scalars['Boolean']['output'];
  /** A list of edges. */
  edges: Array<TaxRateMappingEdge>;
  /** A list of nodes. */
  nodes: Array<TaxRateMapping>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of XeroTaxRateMappingCreate */
export type XeroTaxRateMappingCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** UUID of pi tax */
  ignitionappTaxId: Scalars['ID']['input'];
  /** UUID of tax rate */
  taxRateId: Scalars['ID']['input'];
};

/** Autogenerated return type of XeroTaxRateMappingCreate. */
export type XeroTaxRateMappingCreatePayload = {
  __typename: 'XeroTaxRateMappingCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  xero?: Maybe<Xero>;
};

export type XeroTaxRateMappingInput = {
  /** UUID of PI Tax */
  ignitionappTaxId: Scalars['ID']['input'];
  /** UUID of Tax Rate */
  taxRateId: Scalars['ID']['input'];
};

/** Autogenerated input type of XeroTaxRateMappingsUpdate */
export type XeroTaxRateMappingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  mappings: Array<XeroTaxRateMappingInput>;
};

/** Autogenerated return type of XeroTaxRateMappingsUpdate. */
export type XeroTaxRateMappingsUpdatePayload = {
  __typename: 'XeroTaxRateMappingsUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  xero?: Maybe<Xero>;
};

/** A Xero tracking category */
export type XeroTrackingCategory = {
  __typename: 'XeroTrackingCategory';
  /** The available options for this tracking category */
  availableOptions: Array<XeroTrackingCategoryOption>;
  /** Id of the category from Xero */
  id: Scalars['ID']['output'];
  /** Name of the category from Xero */
  name: Scalars['String']['output'];
  /** The tracking option that has been selected for this client */
  selectedOption?: Maybe<XeroTrackingCategoryOption>;
};

/** A Xero tracking category option */
export type XeroTrackingCategoryOption = {
  __typename: 'XeroTrackingCategoryOption';
  /** The id of this option from Xero */
  id: Scalars['String']['output'];
  /** The name of the tracking option (as created in Xero at the last sync) */
  name: Scalars['String']['output'];
};

/** Autogenerated return type of aiTextGenerationSessionTextGenerated. */
export type AiTextGenerationSessionTextGeneratedPayload = {
  __typename: 'aiTextGenerationSessionTextGeneratedPayload';
  session?: Maybe<Session>;
};

/** Autogenerated return type of capabilitiesProposalImportProposalsAvailable. */
export type CapabilitiesProposalImportProposalsAvailablePayload = {
  __typename: 'capabilitiesProposalImportProposalsAvailablePayload';
  /** Name of the ledger which has available proposals */
  appName: Scalars['String']['output'];
};

/** Autogenerated input type of clientWorkflowItemStartDeployment */
export type ClientWorkflowItemStartDeploymentInput = {
  /** If true, allows starting a new deployment even if the workflow item has already been deployed. */
  allowRedeploy?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of workflow item */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of clientWorkflowItemStartDeployment. */
export type ClientWorkflowItemStartDeploymentPayload = {
  __typename: 'clientWorkflowItemStartDeploymentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deployment?: Maybe<ClientWorkflowItemDeployment>;
  workflowItem?: Maybe<ClientWorkflowItem>;
  workflowStrategy?: Maybe<ClientWorkflowStrategy>;
};

/** Autogenerated input type of clientWorkflowStrategyCreate */
export type ClientWorkflowStrategyCreateInput = {
  /** The name of the workflow app this will be deployed to. */
  appName: Scalars['String']['input'];
  /** The ID of the client. */
  clientId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The duration of each workflow item. This is used to calculate the end date of
   * each workflow item, based on their start dates.
   */
  duration?: InputMaybe<DurationInput>;
  /** The name of the workflow strategy. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Defines how the workflow item schedule will recurr. Defaults to a single occurrence. */
  recurrenceRule?: InputMaybe<Scalars['RecurrenceRuleInput']['input']>;
  /** The date from which the workflow item schedule should start. Defaults to the current date. */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Autogenerated return type of clientWorkflowStrategyCreate. */
export type ClientWorkflowStrategyCreatePayload = {
  __typename: 'clientWorkflowStrategyCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  workflowStrategy?: Maybe<ClientWorkflowStrategy>;
};

/** Autogenerated input type of clientWorkflowStrategyDeactivate */
export type ClientWorkflowStrategyDeactivateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The slug of the workflow strategy being deactivated. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of clientWorkflowStrategyDeactivate. */
export type ClientWorkflowStrategyDeactivatePayload = {
  __typename: 'clientWorkflowStrategyDeactivatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  workflowStrategy?: Maybe<ClientWorkflowStrategy>;
};

/** Autogenerated input type of clientWorkflowStrategyDelete */
export type ClientWorkflowStrategyDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of workflow strategy to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of clientWorkflowStrategyDelete. */
export type ClientWorkflowStrategyDeletePayload = {
  __typename: 'clientWorkflowStrategyDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  workflowStrategies: ClientWorkflowStrategyConnection;
};

/** Autogenerated return type of clientWorkflowStrategyDelete. */
export type ClientWorkflowStrategyDeletePayloadWorkflowStrategiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of clientWorkflowStrategyDuplicate */
export type ClientWorkflowStrategyDuplicateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of workflow strategy to duplicate. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of clientWorkflowStrategyDuplicate. */
export type ClientWorkflowStrategyDuplicatePayload = {
  __typename: 'clientWorkflowStrategyDuplicatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  workflowStrategy?: Maybe<ClientWorkflowStrategy>;
};

/** Autogenerated input type of clientWorkflowStrategySetBillingGroup */
export type ClientWorkflowStrategySetBillingGroupInput = {
  /** Slug of the billing group */
  billingGroupId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of the workflow strategy */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of clientWorkflowStrategySetBillingGroup. */
export type ClientWorkflowStrategySetBillingGroupPayload = {
  __typename: 'clientWorkflowStrategySetBillingGroupPayload';
  client: Client;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  workflowStrategy: ClientWorkflowStrategy;
};

/** Autogenerated input type of clientWorkflowStrategySetClientBillingGroup */
export type ClientWorkflowStrategySetClientBillingGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of the workflow strategy */
  id: Scalars['ID']['input'];
  /**
   * A billing group can only be assigned to one active workflow at a time.
   *
   * If another workflow strategy is already configured to use this billing group,
   * by default it will return an error. Specify replaceExisting to override this
   * and move the billing group to this workflow strategy.
   */
  replaceExisting?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of clientWorkflowStrategySetClientBillingGroup. */
export type ClientWorkflowStrategySetClientBillingGroupPayload = {
  __typename: 'clientWorkflowStrategySetClientBillingGroupPayload';
  client: Client;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  workflowStrategy: ClientWorkflowStrategy;
};

/** Autogenerated input type of clientWorkflowStrategySetDeployStrategy */
export type ClientWorkflowStrategySetDeployStrategyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  deployStrategy: ClientWorkflowStrategyDeployStrategy;
  /** Workflow strategy slug */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of clientWorkflowStrategySetDeployStrategy. */
export type ClientWorkflowStrategySetDeployStrategyPayload = {
  __typename: 'clientWorkflowStrategySetDeployStrategyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  workflowStrategy?: Maybe<ClientWorkflowStrategy>;
};

/** Autogenerated input type of clientWorkflowStrategySetGeneralSettings */
export type ClientWorkflowStrategySetGeneralSettingsInput = {
  budget?: InputMaybe<MoneyInput>;
  /** IDs of the workflow categories */
  categoryIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  /** Slug of workflow strategy */
  id: Scalars['ID']['input'];
  /** ID of the manager user */
  managerId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  /** ID of the partner user */
  partnerId?: InputMaybe<Scalars['ID']['input']>;
  /** IDs of the staff users */
  staffIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** IDs of the workflow templates */
  templateIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of clientWorkflowStrategySetGeneralSettings. */
export type ClientWorkflowStrategySetGeneralSettingsPayload = {
  __typename: 'clientWorkflowStrategySetGeneralSettingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  workflowStrategy?: Maybe<ClientWorkflowStrategy>;
};

/** Autogenerated input type of clientWorkflowStrategySetOneTimeSchedule */
export type ClientWorkflowStrategySetOneTimeScheduleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When the workflow item is scheduled to start. */
  date?: InputMaybe<Scalars['Date']['input']>;
  /**
   * Duration of the workflow item. This is used in combination with
   * the start date to calculate the end date of the workflow item.
   */
  duration: DurationInput;
  /** Slug of the workflow strategy. */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of clientWorkflowStrategySetOneTimeSchedule. */
export type ClientWorkflowStrategySetOneTimeSchedulePayload = {
  __typename: 'clientWorkflowStrategySetOneTimeSchedulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  workflowStrategy?: Maybe<ClientWorkflowStrategy>;
};

/** Autogenerated input type of clientWorkflowStrategySetRecurringSchedule */
export type ClientWorkflowStrategySetRecurringScheduleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Duration of the workflow items. This is used in combination with
   * the start date to calculate the end date of each workflow item.
   */
  duration: DurationInput;
  /** Slug of workflow strategy */
  id: Scalars['ID']['input'];
  /** Recurrence rule in iCal/RRULE format. */
  recurrenceRule: Scalars['RecurrenceRuleInput']['input'];
  /** Date from which the schedule starts recurring. */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Autogenerated return type of clientWorkflowStrategySetRecurringSchedule. */
export type ClientWorkflowStrategySetRecurringSchedulePayload = {
  __typename: 'clientWorkflowStrategySetRecurringSchedulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  workflowStrategy?: Maybe<ClientWorkflowStrategy>;
};

/** Autogenerated input type of clientWorkflowStrategyUnsetBillingGroup */
export type ClientWorkflowStrategyUnsetBillingGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Slug of the workflow strategy */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of clientWorkflowStrategyUnsetBillingGroup. */
export type ClientWorkflowStrategyUnsetBillingGroupPayload = {
  __typename: 'clientWorkflowStrategyUnsetBillingGroupPayload';
  client: Client;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  workflowStrategy: ClientWorkflowStrategy;
};

/** Autogenerated input type of enhanceAiServiceDescription */
export type EnhanceAiServiceDescriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Enhancement type */
  enhancementType: ServiceDescriptionEnhancementType;
  /** Service ID */
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  /** Service Name */
  serviceName: Scalars['String']['input'];
  /** Text Generation Session ID */
  sessionId: Scalars['ID']['input'];
};

/** Autogenerated return type of enhanceAiServiceDescription. */
export type EnhanceAiServiceDescriptionPayload = {
  __typename: 'enhanceAiServiceDescriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  session?: Maybe<Session>;
};

/** Autogenerated return type of paymentCollected. */
export type PaymentCollectedPayload = {
  __typename: 'paymentCollectedPayload';
  /** True if this is the first collected payment for the practice */
  isFirstPayment: Scalars['Boolean']['output'];
  /** The collected payment */
  payment: Payment;
};

/** Autogenerated return type of paymentDisbursed. */
export type PaymentDisbursedPayload = {
  __typename: 'paymentDisbursedPayload';
  /** True if this is the first disbursed payment for the practice */
  isFirstPayment: Scalars['Boolean']['output'];
  /** The disbursed payment */
  payment: Payment;
};

/** Autogenerated return type of paymentStarted. */
export type PaymentStartedPayload = {
  __typename: 'paymentStartedPayload';
  /** True if this is the first started payment for the practice */
  isFirstPayment: Scalars['Boolean']['output'];
  /** The started payment */
  payment: Payment;
};

/** Autogenerated input type of practiceBillingCancelSubscription */
export type PracticeBillingCancelSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  exitSurvey: ExitSurveyInputType;
};

/** Autogenerated return type of practiceBillingCancelSubscription. */
export type PracticeBillingCancelSubscriptionPayload = {
  __typename: 'practiceBillingCancelSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  exitSurvey: ExitSurvey;
  practice: Practice;
};

/** Autogenerated input type of practiceBillingReportPaymentChallengeError */
export type PracticeBillingReportPaymentChallengeErrorInput = {
  /** The name of the App that generated this payment challenge */
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The error code received while attempting to resolve a 3DS challenge */
  errorCode?: InputMaybe<Scalars['String']['input']>;
  /** The error message received while attempting to resolve a 3DS challenge */
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  /** Request that the payment challenge be marked as failed */
  failChallenge: Scalars['Boolean']['input'];
  /** The id of the payment challenge with an error */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of practiceBillingReportPaymentChallengeError. */
export type PracticeBillingReportPaymentChallengeErrorPayload = {
  __typename: 'practiceBillingReportPaymentChallengeErrorPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice: Practice;
};

/** Autogenerated input type of practiceBillingResolvePaymentChallenge */
export type PracticeBillingResolvePaymentChallengeInput = {
  /** The name of the App that generated this payment challenge */
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the payment challenge being resolved */
  id: Scalars['ID']['input'];
  /** App-specific token that resolves the payment challenge */
  token: Scalars['String']['input'];
};

/** Autogenerated return type of practiceBillingResolvePaymentChallenge. */
export type PracticeBillingResolvePaymentChallengePayload = {
  __typename: 'practiceBillingResolvePaymentChallengePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice: Practice;
};

/** Autogenerated input type of practiceBillingSetSubscription */
export type PracticeBillingSetSubscriptionInput = {
  billingInfo?: InputMaybe<PracticeBillingBillingInfoInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  couponCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  paymentMethod?: InputMaybe<PracticeBillingPaymentMethodInput>;
  plan?: InputMaybe<PracticeBillingPlanInput>;
};

/** Autogenerated return type of practiceBillingSetSubscription. */
export type PracticeBillingSetSubscriptionPayload = {
  __typename: 'practiceBillingSetSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice: Practice;
};

/** Autogenerated return type of proposalAccepted. */
export type ProposalAcceptedPayload = {
  __typename: 'proposalAcceptedPayload';
  /** True if this is the first accepted proposal for the practice */
  isFirstProposal: Scalars['Boolean']['output'];
  /** The accepted proposal */
  proposal: Proposal;
};

/** Autogenerated input type of proposalAddWorkflowStrategy */
export type ProposalAddWorkflowStrategyInput = {
  /** The workflow app this workflow will be deployed to. */
  appName?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalAddWorkflowStrategy. */
export type ProposalAddWorkflowStrategyPayload = {
  __typename: 'proposalAddWorkflowStrategyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalAddWorkflowStrategyStaff */
export type ProposalAddWorkflowStrategyStaffInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Staff ID */
  userId: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalAddWorkflowStrategyStaff. */
export type ProposalAddWorkflowStrategyStaffPayload = {
  __typename: 'proposalAddWorkflowStrategyStaffPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalAddWorkflowStrategyTemplate */
export type ProposalAddWorkflowStrategyTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Template ID */
  templateId: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalAddWorkflowStrategyTemplate. */
export type ProposalAddWorkflowStrategyTemplatePayload = {
  __typename: 'proposalAddWorkflowStrategyTemplatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalArchive */
export type ProposalArchiveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalArchive. */
export type ProposalArchivePayload = {
  __typename: 'proposalArchivePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal: Proposal;
};

/** Autogenerated input type of proposalDuplicate */
export type ProposalDuplicateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalDuplicate. */
export type ProposalDuplicatePayload = {
  __typename: 'proposalDuplicatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of proposalIncreaseServicePrices */
export type ProposalIncreaseServicePricesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal to increase prices of */
  id: Scalars['ID']['input'];
  priceIncreaseInput: PriceIncreaseInputType;
};

/** Autogenerated return type of proposalIncreaseServicePrices. */
export type ProposalIncreaseServicePricesPayload = {
  __typename: 'proposalIncreaseServicePricesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of proposalMarkAsLost */
export type ProposalMarkAsLostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalMarkAsLost. */
export type ProposalMarkAsLostPayload = {
  __typename: 'proposalMarkAsLostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal: Proposal;
};

/** Autogenerated input type of proposalOptionDuplicate */
export type ProposalOptionDuplicateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
  /** slug of the option to duplicate */
  optionId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalOptionDuplicate. */
export type ProposalOptionDuplicatePayload = {
  __typename: 'proposalOptionDuplicatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** the copy of option */
  option?: Maybe<ProposalOption>;
  proposal: Proposal;
};

/** Autogenerated input type of proposalRemoveWorkflowStrategy */
export type ProposalRemoveWorkflowStrategyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalRemoveWorkflowStrategy. */
export type ProposalRemoveWorkflowStrategyPayload = {
  __typename: 'proposalRemoveWorkflowStrategyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of proposalRemoveWorkflowStrategyStaff */
export type ProposalRemoveWorkflowStrategyStaffInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Staff ID */
  userId: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalRemoveWorkflowStrategyStaff. */
export type ProposalRemoveWorkflowStrategyStaffPayload = {
  __typename: 'proposalRemoveWorkflowStrategyStaffPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalRemoveWorkflowStrategyTemplate */
export type ProposalRemoveWorkflowStrategyTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Template id */
  templateId: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalRemoveWorkflowStrategyTemplate. */
export type ProposalRemoveWorkflowStrategyTemplatePayload = {
  __typename: 'proposalRemoveWorkflowStrategyTemplatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalRenewBulk */
export type ProposalRenewBulkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slugs of the proposals to renew */
  ids: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of proposalRenewBulk. */
export type ProposalRenewBulkPayload = {
  __typename: 'proposalRenewBulkPayload';
  asyncJobGroup: AsyncJobGroup;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of proposalRenew */
export type ProposalRenewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal to be renewed */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalRenew. */
export type ProposalRenewPayload = {
  __typename: 'proposalRenewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of proposalRevoke */
export type ProposalRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slug of the proposal */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalRevoke. */
export type ProposalRevokePayload = {
  __typename: 'proposalRevokePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal: Proposal;
};

/** Autogenerated input type of proposalSendToClientBulk */
export type ProposalSendToClientBulkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** slugs of the proposals to send */
  ids: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of proposalSendToClientBulk. */
export type ProposalSendToClientBulkPayload = {
  __typename: 'proposalSendToClientBulkPayload';
  asyncJobGroup: AsyncJobGroup;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of proposalSetWorkflowStrategyBudget */
export type ProposalSetWorkflowStrategyBudgetInput = {
  budget: MoneyInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalSetWorkflowStrategyBudget. */
export type ProposalSetWorkflowStrategyBudgetPayload = {
  __typename: 'proposalSetWorkflowStrategyBudgetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalSetWorkflowStrategyCategories */
export type ProposalSetWorkflowStrategyCategoriesInput = {
  /** IDs of the workflow categories */
  categoryIds: Array<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalSetWorkflowStrategyCategories. */
export type ProposalSetWorkflowStrategyCategoriesPayload = {
  __typename: 'proposalSetWorkflowStrategyCategoriesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalSetWorkflowStrategyDescription */
export type ProposalSetWorkflowStrategyDescriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalSetWorkflowStrategyDescription. */
export type ProposalSetWorkflowStrategyDescriptionPayload = {
  __typename: 'proposalSetWorkflowStrategyDescriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalSetWorkflowStrategyDuration */
export type ProposalSetWorkflowStrategyDurationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  duration: DurationInput;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalSetWorkflowStrategyDuration. */
export type ProposalSetWorkflowStrategyDurationPayload = {
  __typename: 'proposalSetWorkflowStrategyDurationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalSetWorkflowStrategyManager */
export type ProposalSetWorkflowStrategyManagerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** ID of the manager user */
  userId: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalSetWorkflowStrategyManager. */
export type ProposalSetWorkflowStrategyManagerPayload = {
  __typename: 'proposalSetWorkflowStrategyManagerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalSetWorkflowStrategyName */
export type ProposalSetWorkflowStrategyNameInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalSetWorkflowStrategyName. */
export type ProposalSetWorkflowStrategyNamePayload = {
  __typename: 'proposalSetWorkflowStrategyNamePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalSetWorkflowStrategyPartner */
export type ProposalSetWorkflowStrategyPartnerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** ID of the partner user */
  userId: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalSetWorkflowStrategyPartner. */
export type ProposalSetWorkflowStrategyPartnerPayload = {
  __typename: 'proposalSetWorkflowStrategyPartnerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalSetWorkflowStrategyRecurrenceOnce */
export type ProposalSetWorkflowStrategyRecurrenceOnceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalSetWorkflowStrategyRecurrenceOnce. */
export type ProposalSetWorkflowStrategyRecurrenceOncePayload = {
  __typename: 'proposalSetWorkflowStrategyRecurrenceOncePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalSetWorkflowStrategyRecurring */
export type ProposalSetWorkflowStrategyRecurringInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  recurrenceRule: Scalars['RecurrenceRuleInput']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalSetWorkflowStrategyRecurring. */
export type ProposalSetWorkflowStrategyRecurringPayload = {
  __typename: 'proposalSetWorkflowStrategyRecurringPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalSetWorkflowStrategyStartOnDate */
export type ProposalSetWorkflowStrategyStartOnDateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Start on date */
  date: Scalars['Date']['input'];
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalSetWorkflowStrategyStartOnDate. */
export type ProposalSetWorkflowStrategyStartOnDatePayload = {
  __typename: 'proposalSetWorkflowStrategyStartOnDatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalSetWorkflowStrategyTemplates */
export type ProposalSetWorkflowStrategyTemplatesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** IDs of the workflow templates */
  templateIds: Array<Scalars['ID']['input']>;
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalSetWorkflowStrategyTemplates. */
export type ProposalSetWorkflowStrategyTemplatesPayload = {
  __typename: 'proposalSetWorkflowStrategyTemplatesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalSignOnBehalfForAll */
export type ProposalSignOnBehalfForAllInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** id of the proposal */
  id: Scalars['ID']['input'];
  /** payment method id */
  paymentMethodId?: InputMaybe<Scalars['ID']['input']>;
  /** reason the contract is being signed on behalf of the signatories */
  reason: Scalars['String']['input'];
};

/** Autogenerated return type of proposalSignOnBehalfForAll. */
export type ProposalSignOnBehalfForAllPayload = {
  __typename: 'proposalSignOnBehalfForAllPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal: Proposal;
};

/** Autogenerated input type of proposalUnsetWorkflowStrategyManager */
export type ProposalUnsetWorkflowStrategyManagerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalUnsetWorkflowStrategyManager. */
export type ProposalUnsetWorkflowStrategyManagerPayload = {
  __typename: 'proposalUnsetWorkflowStrategyManagerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalUnsetWorkflowStrategyPartner */
export type ProposalUnsetWorkflowStrategyPartnerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalUnsetWorkflowStrategyPartner. */
export type ProposalUnsetWorkflowStrategyPartnerPayload = {
  __typename: 'proposalUnsetWorkflowStrategyPartnerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalWorkflowSettingsSetDeployStrategy */
export type ProposalWorkflowSettingsSetDeployStrategyInput = {
  /** The deploy strategy will apply to workflows creates for this app. */
  appName: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  deployStrategy: ProposalWorkflowSettingsDeployStrategy;
  /** Proposal slug */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalWorkflowSettingsSetDeployStrategy. */
export type ProposalWorkflowSettingsSetDeployStrategyPayload = {
  __typename: 'proposalWorkflowSettingsSetDeployStrategyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowSettings?: Maybe<WorkflowSettings>;
};

/** Autogenerated input type of proposalWorkflowStrategySetClientBillingGroup */
export type ProposalWorkflowStrategySetClientBillingGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalWorkflowStrategySetClientBillingGroup. */
export type ProposalWorkflowStrategySetClientBillingGroupPayload = {
  __typename: 'proposalWorkflowStrategySetClientBillingGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalWorkflowStrategySetProjectBillingGroup */
export type ProposalWorkflowStrategySetProjectBillingGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Slug of the project */
  projectId: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalWorkflowStrategySetProjectBillingGroup. */
export type ProposalWorkflowStrategySetProjectBillingGroupPayload = {
  __typename: 'proposalWorkflowStrategySetProjectBillingGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalWorkflowStrategySetProposalBillingGroup */
export type ProposalWorkflowStrategySetProposalBillingGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalWorkflowStrategySetProposalBillingGroup. */
export type ProposalWorkflowStrategySetProposalBillingGroupPayload = {
  __typename: 'proposalWorkflowStrategySetProposalBillingGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalWorkflowStrategyStartOnAcceptance */
export type ProposalWorkflowStrategyStartOnAcceptanceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  delay: DurationInput;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalWorkflowStrategyStartOnAcceptance. */
export type ProposalWorkflowStrategyStartOnAcceptancePayload = {
  __typename: 'proposalWorkflowStrategyStartOnAcceptancePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalWorkflowStrategyStartOnProposalStart */
export type ProposalWorkflowStrategyStartOnProposalStartInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  delay: DurationInput;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalWorkflowStrategyStartOnProposalStart. */
export type ProposalWorkflowStrategyStartOnProposalStartPayload = {
  __typename: 'proposalWorkflowStrategyStartOnProposalStartPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal: Proposal;
  workflowStrategy: WorkflowStrategy;
};

/** Autogenerated input type of proposalWorkflowStrategyUnsetBillingGroup */
export type ProposalWorkflowStrategyUnsetBillingGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Proposal slug */
  id: Scalars['ID']['input'];
  /** Workflow Strategy slug */
  workflowStrategyId: Scalars['ID']['input'];
};

/** Autogenerated return type of proposalWorkflowStrategyUnsetBillingGroup. */
export type ProposalWorkflowStrategyUnsetBillingGroupPayload = {
  __typename: 'proposalWorkflowStrategyUnsetBillingGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
  workflowStrategy?: Maybe<WorkflowStrategy>;
};

/** Autogenerated input type of proposalsExport */
export type ProposalsExportInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** If provided, only proposals accepted or lost before this date will not be included. */
  endDate?: InputMaybe<Scalars['Date']['input']>;
  /** If provided, only proposals accepted or lost after this date will not be included. */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Autogenerated return type of proposalsExport. */
export type ProposalsExportPayload = {
  __typename: 'proposalsExportPayload';
  backgroundJob: BackgroundJob;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export type Quickbooks = {
  __typename: 'quickbooks';
  companyId?: Maybe<Scalars['ID']['output']>;
  items: QuickbooksItemConnection;
  lastSynced?: Maybe<Scalars['DateTime']['output']>;
  recurringTransactionsSearch?: Maybe<SearchQuery>;
  settings?: Maybe<QuickbooksSettings>;
  /** @deprecated Use apps() query and its userConfiguration.state instead. */
  state: QuickbooksState;
  /** @deprecated Use appTaxes query instead. */
  taxCodeMappings: QuickbooksTaxCodeMappingConnectionType;
  /** @deprecated Use appTaxes query instead. */
  taxCodes: Array<QuickbooksTaxCode>;
};

export type QuickbooksItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type QuickbooksRecurringTransactionsSearchArgs = {
  asyncJobGroupId?: InputMaybe<Scalars['ID']['input']>;
  filterWithConversionErrors?: InputMaybe<Scalars['Boolean']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  pagination?: InputMaybe<PaginationInput>;
  sort?: InputMaybe<SearchQuerySortInput>;
  type?: InputMaybe<Array<RecurringTransactionTypeEnum>>;
};

export type QuickbooksTaxCodeMappingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of quickbooksRecurringTransactionStopRemoteFailed. */
export type QuickbooksRecurringTransactionStopRemoteFailedPayload = {
  __typename: 'quickbooksRecurringTransactionStopRemoteFailedPayload';
  /** The associated proposal */
  proposal: Proposal;
  /** The recurring transaction which throws an error when we try to stop it */
  recurringTransaction: QuickbooksIntegrationRecurringTransaction;
};

/** Autogenerated input type of serviceGenerateAiServiceDescription */
export type ServiceGenerateAiServiceDescriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Service ID */
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  /** Service Name */
  serviceName: Scalars['String']['input'];
  /** Text Generation Session ID */
  sessionId: Scalars['ID']['input'];
};

/** Autogenerated return type of serviceGenerateAiServiceDescription. */
export type ServiceGenerateAiServiceDescriptionPayload = {
  __typename: 'serviceGenerateAiServiceDescriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  session?: Maybe<Session>;
};

export enum UserContentType {
  PROPOSAL_PROPOSED_SERVICE_DESCRIPTION = 'PROPOSAL_PROPOSED_SERVICE_DESCRIPTION',
  PROPOSAL_SERVICE_TERMS = 'PROPOSAL_SERVICE_TERMS',
  PROPOSAL_TERMS = 'PROPOSAL_TERMS',
}

/** Autogenerated return type of xeroRepeatingInvoiceStopRemoteFailed. */
export type XeroRepeatingInvoiceStopRemoteFailedPayload = {
  __typename: 'xeroRepeatingInvoiceStopRemoteFailedPayload';
  /** The associated proposal */
  proposal: Proposal;
  /** The repeating invoice which throws an error when we try to stop it */
  repeatingInvoice: XeroIntegrationRepeatingInvoice;
};

export type AcknowledgementAddMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  level: AcknowledgementLevel;
}>;

export type AcknowledgementAddMutation = {
  __typename: 'Mutation';
  acknowledgementAdd?: {
    __typename: 'AcknowledgementAddPayload';
    acknowledgements: Array<{
      __typename: 'Acknowledgement';
      id: string;
      level: AcknowledgementLevel;
      updatedAt: any;
    }>;
  };
};

export type AcknowledgementRemoveMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  level: AcknowledgementLevel;
}>;

export type AcknowledgementRemoveMutation = {
  __typename: 'Mutation';
  acknowledgementRemove?: {
    __typename: 'AcknowledgementRemovePayload';
    acknowledgements: Array<{
      __typename: 'Acknowledgement';
      id: string;
      level: AcknowledgementLevel;
      updatedAt: any;
    }>;
  };
};

export type AcknowledgementsQueryVariables = Exact<{ [key: string]: never }>;

export type AcknowledgementsQuery = {
  __typename: 'Query';
  acknowledgements: Array<{
    __typename: 'Acknowledgement';
    id: string;
    level: AcknowledgementLevel;
    updatedAt: any;
  }>;
};

export type CodeVersionQueryVariables = Exact<{ [key: string]: never }>;

export type CodeVersionQuery = { __typename: 'Query'; codeVersion: string };

export type CurrentPracticeQueryVariables = Exact<{ [key: string]: never }>;

export type CurrentPracticeQuery = {
  __typename: 'Query';
  currentPractice: {
    __typename: 'Practice';
    id: string;
    referenceNumber: string;
    name: string;
    countryCode: any;
  };
};
